<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lean Manual</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="alectryon.css">
        <link rel="stylesheet" href="pygments.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="whatIsLean.html"><strong aria-hidden="true">1.</strong> What is Lean</a></li><li class="chapter-item "><a href="tour.html"><strong aria-hidden="true">2.</strong> Tour of Lean</a></li><li class="chapter-item "><a href="quickstart.html"><strong aria-hidden="true">3.</strong> Setting Up Lean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="setup.html"><strong aria-hidden="true">3.1.</strong> Extended Setup Notes</a></li></ol></li><li class="chapter-item "><a href="tpil.html"><strong aria-hidden="true">4.</strong> Theorem Proving in Lean</a></li><li class="chapter-item "><a href="fplean.html"><strong aria-hidden="true">5.</strong> Functional Programming in Lean</a></li><li class="chapter-item "><a href="examples.html"><strong aria-hidden="true">6.</strong> Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="examples/palindromes.lean.html"><strong aria-hidden="true">6.1.</strong> Palindromes</a></li><li class="chapter-item "><a href="examples/bintree.lean.html"><strong aria-hidden="true">6.2.</strong> Binary Search Trees</a></li><li class="chapter-item "><a href="examples/tc.lean.html"><strong aria-hidden="true">6.3.</strong> A Certified Type Checker</a></li><li class="chapter-item "><a href="examples/interp.lean.html"><strong aria-hidden="true">6.4.</strong> The Well-Typed Interpreter</a></li><li class="chapter-item "><a href="examples/deBruijn.lean.html"><strong aria-hidden="true">6.5.</strong> Dependent de Bruijn Indices</a></li><li class="chapter-item "><a href="examples/phoas.lean.html"><strong aria-hidden="true">6.6.</strong> Parametric Higher-Order Abstract Syntax</a></li></ol></li><li class="chapter-item "><li class="part-title">Language Manual</li><li class="chapter-item "><a href="organization.html"><strong aria-hidden="true">7.</strong> Organizational features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sections.html"><strong aria-hidden="true">7.1.</strong> Sections</a></li><li class="chapter-item "><a href="namespaces.html"><strong aria-hidden="true">7.2.</strong> Namespaces</a></li><li class="chapter-item "><a href="implicit.html"><strong aria-hidden="true">7.3.</strong> Implicit Arguments</a></li><li class="chapter-item "><a href="autobound.html"><strong aria-hidden="true">7.4.</strong> Auto Bound Implicit Arguments</a></li></ol></li><li class="chapter-item "><a href="syntax.html"><strong aria-hidden="true">8.</strong> Syntax Extensions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="do.html"><strong aria-hidden="true">8.1.</strong> The do Notation</a></li><li class="chapter-item "><a href="stringinterp.html"><strong aria-hidden="true">8.2.</strong> String Interpolation</a></li><li class="chapter-item "><a href="notation.html"><strong aria-hidden="true">8.3.</strong> User-Defined Notation</a></li><li class="chapter-item "><a href="macro_overview.html"><strong aria-hidden="true">8.4.</strong> Macro Overview</a></li><li class="chapter-item "><a href="elaborators.html"><strong aria-hidden="true">8.5.</strong> Elaborators</a></li><li class="chapter-item "><a href="syntax_examples.html"><strong aria-hidden="true">8.6.</strong> Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="syntax_example.html"><strong aria-hidden="true">8.6.1.</strong> Balanced Parentheses</a></li><li class="chapter-item "><a href="metaprogramming-arith.html"><strong aria-hidden="true">8.6.2.</strong> Arithmetic DSL</a></li></ol></li></ol></li><li class="chapter-item "><a href="decltypes.html"><strong aria-hidden="true">9.</strong> Declaring New Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="enum.html"><strong aria-hidden="true">9.1.</strong> Enumerated Types</a></li><li class="chapter-item "><a href="inductive.html"><strong aria-hidden="true">9.2.</strong> Inductive Types</a></li><li class="chapter-item "><a href="struct.html"><strong aria-hidden="true">9.3.</strong> Structures</a></li><li class="chapter-item "><a href="typeclass.html"><strong aria-hidden="true">9.4.</strong> Type classes</a></li><li class="chapter-item "><a href="unifhint.html"><strong aria-hidden="true">9.5.</strong> Unification Hints</a></li></ol></li><li class="chapter-item "><a href="builtintypes.html"><strong aria-hidden="true">10.</strong> Builtin Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="nat.html"><strong aria-hidden="true">10.1.</strong> Natural number</a></li><li class="chapter-item "><a href="int.html"><strong aria-hidden="true">10.2.</strong> Integer</a></li><li class="chapter-item "><a href="uint.html"><strong aria-hidden="true">10.3.</strong> Fixed precision unsigned integer</a></li><li class="chapter-item "><a href="float.html"><strong aria-hidden="true">10.4.</strong> Float</a></li><li class="chapter-item "><a href="array.html"><strong aria-hidden="true">10.5.</strong> Array</a></li><li class="chapter-item "><a href="list.html"><strong aria-hidden="true">10.6.</strong> List</a></li><li class="chapter-item "><a href="char.html"><strong aria-hidden="true">10.7.</strong> Character</a></li><li class="chapter-item "><a href="string.html"><strong aria-hidden="true">10.8.</strong> String</a></li><li class="chapter-item "><a href="option.html"><strong aria-hidden="true">10.9.</strong> Option</a></li><li class="chapter-item "><a href="thunk.html"><strong aria-hidden="true">10.10.</strong> Thunk</a></li><li class="chapter-item "><a href="task.html"><strong aria-hidden="true">10.11.</strong> Task and Thread</a></li></ol></li><li class="chapter-item "><a href="functions.html"><strong aria-hidden="true">11.</strong> Functions</a></li><li class="chapter-item "><a href="monads/intro.html"><strong aria-hidden="true">12.</strong> Monads</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="monads/functors.lean.html"><strong aria-hidden="true">12.1.</strong> Functor</a></li><li class="chapter-item "><a href="monads/applicatives.lean.html"><strong aria-hidden="true">12.2.</strong> Applicative</a></li><li class="chapter-item "><a href="monads/monads.lean.html"><strong aria-hidden="true">12.3.</strong> Monad</a></li><li class="chapter-item "><a href="monads/readers.lean.html"><strong aria-hidden="true">12.4.</strong> Reader</a></li><li class="chapter-item "><a href="monads/states.lean.html"><strong aria-hidden="true">12.5.</strong> State</a></li><li class="chapter-item "><a href="monads/except.lean.html"><strong aria-hidden="true">12.6.</strong> Except</a></li><li class="chapter-item "><a href="monads/transformers.lean.html"><strong aria-hidden="true">12.7.</strong> Transformers</a></li><li class="chapter-item "><a href="monads/laws.lean.html"><strong aria-hidden="true">12.8.</strong> Laws</a></li></ol></li><li class="chapter-item "><li class="part-title">Other</li><li class="chapter-item "><a href="faq.html"><strong aria-hidden="true">13.</strong> Frequently Asked Questions</a></li><li class="chapter-item "><a href="lean3changes.html"><strong aria-hidden="true">14.</strong> Significant Changes from Lean 3</a></li><li class="chapter-item "><a href="syntax_highlight_in_latex.html"><strong aria-hidden="true">15.</strong> Syntax Highlighting Lean in LaTeX</a></li><li class="chapter-item "><a href="examples/widgets.lean.html"><strong aria-hidden="true">16.</strong> User Widgets</a></li><li class="chapter-item "><a href="semantic_highlighting.html"><strong aria-hidden="true">17.</strong> Semantic Highlighting</a></li><li class="chapter-item affix "><li class="part-title">Development</li><li class="chapter-item "><a href="dev/index.html"><strong aria-hidden="true">18.</strong> Development Guide</a></li><li class="chapter-item "><a href="make/index.html"><strong aria-hidden="true">19.</strong> Building Lean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="make/ubuntu.html"><strong aria-hidden="true">19.1.</strong> Ubuntu Setup</a></li><li class="chapter-item "><a href="make/osx-10.9.html"><strong aria-hidden="true">19.2.</strong> macOS Setup</a></li><li class="chapter-item "><a href="make/msys2.html"><strong aria-hidden="true">19.3.</strong> Windows MSYS2 Setup</a></li><li class="chapter-item "><a href="make/wsl.html"><strong aria-hidden="true">19.4.</strong> Windows with WSL</a></li></ol></li><li class="chapter-item "><a href="dev/bootstrap.html"><strong aria-hidden="true">20.</strong> Bootstrapping</a></li><li class="chapter-item "><a href="dev/testing.html"><strong aria-hidden="true">21.</strong> Testing</a></li><li class="chapter-item "><a href="dev/debugging.html"><strong aria-hidden="true">22.</strong> Debugging</a></li><li class="chapter-item "><a href="dev/commit_convention.html"><strong aria-hidden="true">23.</strong> Commit Convention</a></li><li class="chapter-item "><a href="dev/mdbook.html"><strong aria-hidden="true">24.</strong> Building This Manual</a></li><li class="chapter-item "><a href="dev/ffi.html"><strong aria-hidden="true">25.</strong> Foreign Function Interface</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leanprover/lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is-lean"><a class="header" href="#what-is-lean">What is Lean</a></h1>
<p>Lean is a functional programming language that makes it easy to
write correct and maintainable code.
You can also use Lean as an interactive theorem prover.</p>
<p>Lean programming primarily involves defining types and functions.
This allows your focus to remain on the problem domain and manipulating its data,
rather than the details of programming.</p>
<pre><code class="language-lean">-- Defines a function that takes a name and produces a greeting.
def getGreeting (name : String) := s!&quot;Hello, {name}! Isn't Lean great?&quot;

-- The `main` function is the entry point of your program.
-- Its type is `IO Unit` because it can perform `IO` operations (side effects).
def main : IO Unit :=
  -- Define a list of names
  let names := [&quot;Sebastian&quot;, &quot;Leo&quot;, &quot;Daniel&quot;]

  -- Map each name to a greeting
  let greetings := names.map getGreeting

  -- Print the list of greetings
  for greeting in greetings do
    IO.println greeting
</code></pre>
<p>Lean has numerous features, including:</p>
<ul>
<li>Type inference</li>
<li>First-class functions</li>
<li>Powerful data types</li>
<li>Pattern matching</li>
<li><a href="./typeclass.html">Type classes</a></li>
<li><a href="./monads/intro.html">Monads</a></li>
<li><a href="./syntax.html">Extensible syntax</a></li>
<li>Hygienic macros</li>
<li><a href="https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html">Dependent types</a></li>
<li><a href="./metaprogramming.html">Metaprogramming</a></li>
<li>Multithreading</li>
<li>Verification: you can prove properties of your functions using Lean itself</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tour-of-lean"><a class="header" href="#tour-of-lean">Tour of Lean</a></h1>
<p>The best way to learn about Lean is to read and write Lean code.
This article will act as a tour through some of the key features of the Lean
language and give you some code snippets that you can execute on your machine.
To learn about setting up a development environment, check out <a href="./setup.html">Setting Up Lean</a>.</p>
<p>There are two primary concepts in Lean: functions and types.
This tour will emphasize features of the language which fall into
these two concepts.</p>
<h1 id="functions-and-namespaces"><a class="header" href="#functions-and-namespaces">Functions and Namespaces</a></h1>
<p>The most fundamental pieces of any Lean program are functions organized into namespaces.
<a href="./functions.html">Functions</a> perform work on inputs to produce outputs,
and they are organized under <a href="./namespaces.html">namespaces</a>,
which are the primary way you group things in Lean.
They are defined using the <a href="./definitions.html"><code>def</code></a> command,
which give the function a name and define its arguments.</p>
<pre><code class="language-lean">namespace BasicFunctions

-- The `#eval` command evaluates an expression on the fly and prints the result.
#eval 2+2

-- You use 'def' to define a function. This one accepts a natural number
-- and returns a natural number.
-- Parentheses are optional for function arguments, except for when
-- you use an explicit type annotation.
-- Lean can often infer the type of the function's arguments.
def sampleFunction1 x := x*x + 3

-- Apply the function, naming the function return result using 'def'.
-- The variable type is inferred from the function return type.
def result1 := sampleFunction1 4573

-- This line uses an interpolated string to print the result. Expressions inside
-- braces `{}` are converted into strings using the polymorphic method `toString`
#eval println! &quot;The result of squaring the integer 4573 and adding 3 is {result1}&quot;

-- When needed, annotate the type of a parameter name using '(argument : type)'.
def sampleFunction2 (x : Nat) := 2*x*x - x + 3

def result2 := sampleFunction2 (7 + 4)

#eval println! &quot;The result of applying the 2nd sample function to (7 + 4) is {result2}&quot;

-- Conditionals use if/then/else
def sampleFunction3 (x : Int) :=
  if x &gt; 100 then
    2*x*x - x + 3
  else
    2*x*x + x - 37

#eval println! &quot;The result of applying sampleFunction3 to 2 is {sampleFunction3 2}&quot;

end BasicFunctions
</code></pre>
<pre><code class="language-lean">-- Lean has first-class functions.
-- `twice` takes two arguments `f` and `a` where
-- `f` is a function from natural numbers to natural numbers, and
-- `a` is a natural number.
def twice (f : Nat → Nat) (a : Nat) :=
  f (f a)

-- `fun` is used to declare anonymous functions
#eval twice (fun x =&gt; x + 2) 10

-- You can prove theorems about your functions.
-- The following theorem states that for any natural number `a`,
-- adding 2 twice produces a value equal to `a + 4`.
theorem twiceAdd2 (a : Nat) : twice (fun x =&gt; x + 2) a = a + 4 :=
  -- The proof is by reflexivity. Lean &quot;symbolically&quot; reduces both sides of the equality
  -- until they are identical.
  rfl

-- `(· + 2)` is syntax sugar for `(fun x =&gt; x + 2)`. The parentheses + `·` notation
-- is useful for defining simple anonymous functions.
#eval twice (· + 2) 10

-- Enumerated types are a special case of inductive types in Lean,
-- which we will learn about later.
-- The following command creates a new type `Weekday`.
inductive Weekday where
  | sunday    : Weekday
  | monday    : Weekday
  | tuesday   : Weekday
  | wednesday : Weekday
  | thursday  : Weekday
  | friday    : Weekday
  | saturday  : Weekday

-- `Weekday` has 7 constructors/elements.
-- The constructors live in the `Weekday` namespace.
-- Think of `sunday`, `monday`, …, `saturday` as being distinct elements of `Weekday`,
-- with no other distinguishing properties.
-- The command `#check` prints the type of a term in Lean.
#check Weekday.sunday
#check Weekday.monday

-- The `open` command opens a namespace, making all declarations in it accessible without
-- qualification.
open Weekday
#check sunday
#check tuesday

-- You can define functions by pattern matching.
-- The following function converts a `Weekday` into a natural number.
def natOfWeekday (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

#eval natOfWeekday tuesday

def isMonday : Weekday → Bool :=
  -- `fun` + `match`  is a common idiom.
  -- The following expression is syntax sugar for
  -- `fun d =&gt; match d with | monday =&gt; true | _ =&gt; false`.
  fun
    | monday =&gt; true
    | _      =&gt; false

#eval isMonday monday
#eval isMonday sunday

-- Lean has support for type classes and polymorphic methods.
-- The `toString` method converts a value into a `String`.
#eval toString 10
#eval toString (10, 20)

-- The method `toString` converts values of any type that implements
-- the class `ToString`.
-- You can implement instances of `ToString` for your own types.
instance : ToString Weekday where
  toString (d : Weekday) : String :=
    match d with
    | sunday    =&gt; &quot;Sunday&quot;
    | monday    =&gt; &quot;Monday&quot;
    | tuesday   =&gt; &quot;Tuesday&quot;
    | wednesday =&gt; &quot;Wednesday&quot;
    | thursday  =&gt; &quot;Thursday&quot;
    | friday    =&gt; &quot;Friday&quot;
    | saturday  =&gt; &quot;Saturday&quot;

#eval toString (sunday, 10)

def Weekday.next (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; monday
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; saturday
  | saturday  =&gt; sunday

#eval Weekday.next Weekday.wednesday
-- Since the `Weekday` namespace has already been opened, you can also write
#eval next wednesday

-- Matching on a parameter like in the previous definition
-- is so common that Lean provides syntax sugar for it. The following
-- function uses it.
def Weekday.previous : Weekday -&gt; Weekday
  | sunday    =&gt; saturday
  | monday    =&gt; sunday
  | tuesday   =&gt; monday
  | wednesday =&gt; tuesday
  | thursday  =&gt; wednesday
  | friday    =&gt; thursday
  | saturday  =&gt; friday

#eval next (previous wednesday)

-- We can prove that for any `Weekday` `d`, `next (previous d) = d`
theorem Weekday.nextOfPrevious (d : Weekday) : next (previous d) = d :=
  match d with
  | sunday    =&gt; rfl
  | monday    =&gt; rfl
  | tuesday   =&gt; rfl
  | wednesday =&gt; rfl
  | thursday  =&gt; rfl
  | friday    =&gt; rfl
  | saturday  =&gt; rfl

-- You can automate definitions such as `Weekday.nextOfPrevious`
-- using metaprogramming (or &quot;tactics&quot;).
theorem Weekday.nextOfPrevious' (d : Weekday) : next (previous d) = d := by
  cases d       -- A proof by case distinction
  all_goals rfl  -- Each case is solved using `rfl`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>These instructions will walk you through setting up Lean 4 together with VS Code as an editor for Lean 4.
See <a href="./setup.html">Setup</a> for supported platforms and other ways to set up Lean 4.</p>
<ol>
<li>
<p>Install <a href="https://code.visualstudio.com/">VS Code</a>.</p>
</li>
<li>
<p>Launch VS Code and install the <code>lean4</code> extension by clicking on the &quot;Extensions&quot; sidebar entry and searching for &quot;lean4&quot;.</p>
<p><img src="images/code-ext.png" alt="installing the vscode-lean4 extension" /></p>
</li>
<li>
<p>Open the Lean 4 setup guide by creating a new text file using &quot;File &gt; New Text File&quot; (<code>Ctrl+N</code>), clicking on the ∀-symbol in the top right and selecting &quot;Documentation… &gt; Setup: Show Setup Guide&quot;.</p>
<p><img src="images/show-setup-guide.png" alt="show setup guide" /></p>
</li>
<li>
<p>Follow the Lean 4 setup guide. It will walk you through learning resources for Lean 4, teach you how to set up Lean's dependencies on your platform, install Lean 4 for you at the click of a button and help you set up your first project.</p>
<p><img src="images/setup_guide.png" alt="setup guide" /></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h1>
<h3 id="tier-1"><a class="header" href="#tier-1">Tier 1</a></h3>
<p>Platforms built &amp; tested by our CI, available as nightly releases via elan (see below)</p>
<ul>
<li>x86-64 Linux with glibc 2.27+</li>
<li>x86-64 macOS 10.15+</li>
<li>x86-64 Windows 10+</li>
</ul>
<h3 id="tier-2"><a class="header" href="#tier-2">Tier 2</a></h3>
<p>Platforms cross-compiled but not tested by our CI, available as nightly releases</p>
<p>Releases may be silently broken due to the lack of automated testing.
Issue reports and fixes are welcome.</p>
<ul>
<li>aarch64 Linux with glibc 2.27+</li>
<li>aarch64 (Apple Silicon) macOS</li>
<li>x86 (32-bit) Linux</li>
<li>Emscripten Web Assembly</li>
</ul>
<!--
### Tier 3

Platforms that are known to work from manual testing, but do not come with CI or official releases
-->
<h1 id="setting-up-lean"><a class="header" href="#setting-up-lean">Setting Up Lean</a></h1>
<p>See also the <a href="./quickstart.html">quickstart</a> instructions for a standard setup with VS Code as the editor.</p>
<p>Release builds for all supported platforms are available at <a href="https://github.com/leanprover/lean4/releases">https://github.com/leanprover/lean4/releases</a>.
Instead of downloading these and setting up the paths manually, however, it is recommended to use the Lean version manager <a href="https://github.com/leanprover/elan"><code>elan</code></a> instead:</p>
<pre><code class="language-sh">$ elan self update  # in case you haven't updated elan in a while
# download &amp; activate latest Lean 4 stable release (https://github.com/leanprover/lean4/releases)
$ elan default leanprover/lean4:stable
</code></pre>
<h2 id="lake"><a class="header" href="#lake"><code>lake</code></a></h2>
<p>Lean 4 comes with a package manager named <code>lake</code>.
Use <code>lake init foo</code> to initialize a Lean package <code>foo</code> in the current directory, and <code>lake build</code> to typecheck and build it as well as all its dependencies. Use <code>lake help</code> to learn about further commands.
The general directory structure of a package <code>foo</code> is</p>
<pre><code class="language-sh">lakefile.lean  # package configuration
lean-toolchain # specifies the lean version to use
Foo.lean       # main file, import via `import Foo`
Foo/
  A.lean       # further files, import via e.g. `import Foo.A`
  A/...        # further nesting
.lake/         # `lake` build output directory
</code></pre>
<p>After running <code>lake build</code> you will see a binary named <code>./.lake/build/bin/foo</code> and when you run it you should see the output:</p>
<pre><code>Hello, world!
</code></pre>
<h2 id="editing"><a class="header" href="#editing">Editing</a></h2>
<p>Lean implements the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> that can be used for interactive development in <a href="https://github.com/leanprover/lean4-mode">Emacs</a>, <a href="https://github.com/leanprover-community/vscode-lean4">VS Code</a>, and possibly other editors.</p>
<p>Changes must be saved to be visible in other files, which must then be invalidated using an editor command (see links above).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theorem-proving-in-lean"><a class="header" href="#theorem-proving-in-lean">Theorem Proving in Lean</a></h1>
<p>We strongly encourage you to read the book <a href="https://lean-lang.org/theorem_proving_in_lean4/title_page.html">Theorem Proving in Lean</a>.
Many Lean users consider it to be the Lean Bible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programming-in-lean"><a class="header" href="#functional-programming-in-lean">Functional Programming in Lean</a></h1>
<p>The goal of <a href="https://lean-lang.org/functional_programming_in_lean/">this book</a> is to be an accessible introduction to using Lean 4 as a programming language.
It should be useful both to people who want to use Lean as a general-purpose programming language and to mathematicians who want to develop larger-scale proof automation but do not have a background in functional programming.
It does not assume any background with functional programming, though it's probably not a good first book on programming in general.
New content will be added once per month until it's done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<ul>
<li><a href="examples/palindromes.lean.html">Palindromes</a></li>
<li><a href="examples/bintree.lean.html">Binary Search Trees</a></li>
<li><a href="examples/tc.lean.html">A Certified Type Checker</a></li>
<li><a href="examples/interp.lean.html">The Well-Typed Interpreter</a></li>
<li><a href="examples/deBruijn.lean.html">Dependent de Bruijn Indices</a></li>
<li><a href="examples/phoas.lean.html">Parametric Higher-Order Abstract Syntax</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="palindromes"><a class="header" href="#palindromes">Palindromes</a></h1>
<p>Palindromes are lists that read the same from left to right and from right to left.
For example, <code>[a, b, b, a]</code> and <code>[a, h, a]</code> are palindromes.</p>
<p>We use an inductive predicate to specify whether a list is a palindrome or not.
Recall that inductive predicates, or inductively defined propositions, are a convenient
way to specify functions of type <code>... → Prop</code>.</p>
<p>This example is a based on an example from the book &quot;The Hitchhiker's Guide to Logical Verification&quot;.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">Palindrome</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>∀ {α : Type u_1}, Palindrome []</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">      : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">Palindrome</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List ?m.17</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>single</var><b>: </b><span>∀ {α : Type u_1} (a : α), Palindrome [a]</span></span></div></blockquote></div></small></div>single</span><span class="alectryon-token">   : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">Palindrome</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">]
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sandwich</var><b>: </b><span>∀ {α : Type u_1} {as : List α} (a : α), Palindrome as → Palindrome ([a] ++ as ++ [a])</span></span></div></blockquote></div></small></div>sandwich</span><span class="alectryon-token"> : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">Palindrome</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">Palindrome</span></span><span class="alectryon-token"> ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">] <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">])</span></span></pre>
<p>The definition distinguishes three cases: (1) <code>[]</code> is a palindrome; (2) for any element
<code>a</code>, the singleton list <code>[a]</code> is a palindrome; (3) for any element <code>a</code> and any palindrome
<code>[b₁, . . ., bₙ]</code>, the list <code>[a, b₁, . . ., bₙ, a]</code> is a palindrome.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<p>We now prove that the reverse of a palindrome is a palindrome using induction on the inductive predicate <code>h : Palindrome as</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>palindrome_reverse</var><b>: </b><span>∀ {α : Type u_1} {as : List α}, Palindrome as → Palindrome (List.reverse as)</span></span></div></blockquote></div></small></div><span class="nv">palindrome_reverse</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div>Palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.394</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div>Palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.394</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk1"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Palindrome as</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Palindrome (List.reverse as)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk2"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>∀ {α : Type u_1}, Palindrome []</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">Palindrome (List.reverse [])</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk3"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome.nil</var><b>: </b><span>∀ {α : Type u_1}, Palindrome []</span></span></div></blockquote></div></small></div>Palindrome.nil</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk4"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>single</var><b>: </b><span>∀ {α : Type u_1} (a : α), Palindrome [a]</span></span></div></blockquote></div></small></div>single</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">single</span></span><div class="goal-conclusion">Palindrome (List.reverse [a])</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk5"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome.single</var><b>: </b><span>∀ {α : Type u_1} (a : α), Palindrome [a]</span></span></div></blockquote></div></small></div>Palindrome.single</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk6"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sandwich</var><b>: </b><span>∀ {α : Type u_1} {as : List α} (a : α), Palindrome as → Palindrome ([a] ++ as ++ [a])</span></span></div></blockquote></div></small></div>sandwich</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as✝</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>Palindrome (List.reverse as✝)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as, as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>Palindrome (List.reverse as<span class="bp">✝</span>)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sandwich</span></span><div class="goal-conclusion">Palindrome (List.reverse ([a] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [a]))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk7"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as, as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>Palindrome (List.reverse as<span class="bp">✝</span>)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sandwich</span></span><div class="goal-conclusion">Palindrome (a :: (List.reverse as<span class="bp">✝</span> <span class="bp">++</span> [a]))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk8"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome.sandwich</var><b>: </b><span>∀ {α : Type u_1} {as : List α} (a : α), Palindrome as → Palindrome ([a] ++ as ++ [a])</span></span></div></blockquote></div></small></div>Palindrome.sandwich</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>Palindrome (List.reverse as✝)</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>If a list <code>as</code> is a palindrome, then the reverse of <code>as</code> is equal to itself.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse_eq_of_palindrome</var><b>: </b><span>∀ {α : Type u_1} {as : List α}, Palindrome as → List.reverse as = as</span></span></div></blockquote></div></small></div><span class="nv">reverse_eq_of_palindrome</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div>Palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.696</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.696</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.696</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk9"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chka"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Palindrome as</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.reverse as <span class="bp">=</span> as</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chkb"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>∀ {α : Type u_1}, Palindrome []</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nil</span></span><div class="goal-conclusion">List.reverse [] <span class="bp">=</span> []</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chkc"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chkd"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>single</var><b>: </b><span>∀ {α : Type u_1} (a : α), Palindrome [a]</span></span></div></blockquote></div></small></div>single</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">single</span></span><div class="goal-conclusion">List.reverse [a] <span class="bp">=</span> [a]</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chke"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chkf"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>sandwich</var><b>: </b><span>∀ {α : Type u_1} {as : List α} (a : α), Palindrome as → Palindrome ([a] ++ as ++ [a])</span></span></div></blockquote></div></small></div>sandwich</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as, as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>List.reverse as<span class="bp">✝</span> <span class="bp">=</span> as<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sandwich</span></span><div class="goal-conclusion">List.reverse ([a] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [a]) <span class="bp">=</span> [a] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [a]</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk10"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as✝</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>h<span class="bp">`</span> [linter.unusedVariables]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as, as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>List.reverse as<span class="bp">✝</span> <span class="bp">=</span> as<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sandwich</span></span><div class="goal-conclusion">List.reverse ([a] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [a]) <span class="bp">=</span> [a] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [a]</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>List.reverse as✝ = as✝</span></span></div></blockquote></div></small></div></span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk11"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>List.reverse as✝ = as✝</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as, as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>List.reverse as<span class="bp">✝</span> <span class="bp">=</span> as<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">sandwich</span></span><div class="goal-conclusion">List.reverse ([a] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [a]) <span class="bp">=</span> [a] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [a]</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk12"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>List.reverse as✝ = as✝</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Note that you can also easily prove <code>palindrome_reverse</code> using <code>reverse_eq_of_palindrome</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {α : Type u_1} {as : List α}, Palindrome as → Palindrome (List.reverse as)</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div>Palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.946</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div>Palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.946</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk13"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk14"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse_eq_of_palindrome</var><b>: </b><span>∀ {α : Type ?u.942} {as : List α}, Palindrome as → List.reverse as = as</span></span></div></blockquote></div></small></div>reverse_eq_of_palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Given a nonempty list, the function <code>List.last</code> returns its element.
Note that we use <code>(by simp)</code> to prove that <code>a₂ :: as ≠ []</code> in the recursive application.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.last</var><b>: </b><span>{α : Type u_1} → (as : List α) → as ≠ [] → α</span></span></div></blockquote></div></small></div><span class="nv">List.last</span></span><span class="alectryon-token"> : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">≠</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  <span class="bp">|</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">],         _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> _::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token">:: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">, _ <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>last</var><b>: </b><span>{α : Type u_1} → (as : List α) → as ≠ [] → α</span></span></div></blockquote></div></small></div><span class="nv">last</span></span><span class="alectryon-token"> (</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk15"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk16"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">)</span></span></pre>
<p>We use the function <code>List.last</code> to prove the following theorem that says that if a list <code>as</code> is not empty,
then removing the last element from <code>as</code> and appending it back is equal to <code>as</code>.
We use the attribute <code>@[simp]</code> to instruct the <code>simp</code> tactic to use this theorem as a simplification rule.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.dropLast_append_last</var><b>: </b><span>∀ {α : Type u_1} {as : List α} (h : as ≠ []), dropLast as ++ [last as h] = as</span></span></div></blockquote></div></small></div><span class="nv">List.dropLast_append_last</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>as ≠ []</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.1469</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">≠</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List ?m.1469</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.1469</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropLast</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div>dropLast</span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.1469</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>last</var><b>: </b><span>{α : Type u_1} → (as : List α) → as ≠ [] → α</span></span></div></blockquote></div></small></div>last</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>as ≠ []</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">] <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.1469</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk17"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk18"><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>as <span class="bp">≠</span> []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropLast as <span class="bp">++</span> [last as h] <span class="bp">=</span> as</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk19"><span class="alectryon-token"><span class="bp">|</span> [] <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>[] <span class="bp">≠</span> []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropLast [] <span class="bp">++</span> [last [] h] <span class="bp">=</span> []</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk1a"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk1b"><span class="alectryon-token"><span class="bp">|</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">] <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>[a] <span class="bp">≠</span> []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropLast [a] <span class="bp">++</span> [last [a] h] <span class="bp">=</span> [a]</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk1c"><span class="alectryon-token"><span class="k">simp_all</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>last</var><b>: </b><span>{α : Type ?u.1769} → (as : List α) → as ≠ [] → α</span></span></div></blockquote></div></small></div>last</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropLast</var><b>: </b><span>{α : Type ?u.2200} → List α → List α</span></span></div></blockquote></div></small></div>dropLast</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk1d"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₁</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a₁</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a₁ :: a₂ :: as <span class="bp">≠</span> []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropLast (a₁ :: a₂ :: as) <span class="bp">++</span> [last (a₁ :: a₂ :: as) h] <span class="bp">=</span> a₁ :: a₂ :: as</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk1e"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>last</var><b>: </b><span>{α : Type ?u.3235} → (as : List α) → as ≠ [] → α</span></span></div></blockquote></div></small></div>last</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropLast</var><b>: </b><span>{α : Type ?u.3260} → List α → List α</span></span></div></blockquote></div></small></div>dropLast</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a₁ :: a₂ :: as <span class="bp">≠</span> []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropLast (a₂ :: as) <span class="bp">++</span> [last (a₂ :: as) (_ : <span class="bp">¬</span>a₂ :: as <span class="bp">=</span> [])] <span class="bp">=</span> a₂ :: as</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk1f"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropLast_append_last</var><b>: </b><span>∀ {α : Type u_1} {as : List α} (h : as ≠ []), dropLast as ++ [last as h] = as</span></span></div></blockquote></div></small></div><span class="nv">dropLast_append_last</span></span><span class="alectryon-token"> (as := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) (</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a₁, a₂</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>a₁ :: a₂ :: as <span class="bp">≠</span> []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dropLast (a₂ :: as) <span class="bp">++</span> [last (a₂ :: as) (_ : <span class="bp">¬</span>a₂ :: as <span class="bp">=</span> [])] <span class="bp">=</span> a₂ :: as</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk20"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk21"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk22"><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>We now define the following auxiliary induction principle for lists using well-founded recursion on <code>as.length</code>.
We can read it as follows, to prove <code>motive as</code>, it suffices to show that: (1) <code>motive []</code>; (2) <code>motive [a]</code> for any <code>a</code>;
(3) if <code>motive as</code> holds, then <code>motive ([a] ++ as ++ [b])</code> also holds for any <code>a</code>, <code>b</code>, and <code>as</code>.
Note that the structure of this induction principle is very similar to the <code>Palindrome</code> inductive predicate.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.palindrome_ind</var><b>: </b><span>∀ {α : Type u_1} (motive : List α → Prop),
  motive [] →
    (∀ (a : α), motive [a]) →
      (∀ (a b : α) (as : List α), motive as → motive ([a] ++ as ++ [b])) → ∀ (as : List α), motive as</span></span></div></blockquote></div></small></div><span class="nv">List.palindrome_ind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>motive</var><b>: </b><span>List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">motive</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">)
    (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>motive []</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>motive</var><b>: </b><span>List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">motive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">)
    (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>∀ (a : α), motive [a]</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>motive</var><b>: </b><span>List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">motive</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">])
    (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₃</var><b>: </b><span>∀ (a b : α) (as : List α), motive as → motive ([a] ++ as ++ [b])</span></span></div></blockquote></div></small></div><span class="nv">h₃</span></span><span class="alectryon-token"> : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>motive</var><b>: </b><span>List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">motive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>motive</var><b>: </b><span>List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">motive</span></span><span class="alectryon-token"> ([</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">] <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">++</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">]))
    (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">)
    : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>motive</var><b>: </b><span>List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">motive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> []  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>motive []</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token">
  <span class="bp">|</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">] <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>∀ (a : α), motive [a]</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₁</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₁</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as'</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>motive (dropLast (a₂ :: as'))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>palindrome_ind</var><b>: </b><span>∀ {α : Type u_1} (motive : List α → Prop),
  motive [] →
    (∀ (a : α), motive [a]) →
      (∀ (a b : α) (as : List α), motive as → motive ([a] ++ as ++ [b])) → ∀ (as : List α), motive as</span></span></div></blockquote></div></small></div><span class="nv">palindrome_ind</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>motive</var><b>: </b><span>List α → Prop</span></span></div></blockquote></div></small></div><span class="nv">motive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>motive []</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>∀ (a : α), motive [a]</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₃</var><b>: </b><span>∀ (a b : α) (as : List α), motive as → motive ([a] ++ as ++ [b])</span></span></div></blockquote></div></small></div><span class="nv">h₃</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as'</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as&#39;</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropLast</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div><span class="na">dropLast</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> : [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₁</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₁</span></span><span class="alectryon-token">] <span class="bp">++</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as'</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as&#39;</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dropLast</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div><span class="na">dropLast</span></span><span class="alectryon-token"> <span class="bp">++</span> [(</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as'</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as&#39;</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>last</var><b>: </b><span>{α : Type u_1} → (as : List α) → as ≠ [] → α</span></span></div></blockquote></div></small></div><span class="na">last</span></span><span class="alectryon-token"> (</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk23"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk24"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">)] <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₁</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₁</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a₂</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a₂</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as'</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as&#39;</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk25"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk26"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>[a₁] ++ dropLast (a₂ :: as') ++ [last (a₂ :: as') (_ : ¬a₂ :: as' = [])] = a₁ :: a₂ :: as'</span></span></div></blockquote></div></small></div><span class="nv">this</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₃</var><b>: </b><span>∀ (a b : α) (as : List α), motive as → motive ([a] ++ as ++ [b])</span></span></div></blockquote></div></small></div><span class="nv">h₃</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>α</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>α</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>motive (dropLast (a₂ :: as'))</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">termination_by</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type u_1} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"></span></span></pre>
<p>We use our new induction principle to prove that if <code>as.reverse = as</code>, then <code>Palindrome as</code> holds.
Note that we use the <code>using</code> modifier to instruct the <code>induction</code> tactic to use this induction principle
instead of the default one for lists.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.palindrome_of_eq_reverse</var><b>: </b><span>∀ {α : Type u_1} {as : List α}, reverse as = as → Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">List.palindrome_of_eq_reverse</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>reverse as = as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.9729</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.9729</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div>Palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.9729</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk27"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk28"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">using</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>palindrome_ind</var><b>: </b><span>∀ {α : Type u_1} (motive : List α → Prop),
  motive [] →
    (∀ (a : α), motive [a]) →
      (∀ (a b : α) (as : List α), motive as → motive ([a] ++ as ++ [b])) → ∀ (as : List α), motive as</span></span></div></blockquote></div></small></div>palindrome_ind</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse [] <span class="bp">=</span> []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h₁</span></span><div class="goal-conclusion">Palindrome []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="palindromes-lean-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse [a<span class="bp">✝</span>] <span class="bp">=</span> [a<span class="bp">✝</span>]</span></span></span><br></div><label class="goal-separator" for="palindromes-lean-chk29"><hr><span class="goal-name">h₂</span></label><div class="goal-conclusion">Palindrome [a<span class="bp">✝</span>]</div></blockquote><input class="alectryon-extra-goal-toggle" id="palindromes-lean-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a✝¹, b✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>reverse as<span class="bp">✝</span> <span class="bp">=</span> as<span class="bp">✝</span> <span class="bp">→</span> Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]) <span class="bp">=</span> [a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]</span></span></span><br></div><label class="goal-separator" for="palindromes-lean-chk2a"><hr><span class="goal-name">h₃</span></label><div class="goal-conclusion">Palindrome ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>])</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk2b"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse [] <span class="bp">=</span> []</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h₁</span></span><div class="goal-conclusion">Palindrome []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="palindromes-lean-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse [a<span class="bp">✝</span>] <span class="bp">=</span> [a<span class="bp">✝</span>]</span></span></span><br></div><label class="goal-separator" for="palindromes-lean-chk2c"><hr><span class="goal-name">h₂</span></label><div class="goal-conclusion">Palindrome [a<span class="bp">✝</span>]</div></blockquote><input class="alectryon-extra-goal-toggle" id="palindromes-lean-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a✝¹, b✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>reverse as<span class="bp">✝</span> <span class="bp">=</span> as<span class="bp">✝</span> <span class="bp">→</span> Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]) <span class="bp">=</span> [a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]</span></span></span><br></div><label class="goal-separator" for="palindromes-lean-chk2d"><hr><span class="goal-name">h₃</span></label><div class="goal-conclusion">Palindrome ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>])</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk2e"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome.nil</var><b>: </b><span>∀ {α : Type u_1}, Palindrome []</span></span></div></blockquote></div></small></div>Palindrome.nil</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk2f"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse [a<span class="bp">✝</span>] <span class="bp">=</span> [a<span class="bp">✝</span>]</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h₂</span></span><div class="goal-conclusion">Palindrome [a<span class="bp">✝</span>]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="palindromes-lean-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a✝¹, b✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>reverse as<span class="bp">✝</span> <span class="bp">=</span> as<span class="bp">✝</span> <span class="bp">→</span> Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]) <span class="bp">=</span> [a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]</span></span></span><br></div><label class="goal-separator" for="palindromes-lean-chk30"><hr><span class="goal-name">h₃</span></label><div class="goal-conclusion">Palindrome ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>])</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk31"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome.single</var><b>: </b><span>∀ {α : Type u_1} (a : α), Palindrome [a]</span></span></div></blockquote></div></small></div>Palindrome.single</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk32"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>reverse as = as → Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a✝¹, b✝</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as✝</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>reverse as<span class="bp">✝</span> <span class="bp">=</span> as<span class="bp">✝</span> <span class="bp">→</span> Palindrome as<span class="bp">✝</span></span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]) <span class="bp">=</span> [a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>]</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h₃</span></span><div class="goal-conclusion">Palindrome ([a<span class="bp">✝¹</span>] <span class="bp">++</span> as<span class="bp">✝</span> <span class="bp">++</span> [b<span class="bp">✝</span>])</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk33"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> :=</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>reverse as <span class="bp">=</span> as <span class="bp">→</span> Palindrome as</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse ([a] <span class="bp">++</span> as <span class="bp">++</span> [b]) <span class="bp">=</span> [a] <span class="bp">++</span> as <span class="bp">++</span> [b]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Palindrome ([a] <span class="bp">++</span> as <span class="bp">++</span> [b])</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk34"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk35"><span class="alectryon-token"><span class="k">simp_all</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk36"><span class="alectryon-token"><span class="k">subst</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>a = b</span></span></div></blockquote></div></small></div><span class="nv">this</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>reverse as <span class="bp">=</span> as <span class="bp">→</span> Palindrome as</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse ([a] <span class="bp">++</span> as <span class="bp">++</span> [a]) <span class="bp">=</span> [a] <span class="bp">++</span> as <span class="bp">++</span> [a]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Palindrome ([a] <span class="bp">++</span> as <span class="bp">++</span> [a])</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk37"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> :=</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>α<span class="bp">✝</span></span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α<span class="bp">✝</span></span></span></span><br><span><var>ih</var><span class="hyp-type"><b>: </b><span>reverse as <span class="bp">=</span> as <span class="bp">→</span> Palindrome as</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>reverse ([a] <span class="bp">++</span> as <span class="bp">++</span> [a]) <span class="bp">=</span> [a] <span class="bp">++</span> as <span class="bp">++</span> [a]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Palindrome ([a] <span class="bp">++</span> as <span class="bp">++</span> [a])</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk38"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk39"><span class="alectryon-token"><span class="k">simp_all</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk3a"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome.sandwich</var><b>: </b><span>∀ {α : Type u_1} {as : List α} (a : α), Palindrome as → Palindrome ([a] ++ as ++ [a])</span></span></div></blockquote></div></small></div>Palindrome.sandwich</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih</var><b>: </b><span>reverse as = as → Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">ih</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>reverse as = as</span></span></div></blockquote></div></small></div><span class="nv">this</span></span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>We now define a function that returns <code>true</code> iff <code>as</code> is a palindrome.
The function assumes that the type <code>α</code> has decidable equality. We need this assumption
because we need to compare the list elements.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.isPalindrome</var><b>: </b><span>{α : Type u_1} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div><span class="nv">List.isPalindrome</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>DecidableEq</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>DecidableEq</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> :=
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse</var><b>: </b><span>{α : Type u_1} → List α → List α</span></span></div></blockquote></div></small></div>reverse</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"></span></span></pre>
<p>It is straightforward to prove that <code>isPalindrome</code> is correct using the previously proved theorems.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.isPalindrome_correct</var><b>: </b><span>∀ {α : Type u_1} [inst : DecidableEq α] (as : List α), isPalindrome as = true ↔ Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">List.isPalindrome_correct</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>DecidableEq</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>DecidableEq</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isPalindrome</var><b>: </b><span>{α : Type u_1} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div>isPalindrome</span><span class="alectryon-token"> <span class="bp">↔</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Palindrome</var><b>: </b><span>{α : Type u_1} → List α → Prop</span></span></div></blockquote></div></small></div>Palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk3b"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk3c"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isPalindrome</var><b>: </b><span>{α : Type ?u.10594} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div>isPalindrome</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>α</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>DecidableEq α</span></span></span><br><span><var>as</var><span class="hyp-type"><b>: </b><span>List α</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reverse as <span class="bp">=</span> as <span class="bp">↔</span> Palindrome as</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk3d"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Iff.intro</var><b>: </b><span>∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)</span></span></div></blockquote></div></small></div>Iff.intro</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>reverse as = as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>palindrome_of_eq_reverse</var><b>: </b><span>∀ {α : Type u_1} {as : List α}, reverse as = as → Palindrome as</span></span></div></blockquote></div></small></div>palindrome_of_eq_reverse</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>reverse as = as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>reverse_eq_of_palindrome</var><b>: </b><span>∀ {α : Type u_1} {as : List α}, Palindrome as → reverse as = as</span></span></div></blockquote></div></small></div>reverse_eq_of_palindrome</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Palindrome as</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk3e"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isPalindrome</var><b>: </b><span>{α : Type} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div><span class="na">isPalindrome</span></span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="palindromes-lean-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="palindromes-lean-chk3f"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isPalindrome</var><b>: </b><span>{α : Type} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div><span class="na">isPalindrome</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>List.isPalindrome [1, 2, 1] = true</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> : [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isPalindrome</var><b>: </b><span>{α : Type} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div><span class="na">isPalindrome</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>List.isPalindrome [1, 2, 2, 1] = true</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> : [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isPalindrome</var><b>: </b><span>{α : Type} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div><span class="na">isPalindrome</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token">
</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>(!List.isPalindrome [1, 2, 3, 1]) = true</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> : <span class="bp">!</span>[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isPalindrome</var><b>: </b><span>{α : Type} → [inst : DecidableEq α] → List α → Bool</span></span></div></blockquote></div></small></div><span class="na">isPalindrome</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token"></span></span></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search-trees"><a class="header" href="#binary-search-trees">Binary Search Trees</a></h1>
<p>If the type of keys can be totally ordered -- that is, it supports a well-behaved <code>≤</code> comparison --
then maps can be implemented with binary search trees (BSTs). Insert and lookup operations on BSTs take time
proportional to the height of the tree. If the tree is balanced, the operations therefore take logarithmic time.</p>
<p>This example is based on a similar example found in the <a href="https://softwarefoundations.cis.upenn.edu/vfa-current/SearchTree.html">&quot;Software Foundations&quot;</a>
book (volume 3).</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<p>We use <code>Nat</code> as the key type in our implementation of BSTs,
since it has a convenient total order with lots of theorems and automation available.
We leave as an exercise to the reader the generalization to arbitrary types.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div><span class="nv">Tree</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type v</var><b>: </b><span>Type (v + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> v</span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type v} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type v} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div><span class="nv">Tree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div><span class="nv">Tree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token"></span></span></pre>
<p>The function <code>contains</code> returns <code>true</code> iff the given tree contains the key <code>k</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">Tree.contains</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.1319} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.1328} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk0"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>value<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">contains</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">contains</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"></span></span></pre>
<p><code>t.find? k</code> returns <code>some v</code> if <code>v</code> is the value bound to key <code>k</code> in the tree <code>t</code>. It returns <code>none</code> otherwise.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>Tree.find<span class="bp">?</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.1660} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type u_1} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.1672} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type u_1} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"></span></span></pre>
<p><code>t.insert k v</code> is the map containing all the bindings of <code>t</code> along with a binding of <code>k</code> to <code>v</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div><span class="nv">Tree.insert</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.2009} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.2024} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div><span class="nv">insert</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div><span class="nv">insert</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"></span></span></pre>
<p>Let's add a new operation to our tree: converting it to an association list that contains the key--value bindings from the tree stored as pairs.
If that list is sorted by the keys, then any two trees that represent the same map would be converted to the same list.
Here's a function that does so with an in-order traversal of the tree.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">Tree.toList</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.2378} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.2390} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">toList</span></span><span class="alectryon-token"> <span class="bp">++</span> [(</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)] <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">toList</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Tree.node (Tree.node (Tree.leaf) <span class="mi">1</span> <span class="s2">&quot;one&quot;</span> (Tree.leaf)) <span class="mi">2</span> <span class="s2">&quot;two&quot;</span> (Tree.node (Tree.leaf) <span class="mi">3</span> <span class="s2">&quot;three&quot;</span> (Tree.leaf))
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.leaf</var><b>: </b><span>{β : Type} → Tree β</span></span></div></blockquote></div></small></div>Tree.leaf</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;two&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;two&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;three&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;three&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;one&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;one&quot;</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[(<span class="mi">1</span>, <span class="s2">&quot;one&quot;</span>), (<span class="mi">2</span>, <span class="s2">&quot;two&quot;</span>), (<span class="mi">3</span>, <span class="s2">&quot;three&quot;</span>)]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.leaf</var><b>: </b><span>{β : Type} → Tree β</span></span></div></blockquote></div></small></div>Tree.leaf</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;two&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;two&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;three&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;three&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;one&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;one&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token"></span></span></pre>
<p>The implementation of <code>Tree.toList</code> is inefficient because of how it uses the <code>++</code> operator.
On a balanced tree its running time is linearithmic, because it does a linear number of
concatenations at each level of the tree. On an unbalanced tree it's quadratic time.
Here's a tail-recursive implementation than runs in linear time, regardless of whether the tree is balanced:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toListTR</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">Tree.toListTR</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :=
    </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.2888} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.2898} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">) :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token">)</span></span></pre>
<p>We now prove that <code>t.toList</code> and <code>t.toListTR</code> return the same list.
The proof is on induction, and as we used the auxiliary function <code>go</code>
to define <code>Tree.toListTR</code>, we use the auxiliary theorem <code>go</code> to prove the theorem.</p>
<p>The proof of the auxiliary theorem is by induction on <code>t</code>.
The <code>generalizing acc</code> modifier instructs Lean to revert <code>acc</code>, apply the
induction theorem for <code>Tree</code>s, and then reintroduce <code>acc</code> in each case.
By using <code>generalizing</code>, we obtain the more general induction hypotheses</p>
<ul>
<li>
<p><code>left_ih : ∀ acc, toListTR.go left acc = toList left ++ acc</code></p>
</li>
<li>
<p><code>right_ih : ∀ acc, toListTR.go right acc = toList right ++ acc</code></p>
</li>
</ul>
<p>Recall that the combinator <code>tac &lt;;&gt; tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal,
concatenating all goals produced by <code>tac'</code>. In this theorem, we use it to apply
<code>simp</code> and close each subgoal produced by the <code>induction</code> tactic.</p>
<p>The <code>simp</code> parameters <code>toListTR.go</code> and <code>toList</code> instruct the simplifier to try to reduce
and/or apply auto generated equation theorems for these two functions.
The parameter <code>*</code> instructs the simplifier to use any equation in a goal as rewriting rules.
In this particular case, <code>simp</code> uses the induction hypotheses as rewriting rules.
Finally, the parameter <code>List.append_assoc</code> instructs the simplifier to use the
<code>List.append_assoc</code> theorem as a rewriting rule.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList_eq_toListTR</var><b>: </b><span>∀ {β : Type u_1} (t : Tree β), toList t = toListTR t</span></span></div></blockquote></div></small></div><span class="nv">Tree.toList_eq_toListTR</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR</span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR</var><b>: </b><span>{β : Type ?u.3985} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>∀ (t : Tree β) (acc : List (Nat × β)), toListTR.go t acc = toList t ++ acc</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>∀ (t : Tree β) (acc : List (Nat × β)), toListTR.go t acc = toList t ++ acc</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">))
     : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR.go</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR.go</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token"> <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk6"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">toListTR.go leaf acc <span class="bp">=</span> toList leaf <span class="bp">++</span> acc</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t, left✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>left_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go left<span class="bp">✝</span> acc <span class="bp">=</span> toList left<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>right_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go right<span class="bp">✝</span> acc <span class="bp">=</span> toList right<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk7"><hr><span class="goal-name">node</span></label><div class="goal-conclusion">toListTR.go (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) acc <span class="bp">=</span> toList (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) <span class="bp">++</span> acc</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk8"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">toListTR.go leaf acc <span class="bp">=</span> toList leaf <span class="bp">++</span> acc</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t, left✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>left_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go left<span class="bp">✝</span> acc <span class="bp">=</span> toList left<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>right_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go right<span class="bp">✝</span> acc <span class="bp">=</span> toList right<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk9"><hr><span class="goal-name">node</span></label><div class="goal-conclusion">toListTR.go (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) acc <span class="bp">=</span> toList (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) <span class="bp">++</span> acc</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chka"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR.go</var><b>: </b><span>{β : Type ?u.3350} → Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR.go</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type ?u.3599} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token">, <span class="bp">*</span>, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.append_assoc</var><b>: </b><span>∀ {α : Type ?u.3862} (as bs cs : List α), as ++ bs ++ cs = as ++ (bs ++ cs)</span></span></div></blockquote></div></small></div>List.append_assoc</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The <code>[csimp]</code> annotation instructs the Lean code generator to replace
any <code>Tree.toList</code> with <code>Tree.toListTR</code> when generating code.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[csimp]</span> </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList_eq_toListTR_csimp</var><b>: </b><span>@toList = @toListTR</span></span></div></blockquote></div></small></div><span class="nv">Tree.toList_eq_toListTR_csimp</span></span><span class="alectryon-token">
                 : <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>Tree.toList</span><span class="alectryon-token"> <span class="bp">=</span> <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toListTR</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>Tree.toListTR</span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkb"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkc"><span class="alectryon-token"><span class="k">funext</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.h</span></span><div class="goal-conclusion">toList t <span class="bp">=</span> toListTR t</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkd"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList_eq_toListTR</var><b>: </b><span>∀ {β : Type u_1} (t : Tree β), toList t = toListTR t</span></span></div></blockquote></div></small></div>toList_eq_toListTR</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The implementations of <code>Tree.find?</code> and <code>Tree.insert</code> assume that values of type tree obey the BST invariant:
for any non-empty node with key <code>k</code>, all the values of the <code>left</code> subtree are less than <code>k</code> and all the values
of the right subtree are greater than <code>k</code>. But that invariant is not part of the definition of tree.</p>
<p>So, let's formalize the BST invariant. Here's one way to do so. First, we define a helper <code>ForallTree</code>
to express that idea that a predicate holds at every node of a tree:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p Tree.leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (Tree.node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> :
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token">)</span></span></pre>
<p>Second, we define the BST invariant:
An empty tree is a BST.
A non-empty tree is a BST if all its left nodes have a lesser key, its right nodes have a greater key, and the left and right subtrees are themselves BSTs.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1}, BST Tree.leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> :
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chke"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>?m.4774</span></span></div></blockquote></div></small></div><span class="nv">v</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>v<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkf"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>?m.4774</span></span></div></blockquote></div></small></div><span class="nv">v</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>v<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>?m.4774</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token">)</span></span></pre>
<p>We can use the <code>macro</code> command to create helper tactics for organizing our proofs.
The macro <code>have_eq x y</code> tries to prove <code>x = y</code> using linear arithmetic, and then
immediately uses the new equality to substitute <code>x</code> with <code>y</code> everywhere in the goal.</p>
<p>The modifier <code>local</code> specifies the scope of the macro.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="sd">/-- The `have_eq lhs rhs` tactic (tries to) prove that `lhs = rhs`,</span>
<span class="sd">    and then replaces `lhs` with `rhs`. -/</span>
</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;have_eq &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">lhs</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>term</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>term</span><span class="alectryon-token">:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">rhs</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>term</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>term</span><span class="alectryon-token">:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tactic</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>tactic</span><span class="alectryon-token"> <span class="bp">=&gt;</span>
  <span class="bp">`</span>(tactic<span class="bp">|</span>
    (</span><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> h : <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">lhs</span></span><span class="alectryon-token"> <span class="bp">=</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">rhs</span></span><span class="alectryon-token"> :=
       <span class="c1">-- TODO: replace with linarith</span>
       </span><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp_arith</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">at</span></span><span class="alectryon-token"> <span class="bp">*;</span> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> Nat.le_antisymm <span class="bp">&lt;;&gt;</span> </span><span class="alectryon-token"><span class="k">assumption</span></span><span class="alectryon-token">
     </span><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">subst</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">lhs</span></span><span class="alectryon-token">))</span></span></pre>
<p>The <code>by_cases' e</code> is just the regular <code>by_cases</code> followed by <code>simp</code> using all
hypotheses in the current goal as rewriting rules.
Recall that the <code>by_cases</code> tactic creates two goals. One where we have <code>h : e</code> and
another one containing <code>h : ¬ e</code>. The simplifier uses the <code>h</code> to rewrite <code>e</code> to <code>True</code>
in the first subgoal, and <code>e</code> to <code>False</code> in the second. This is particularly
useful if <code>e</code> is the condition of an <code>if</code>-statement.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="sd">/-- `by_cases&#39; e` is a shorthand form `by_cases e &lt;;&gt; simp[*]` -/</span>
</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;by_cases&#39; &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>term</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>term</span><span class="alectryon-token"> :  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tactic</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>tactic</span><span class="alectryon-token"> <span class="bp">=&gt;</span>
  <span class="bp">`</span>(tactic<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">by_cases</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">&lt;;&gt;</span> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [<span class="bp">*</span>])</span></span></pre>
<p>We can use the attribute <code>[simp]</code> to instruct the simplifier to reduce given definitions or
apply rewrite theorems. The <code>local</code> modifier limits the scope of this modification to this file.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>Tree.insert</span><span class="alectryon-token"></span></span></pre>
<p>We now prove that <code>Tree.insert</code> preserves the BST invariant using induction and case analysis.
Recall that the tactic <code>. tac</code> focuses on the main goal and tries to solve it using <code>tac</code>, or else fails.
It is used to structure proofs in Lean.
The notation <code>‹e›</code> is just syntax sugar for <code>(by assumption : e)</code>. That is, it tries to find a hypothesis <code>h : e</code>.
It is useful to access hypothesis that have auto generated names (aka &quot;inaccessible&quot;) names.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.forall_insert_of_forall</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {t : Tree β} {key : Nat} {value : β},
  ForallTree p t → p key value → ForallTree p (insert t key value)</span></span></div></blockquote></div></small></div><span class="nv">Tree.forall_insert_of_forall</span></span><span class="alectryon-token">
        (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree p t</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → ?m.6750 → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree ?m.6750</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>p key value</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → ?m.6750 → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>?m.6750</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → ?m.6750 → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree ?m.6750</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>?m.6750</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk10"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk11"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree p t</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree p t</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForallTree p (insert t key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk12"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">ForallTree p (insert leaf key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk13"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>p key value</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk14"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree p left✝</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p key✝ value✝</span></span></div></blockquote></div></small></div><span class="nv">hp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree p right✝</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>ForallTree p (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>ForallTree p (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p key<span class="bp">✝</span> value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">ForallTree p (insert (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk15"><span class="alectryon-token"><span class="k">rename</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">=&gt;</span> k</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">ForallTree p (insert (node left<span class="bp">✝</span> k value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk16"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">ForallTree p (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk17"><hr><span class="goal-name">node.inr</span></label><div class="goal-conclusion">ForallTree p (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk18"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">ForallTree p (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk19"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>ForallTree p (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p k value✝</span></span></div></blockquote></div></small></div><span class="nv">hp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree p right✝</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1a"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">ForallTree p (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1b"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk1c"><hr><span class="goal-name">node.inr.inr</span></label><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1d"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1e"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree p left✝</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p k value✝</span></span></div></blockquote></div></small></div><span class="nv">hp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>ForallTree p (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1f"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk20"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p k value</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> k value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> k value)</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> k value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk21"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree p left✝</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>p k value</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree p right✝</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.bst_insert_of_bst</var><b>: </b><span>∀ {β : Type u_1} {t : Tree β}, BST t → ∀ (key : Nat) (value : β), BST (insert t key value)</span></span></div></blockquote></div></small></div><span class="nv">Tree.bst_insert_of_bst</span></span><span class="alectryon-token">
        {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div>BST</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div>BST</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk22"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk23"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BST (insert t key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk24"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1}, BST leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">BST (insert leaf key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk25"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1}, BST leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1}, BST leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk26"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k v =&gt; k &lt; key✝) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k v =&gt; key✝ &lt; k) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₁</var><b>: </b><span>BST left✝</span></span></div></blockquote></div></small></div><span class="nv">b₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₂</var><b>: </b><span>BST right✝</span></span></div></blockquote></div></small></div><span class="nv">b₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>BST (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>BST (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key<span class="bp">✝</span>) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key<span class="bp">✝</span> <span class="bp">&lt;</span> k) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">BST (insert (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk27"><span class="alectryon-token"><span class="k">rename</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">=&gt;</span> k</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">BST (insert (node left<span class="bp">✝</span> k value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk28"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">BST
  (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>
  <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk29"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">BST (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk2a"><hr><span class="goal-name">node.inr</span></label><div class="goal-conclusion">BST (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2b"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">BST (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2c"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forall_insert_of_forall</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {t : Tree β} {key : Nat} {value : β},
  ForallTree p t → p key value → ForallTree p (insert t key value)</span></span></div></blockquote></div></small></div>forall_insert_of_forall</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k_1 &lt; k) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> ‹key <span class="bp">&lt;</span> k›) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k &lt; k_1) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>BST (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₂</var><b>: </b><span>BST right✝</span></span></div></blockquote></div></small></div><span class="nv">b₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2d"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">BST (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2e"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk2f"><hr><span class="goal-name">node.inr.inr</span></label><div class="goal-conclusion">BST (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk30"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk31"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k_1 &lt; k) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forall_insert_of_forall</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {t : Tree β} {key : Nat} {value : β},
  ForallTree p t → p key value → ForallTree p (insert t key value)</span></span></div></blockquote></div></small></div>forall_insert_of_forall</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k &lt; k_1) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> ‹k <span class="bp">&lt;</span> key›) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₁</var><b>: </b><span>BST left✝</span></span></div></blockquote></div></small></div><span class="nv">b₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>BST (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk32"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk33"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> k value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> k value)</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> k value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk34"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k_1 &lt; k) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k &lt; k_1) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₁</var><b>: </b><span>BST left✝</span></span></div></blockquote></div></small></div><span class="nv">b₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₂</var><b>: </b><span>BST right✝</span></span></div></blockquote></div></small></div><span class="nv">b₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Now, we define the type <code>BinTree</code> using a <code>Subtype</code> that states that only trees satisfying the BST invariant are <code>BinTree</code>s.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">BinTree</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) := { </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">//</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u} → Tree β → Prop</span></span></div></blockquote></div></small></div>BST</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> }

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.mk</var><b>: </b><span>{β : Type u_1} → BinTree β</span></span></div></blockquote></div></small></div><span class="nv">BinTree.mk</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1}, BST Tree.leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">⟩

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.contains</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">BinTree.contains</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div>contains</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>BinTree.find<span class="bp">?</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div><span class="nv">BinTree.insert</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bst_insert_of_bst</var><b>: </b><span>∀ {β : Type u_1} {t : Tree β}, BST t → ∀ (key : Nat) (value : β), BST (Tree.insert t key value)</span></span></div></blockquote></div></small></div>bst_insert_of_bst</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>property</var><b>: </b><span>∀ {α : Type u_1} {p : α → Prop} (self : Subtype p), p self.val</span></span></div></blockquote></div></small></div>property</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">⟩</span></span></pre>
<p>Finally, we prove that <code>BinTree.find?</code> and <code>BinTree.insert</code> satisfy the map properties.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">]
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.mk</var><b>: </b><span>{β : Type u_1} → BinTree β</span></span></div></blockquote></div></small></div>BinTree.mk</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.contains</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Bool</span></span></div></blockquote></div></small></div>BinTree.contains</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>BinTree.find<span class="bp">?</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div>BinTree.insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>Tree.find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div>Tree.contains</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>Tree.insert</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find_mk</var><b>: </b><span>∀ {β : Type u_1} (k : Nat), find? mk k = none</span></span></div></blockquote></div></small></div><span class="nv">BinTree.find_mk</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.mk</var><b>: </b><span>{β : Type u_1} → BinTree β</span></span></div></blockquote></div></small></div>BinTree.mk</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type u_1} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk35"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk36"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find_insert</var><b>: </b><span>∀ {β : Type u_1} (b : BinTree β) (k : Nat) (v : β), find? (insert b k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">BinTree.find_insert</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type u_1} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk37"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk38"><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find<span class="bp">?</span> (insert { val := t, property := h } k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk39"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3a"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3b"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k <span class="bp">=</span>
  some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3c"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type v} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k <span class="bp">=</span>
  some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3d"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk3e"><hr><span class="goal-name">node.inr</span></label><div class="goal-conclusion">Tree.find<span class="bp">?</span> (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right) k <span class="bp">=</span> some v</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3f"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk40"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl.node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk41"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl.node</span></span><div class="goal-conclusion">BST left</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk42"><span class="alectryon-token"><span class="k">assumption</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk43"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk44"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk45"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl.node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk46"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl.node</span></span><div class="goal-conclusion">BST right</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk47"><span class="alectryon-token"><span class="k">assumption</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find_insert_of_ne</var><b>: </b><span>∀ {β : Type u_1} {k k' : Nat} (b : BinTree β), k ≠ k' → ∀ (v : β), find? (insert b k v) k' = find? b k'</span></span></div></blockquote></div></small></div><span class="nv">BinTree.find_insert_of_ne</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>k ≠ k'</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">≠</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk48"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk49"><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find<span class="bp">?</span> (insert { val := t, property := h } k v) k&#39; <span class="bp">=</span> find<span class="bp">?</span> { val := t, property := h } k&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4a"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> t k&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4b"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> t k&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4c"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4d"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type v} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">(<span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> none <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4e"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk4f"><hr><span class="goal-name">leaf.inr</span></label><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk50"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk51"><hr><span class="goal-name">leaf.inr</span></label><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk52"><span class="alectryon-token">(</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk53"><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk54"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk55"><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk56"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk57"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk58"><hr><span class="goal-name">leaf.inr.inr</span></label><div class="goal-conclusion">False</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk59"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk5a"><hr><span class="goal-name">leaf.inr.inr</span></label><div class="goal-conclusion">False</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5b"><span class="alectryon-token">(</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5c"><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5d"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5e"><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5f"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk60"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk61"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type v} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k' = Tree.find? left k'</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k' = Tree.find? right k'</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk62"><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree (fun k v =&gt; k &lt; key) left</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree (fun k v =&gt; key &lt; k) right</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bl</var><b>: </b><span>BST left</span></span></div></blockquote></div></small></div><span class="nv">bl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>br</var><b>: </b><span>BST right</span></span></div></blockquote></div></small></div><span class="nv">br</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk63"><span class="alectryon-token"><span class="k">specialize</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k' = Tree.find? left k'</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bl</var><b>: </b><span>BST left</span></span></div></blockquote></div></small></div><span class="nv">bl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk64"><span class="alectryon-token"><span class="k">specialize</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k' = Tree.find? right k'</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>br</var><b>: </b><span>BST right</span></span></div></blockquote></div></small></div><span class="nv">br</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk65"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right) k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk66"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some v) <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk67"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some v) <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk68"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝³</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right</span></span></span><br><span><var>h✝², h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some v) <span class="bp">=</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk69"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">  <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝⁴</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right</span></span></span><br><span><var>h✝³, h✝²</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr.inr.inr</span></span><div class="goal-conclusion">v <span class="bp">=</span> value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk6a"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>h✝⁴</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k&#39; v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k&#39; v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k&#39; value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k&#39;) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k&#39; <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>h✝³, h✝², h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr.inr.inr</span></span><div class="goal-conclusion">v <span class="bp">=</span> value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk6b"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="a-certified-type-checker"><a class="header" href="#a-certified-type-checker">A Certified Type Checker</a></h1>
<p>In this example, we build a certified type checker for a simple expression
language.</p>
<p>Remark: this example is based on an example in the book <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> by Adam Chlipala.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Nat → Expr</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bool</var><b>: </b><span>Bool → Expr</span></span></div></blockquote></div></small></div>bool</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>and</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div>and</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"></span></span></pre>
<p>We define a simple language of types using the inductive datatype <code>Ty</code>, and
its typing rules using the inductive predicate <code>HasType</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>bool</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>DecidableEq</var><b>: </b><span>Sort u → Sort (max 1 u)</span></span></div></blockquote></div></small></div>DecidableEq</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Expr</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>∀ {v : Nat}, HasType (Expr.nat v) Ty.nat</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Nat → Expr</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>∀ {a b : Expr}, HasType a Ty.nat → HasType b Ty.nat → HasType (Expr.plus a b) Ty.nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bool</var><b>: </b><span>∀ {v : Bool}, HasType (Expr.bool v) Ty.bool</span></span></div></blockquote></div></small></div>bool</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Bool → Expr</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>and</var><b>: </b><span>∀ {a b : Expr}, HasType a Ty.bool → HasType b Ty.bool → HasType (Expr.and a b) Ty.bool</span></span></div></blockquote></div></small></div>and</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.and</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div><span class="bp">.</span>and</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"></span></span></pre>
<p>We can easily show that if <code>e</code> has type <code>t₁</code> and type <code>t₂</code>, then <code>t₁</code> and <code>t₂</code> must be equal
by using the the <code>cases</code> tactic. This tactic creates a new subgoal for every constructor,
and automatically discharges unreachable cases. The tactic combinator <code>tac₁ &lt;;&gt; tac₂</code> applies
<code>tac₂</code> to each subgoal produced by <code>tac₁</code>. Then, the tactic <code>rfl</code> is used to close all produced
goals using reflexivity.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType.det</var><b>: </b><span>∀ {e : Expr} {t₁ t₂ : Ty}, HasType e t₁ → HasType e t₂ → t₁ = t₂</span></span></div></blockquote></div></small></div><span class="nv">HasType.det</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType e t₁</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t₁</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t₁</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType e t₂</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t₂</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t₂</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t₁</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t₁</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t₂</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t₂</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk0"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk1"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType e t₁</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>v✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.nat v<span class="bp">✝</span>) t₂</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nat</span></span><div class="goal-conclusion">Ty.nat <span class="bp">=</span> t₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tc-lean-chk2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a✝², b✝</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝²</span> Ty.nat</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.nat</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.plus a<span class="bp">✝²</span> b<span class="bp">✝</span>) t₂</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk2"><hr><span class="goal-name">plus</span></label><div class="goal-conclusion">Ty.nat <span class="bp">=</span> t₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="tc-lean-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>v✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.bool v<span class="bp">✝</span>) t₂</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk3"><hr><span class="goal-name">bool</span></label><div class="goal-conclusion">Ty.bool <span class="bp">=</span> t₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="tc-lean-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a✝², b✝</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝²</span> Ty.bool</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.bool</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.and a<span class="bp">✝²</span> b<span class="bp">✝</span>) t₂</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk4"><hr><span class="goal-name">and</span></label><div class="goal-conclusion">Ty.bool <span class="bp">=</span> t₂</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk5"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>v✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.nat v<span class="bp">✝</span>) t₂</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nat</span></span><div class="goal-conclusion">Ty.nat <span class="bp">=</span> t₂</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tc-lean-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a✝², b✝</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝²</span> Ty.nat</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.nat</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.plus a<span class="bp">✝²</span> b<span class="bp">✝</span>) t₂</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk6"><hr><span class="goal-name">plus</span></label><div class="goal-conclusion">Ty.nat <span class="bp">=</span> t₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="tc-lean-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>v✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.bool v<span class="bp">✝</span>) t₂</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk7"><hr><span class="goal-name">bool</span></label><div class="goal-conclusion">Ty.bool <span class="bp">=</span> t₂</div></blockquote><input class="alectryon-extra-goal-toggle" id="tc-lean-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t₂</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a✝², b✝</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝²</span> Ty.bool</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.bool</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType (Expr.and a<span class="bp">✝²</span> b<span class="bp">✝</span>) t₂</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk8"><hr><span class="goal-name">and</span></label><div class="goal-conclusion">Ty.bool <span class="bp">=</span> t₂</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk9"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType (Expr.nat v✝) t₂</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a✝⁴, b✝</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝⁴</span> Ty.bool</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.bool</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝⁴</span> Ty.bool</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">and.and</span></span><div class="goal-conclusion">Ty.bool <span class="bp">=</span> Ty.bool</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chka"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">nat.nat</span></span><div class="goal-conclusion">Ty.nat <span class="bp">=</span> Ty.nat</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tc-lean-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a✝⁴, b✝</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝⁴</span> Ty.nat</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.nat</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝⁴</span> Ty.nat</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.nat</span></span></span><br></div><label class="goal-separator" for="tc-lean-chkb"><hr><span class="goal-name">plus.plus</span></label><div class="goal-conclusion">Ty.nat <span class="bp">=</span> Ty.nat</div></blockquote><input class="alectryon-extra-goal-toggle" id="tc-lean-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>v✝</var><span class="hyp-type"><b>: </b><span>Bool</span></span></span><br></div><label class="goal-separator" for="tc-lean-chkc"><hr><span class="goal-name">bool.bool</span></label><div class="goal-conclusion">Ty.bool <span class="bp">=</span> Ty.bool</div></blockquote><input class="alectryon-extra-goal-toggle" id="tc-lean-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a✝⁴, b✝</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝⁴</span> Ty.bool</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.bool</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>HasType a<span class="bp">✝⁴</span> Ty.bool</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>HasType b<span class="bp">✝</span> Ty.bool</span></span></span><br></div><label class="goal-separator" for="tc-lean-chkd"><hr><span class="goal-name">and.and</span></label><div class="goal-conclusion">Ty.bool <span class="bp">=</span> Ty.bool</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chke"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The inductive type <code>Maybe p</code> has two constructors: <code>found a h</code> and <code>unknown</code>.
The former contains an element <code>a : α</code> and a proof that <code>a</code> satisfies the predicate <code>p</code>.
The constructor <code>unknown</code> is used to encode &quot;failure&quot;.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Maybe</var><b>: </b><span>{α : Sort u_1} → (α → Prop) → Sort (max 1 u_1)</span></span></div></blockquote></div></small></div><span class="nv">Maybe</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>found</var><b>: </b><span>{α : Sort u_1} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div>found</span><span class="alectryon-token"> : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Maybe</var><b>: </b><span>{α : Sort u_1} → (α → Prop) → Sort (max 1 u_1)</span></span></div></blockquote></div></small></div><span class="nv">Maybe</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>α → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unknown</var><b>: </b><span>{α : Sort u_1} → {p : α → Prop} → Maybe p</span></span></div></blockquote></div></small></div>unknown</span><span class="alectryon-token"></span></span></pre>
<p>We define a notation for <code>Maybe</code> that is similar to the builtin notation for the Lean builtin type <code>Subtype</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token"> <span class="s2">&quot;{{ &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="s2">&quot; | &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> <span class="s2">&quot; }}&quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Maybe</var><b>: </b><span>{α : Sort u_1} → (α → Prop) → Sort (max 1 u_1)</span></span></div></blockquote></div></small></div>Maybe</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">)</span></span></pre>
<p>The function <code>Expr.typeCheck e</code> returns a type <code>ty</code> and a proof that <code>e</code> has type <code>ty</code>,
or <code>unknown</code>.
Recall that, <code>def Expr.typeCheck ...</code> in Lean is notation for <code>namespace Expr def typeCheck ... end Expr</code>.
The term <code>.found .nat .nat</code> is sugar for <code>Maybe.found Ty.nat HasType.nat</code>. Lean can infer the namespaces using
the expected types.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr.typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div><span class="nv">Expr.typeCheck</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Expr</span><span class="alectryon-token">) : {{ </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> }} :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Nat → Expr</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> <span class="bp">..</span>   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>∀ {v : Nat}, HasType (nat v) Ty.nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bool</var><b>: </b><span>Bool → Expr</span></span></div></blockquote></div></small></div>bool</span><span class="alectryon-token"> <span class="bp">..</span>  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>∀ {v : Bool}, HasType (bool v) Ty.bool</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div><span class="nv">typeCheck</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div><span class="nv">typeCheck</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>∀ {a b : Expr}, HasType a Ty.nat → HasType b Ty.nat → HasType (plus a b) Ty.nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token">)
    <span class="bp">|</span> _, _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.unknown</var><b>: </b><span>{α : Type} → {p : α → Prop} → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>unknown</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>and</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div>and</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div><span class="nv">typeCheck</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div><span class="nv">typeCheck</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>bool</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.and</var><b>: </b><span>∀ {a b : Expr}, HasType a Ty.bool → HasType b Ty.bool → HasType (and a b) Ty.bool</span></span></div></blockquote></div></small></div><span class="bp">.</span>and</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token">)
    <span class="bp">|</span> _, _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.unknown</var><b>: </b><span>{α : Type} → {p : α → Prop} → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>unknown</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr.typeCheck_correct</var><b>: </b><span>∀ {e : Expr} {ty : Ty} {h : HasType e ty}, HasType e ty → typeCheck e ≠ Maybe.unknown → typeCheck e = Maybe.found ty h</span></span></div></blockquote></div></small></div><span class="nv">Expr.typeCheck_correct</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType e ty</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>typeCheck e ≠ Maybe.unknown</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div>typeCheck</span><span class="alectryon-token"> <span class="bp">≠</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.unknown</var><b>: </b><span>{α : Sort ?u.7978} → {p : α → Prop} → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>unknown</span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div>typeCheck</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>HasType e ty</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chkf"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk10"><span class="alectryon-token"><span class="k">revert</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>typeCheck e ≠ Maybe.unknown</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">typeCheck e <span class="bp">≠</span> Maybe.unknown <span class="bp">→</span> typeCheck e <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk11"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div>typeCheck</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType e ty }}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x<span class="bp">✝</span> <span class="bp">≠</span> Maybe.unknown <span class="bp">→</span> x<span class="bp">✝</span> <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk12"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>found</var><b>: </b><span>{α : Sort u_1} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty'</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>HasType e ty'</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br><span><var>ty'</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>HasType e ty&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">found</span></span><div class="goal-conclusion">Maybe.found ty&#39; h&#39; <span class="bp">≠</span> Maybe.unknown <span class="bp">→</span> Maybe.found ty&#39; h&#39; <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk13"><span class="alectryon-token"><span class="k">intro</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br><span><var>ty'</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>HasType e ty&#39;</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>Maybe.found ty&#39; h&#39; <span class="bp">≠</span> Maybe.unknown</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">found</span></span><div class="goal-conclusion">Maybe.found ty&#39; h&#39; <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk14"><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType.det</var><b>: </b><span>∀ {e : Expr} {t₁ t₂ : Ty}, HasType e t₁ → HasType e t₂ → t₁ = t₂</span></span></div></blockquote></div></small></div>HasType.det</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType e ty</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>HasType e ty'</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br><span><var>ty'</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h'</var><span class="hyp-type"><b>: </b><span>HasType e ty&#39;</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>Maybe.found ty&#39; h&#39; <span class="bp">≠</span> Maybe.unknown</span></span></span><br><span><var>this</var><span class="hyp-type"><b>: </b><span>ty <span class="bp">=</span> ty&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">found</span></span><div class="goal-conclusion">Maybe.found ty&#39; h&#39; <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk15"><span class="alectryon-token"><span class="k">subst</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>this</var><b>: </b><span>ty = ty'</span></span></div></blockquote></div></small></div><span class="nv">this</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁, h'</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>Maybe.found ty h&#39; <span class="bp">≠</span> Maybe.unknown</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">found</span></span><div class="goal-conclusion">Maybe.found ty h&#39; <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk16"><span class="alectryon-token"><span class="k">rfl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk17"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>unknown</var><b>: </b><span>{α : Sort u_1} → {p : α → Prop} → Maybe p</span></span></div></blockquote></div></small></div>unknown</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">unknown</span></span><div class="goal-conclusion">Maybe.unknown <span class="bp">≠</span> Maybe.unknown <span class="bp">→</span> Maybe.unknown <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk18"><span class="alectryon-token"><span class="k">intros</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>h, h₁</var><span class="hyp-type"><b>: </b><span>HasType e ty</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>Maybe.unknown <span class="bp">≠</span> Maybe.unknown</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">unknown</span></span><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.found ty h</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk19"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Now, we prove that if <code>Expr.typeCheck e</code> returns <code>Maybe.unknown</code>, then forall <code>ty</code>, <code>HasType e ty</code> does not hold.
The notation <code>e.typeCheck</code> is sugar for <code>Expr.typeCheck e</code>. Lean can infer this because we explicitly said that <code>e</code> has type <code>Expr</code>.
The proof is by induction on <code>e</code> and case analysis. The tactic <code>rename_i</code> is used to to rename &quot;inaccessible&quot; variables.
We say a variable is inaccessible if it is introduced by a tactic (e.g., <code>cases</code>) or has been shadowed by another variable introduced
by the user. Note that the tactic <code>simp [typeCheck]</code> is applied to all goal generated by the <code>induction</code> tactic, and closes
the cases corresponding to the constructors <code>Expr.nat</code> and <code>Expr.bool</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr.typeCheck_complete</var><b>: </b><span>∀ {ty : Ty} {e : Expr}, typeCheck e = Maybe.unknown → ¬HasType e ty</span></span></div></blockquote></div></small></div><span class="nv">Expr.typeCheck_complete</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Expr</span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div>typeCheck</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.unknown</var><b>: </b><span>{α : Type} → {p : α → Prop} → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>unknown</span><span class="alectryon-token"> <span class="bp">→</span> <span class="bp">¬</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk1a"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk1b"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">typeCheck e <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType e ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk1c"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div>typeCheck</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk1d"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>typeCheck a = Maybe.unknown → ¬HasType a ty</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>typeCheck b = Maybe.unknown → ¬HasType b ty</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus</span></span><div class="goal-conclusion">(<span class="k">match</span> typeCheck a, typeCheck b <span class="k">with</span>
    <span class="bp">|</span> Maybe.found Ty.nat h₁, Maybe.found Ty.nat h₂ <span class="bp">=&gt;</span> Maybe.found Ty.nat (_ : HasType (plus a b) Ty.nat)
    <span class="bp">|</span> x, x_1 <span class="bp">=&gt;</span> Maybe.unknown) <span class="bp">=</span>
    Maybe.unknown <span class="bp">→</span>
  <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk1e"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>h₁✝</var><span class="hyp-type"><b>: </b><span>HasType a Ty.nat</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>HasType b Ty.nat</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_1</span></span><div class="goal-conclusion">Maybe.found Ty.nat (_ : HasType (plus a b) Ty.nat) <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tc-lean-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝²</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk1f"><hr><span class="goal-name">plus.h_2</span></label><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk20"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>h₁✝</var><span class="hyp-type"><b>: </b><span>HasType a Ty.nat</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>HasType b Ty.nat</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_1</span></span><div class="goal-conclusion">Maybe.found Ty.nat (_ : HasType (plus a b) Ty.nat) <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tc-lean-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝²</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk21"><hr><span class="goal-name">plus.h_2</span></label><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk22"><span class="alectryon-token"><span class="k">intros</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>h₁✝</var><span class="hyp-type"><b>: </b><span>HasType a Ty.nat</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>HasType b Ty.nat</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂<span class="bp">✝</span></span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>Maybe.found Ty.nat (_ : HasType (plus a b) Ty.nat) <span class="bp">=</span> Maybe.unknown</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">¬</span>HasType (plus a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk23"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk24"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ra</var><b>: </b><span>{{ ty | HasType a ty }}</span></span></div></blockquote></div></small></div><span class="nv">ra</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rb</var><b>: </b><span>{{ ty | HasType b ty }}</span></span></div></blockquote></div></small></div><span class="nv">rb</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hnp</var><b>: </b><span>∀ (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a = Maybe.found Ty.nat h₁ → typeCheck b = Maybe.found Ty.nat h₂ → False</span></span></div></blockquote></div></small></div><span class="nv">hnp</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
      <span class="c1">-- Recall that `hnp` is a hypothesis generated by the `split` tactic</span>
      <span class="c1">-- that asserts the previous case was not taken</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝²</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_2</span></span><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk25"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk26"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Maybe.unknown = Maybe.unknown</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>h<span class="bp">`</span> [linter.unusedVariables]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (plus a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType (plus a b) ty</span></span></div></blockquote></div></small></div></span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk27"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType (plus a b) ty</span></span></div></blockquote></div></small></div><span class="nv">ht</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Maybe.unknown <span class="bp">=</span> Maybe.unknown</span></span></span><br><span><var>ht</var><span class="hyp-type"><b>: </b><span>HasType (plus a b) ty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk28"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType (plus a b) ty</span></span></div></blockquote></div></small></div><span class="nv">ht</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Maybe.unknown <span class="bp">=</span> Maybe.unknown</span></span></span><br><span><var>ht</var><span class="hyp-type"><b>: </b><span>HasType (plus a b) ty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk29"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>∀ {a b : Expr}, HasType a Ty.nat → HasType b Ty.nat → HasType (plus a b) Ty.nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a✝ Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b✝ Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.nat h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.nat h₂ <span class="bp">→</span> False</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Maybe.unknown <span class="bp">=</span> Maybe.unknown</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>HasType a Ty.nat</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType b Ty.nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a Ty.nat</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b Ty.nat</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk2a"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hnp</var><b>: </b><span>∀ (h₁ : HasType a Ty.nat) (h₂ : HasType b Ty.nat),
  typeCheck a = Maybe.found Ty.nat h₁ → typeCheck b = Maybe.found Ty.nat h₂ → False</span></span></div></blockquote></div></small></div><span class="nv">hnp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck_correct</var><b>: </b><span>∀ {e : Expr} {ty : Ty} {h : HasType e ty}, HasType e ty → typeCheck e ≠ Maybe.unknown → typeCheck e = Maybe.found ty h</span></span></div></blockquote></div></small></div>typeCheck_correct</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>typeCheck a = Maybe.unknown → ¬HasType a Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token"> <span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck_correct</var><b>: </b><span>∀ {e : Expr} {ty : Ty} {h : HasType e ty}, HasType e ty → typeCheck e ≠ Maybe.unknown → typeCheck e = Maybe.found ty h</span></span></div></blockquote></div></small></div>typeCheck_correct</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>typeCheck b = Maybe.unknown → ¬HasType b Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token"> <span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.nat</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk2b"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>and</var><b>: </b><span>Expr → Expr → Expr</span></span></div></blockquote></div></small></div>and</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>typeCheck a = Maybe.unknown → ¬HasType a ty</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>typeCheck b = Maybe.unknown → ¬HasType b ty</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">and</span></span><div class="goal-conclusion">(<span class="k">match</span> typeCheck a, typeCheck b <span class="k">with</span>
    <span class="bp">|</span> Maybe.found Ty.bool h₁, Maybe.found Ty.bool h₂ <span class="bp">=&gt;</span> Maybe.found Ty.bool (_ : HasType (and a b) Ty.bool)
    <span class="bp">|</span> x, x_1 <span class="bp">=&gt;</span> Maybe.unknown) <span class="bp">=</span>
    Maybe.unknown <span class="bp">→</span>
  <span class="bp">¬</span>HasType (and a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk2c"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>h₁✝</var><span class="hyp-type"><b>: </b><span>HasType a Ty.bool</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>HasType b Ty.bool</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">and.h_1</span></span><div class="goal-conclusion">Maybe.found Ty.bool (_ : HasType (and a b) Ty.bool) <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (and a b) ty</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tc-lean-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝²</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk2d"><hr><span class="goal-name">and.h_2</span></label><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (and a b) ty</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk2e"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>h₁✝</var><span class="hyp-type"><b>: </b><span>HasType a Ty.bool</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>HasType b Ty.bool</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">and.h_1</span></span><div class="goal-conclusion">Maybe.found Ty.bool (_ : HasType (and a b) Ty.bool) <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (and a b) ty</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tc-lean-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝²</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="tc-lean-chk2f"><hr><span class="goal-name">and.h_2</span></label><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (and a b) ty</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk30"><span class="alectryon-token"><span class="k">intros</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>h₁✝</var><span class="hyp-type"><b>: </b><span>HasType a Ty.bool</span></span></span><br><span><var>h₂✝</var><span class="hyp-type"><b>: </b><span>HasType b Ty.bool</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂<span class="bp">✝</span></span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>Maybe.found Ty.bool (_ : HasType (and a b) Ty.bool) <span class="bp">=</span> Maybe.unknown</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">¬</span>HasType (and a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk31"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk32"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ra</var><b>: </b><span>{{ ty | HasType a ty }}</span></span></div></blockquote></div></small></div><span class="nv">ra</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rb</var><b>: </b><span>{{ ty | HasType b ty }}</span></span></div></blockquote></div></small></div><span class="nv">rb</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hnp</var><b>: </b><span>∀ (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a = Maybe.found Ty.bool h₁ → typeCheck b = Maybe.found Ty.bool h₂ → False</span></span></div></blockquote></div></small></div><span class="nv">hnp</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>x✝²</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>x✝¹</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">and.h_2</span></span><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (and a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk33"><span class="alectryon-token"><span class="k">intro</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (and a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk34"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Maybe.unknown = Maybe.unknown</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>h<span class="bp">`</span> [linter.unusedVariables]</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Maybe.unknown <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType (and a b) ty</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType (and a b) ty</span></span></div></blockquote></div></small></div></span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk35"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType (and a b) ty</span></span></div></blockquote></div></small></div><span class="nv">ht</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Maybe.unknown <span class="bp">=</span> Maybe.unknown</span></span></span><br><span><var>ht</var><span class="hyp-type"><b>: </b><span>HasType (and a b) ty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk36"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType (and a b) ty</span></span></div></blockquote></div></small></div><span class="nv">ht</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a ty</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b ty</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Maybe.unknown <span class="bp">=</span> Maybe.unknown</span></span></span><br><span><var>ht</var><span class="hyp-type"><b>: </b><span>HasType (and a b) ty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk37"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>and</var><b>: </b><span>∀ {a b : Expr}, HasType a Ty.bool → HasType b Ty.bool → HasType (and a b) Ty.bool</span></span></div></blockquote></div></small></div>and</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a✝ Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b✝ Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Expr</span></span></span><br><span><var>ra</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType a ty }}</span></span></span><br><span><var>rb</var><span class="hyp-type"><b>: </b><span>{{ ty <span class="bp">|</span> HasType b ty }}</span></span></span><br><span><var>hnp</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a <span class="bp">=</span> Maybe.found Ty.bool h₁ <span class="bp">→</span> typeCheck b <span class="bp">=</span> Maybe.found Ty.bool h₂ <span class="bp">→</span> False</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>Maybe.unknown <span class="bp">=</span> Maybe.unknown</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>HasType a Ty.bool</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>HasType b Ty.bool</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>typeCheck a <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType a Ty.bool</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>typeCheck b <span class="bp">=</span> Maybe.unknown <span class="bp">→</span> <span class="bp">¬</span>HasType b Ty.bool</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">and</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tc-lean-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="tc-lean-chk38"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hnp</var><b>: </b><span>∀ (h₁ : HasType a Ty.bool) (h₂ : HasType b Ty.bool),
  typeCheck a = Maybe.found Ty.bool h₁ → typeCheck b = Maybe.found Ty.bool h₂ → False</span></span></div></blockquote></div></small></div><span class="nv">hnp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck_correct</var><b>: </b><span>∀ {e : Expr} {ty : Ty} {h : HasType e ty}, HasType e ty → typeCheck e ≠ Maybe.unknown → typeCheck e = Maybe.found ty h</span></span></div></blockquote></div></small></div>typeCheck_correct</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>typeCheck a = Maybe.unknown → ¬HasType a Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token"> <span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>HasType a Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck_correct</var><b>: </b><span>∀ {e : Expr} {ty : Ty} {h : HasType e ty}, HasType e ty → typeCheck e ≠ Maybe.unknown → typeCheck e = Maybe.found ty h</span></span></div></blockquote></div></small></div>typeCheck_correct</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>typeCheck b = Maybe.unknown → ¬HasType b Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token"> <span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>HasType b Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token">))</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Finally, we show that type checking for <code>e</code> can be decided using <code>Expr.typeCheck</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>(e : Expr) → (t : Ty) → Decidable (HasType e t)</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Expr</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Decidable</var><b>: </b><span>Prop → Type</span></span></div></blockquote></div></small></div>Decidable</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>Expr → Ty → Prop</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>Expr.typeCheck e = Maybe.unknown</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>typeCheck</var><b>: </b><span>(e : Expr) → {{ ty | HasType e ty }}</span></span></div></blockquote></div></small></div>typeCheck</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.found</var><b>: </b><span>{α : Type} → {p : α → Prop} → (a : α) → p a → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>found</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t'</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht'</var><b>: </b><span>HasType e t'</span></span></div></blockquote></div></small></div><span class="nv">ht&#39;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>heq</var><b>: </b><span>t = t'</span></span></div></blockquote></div></small></div><span class="nv">heq</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t'</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">t&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isTrue</var><b>: </b><span>{p : Prop} → p → Decidable p</span></span></div></blockquote></div></small></div>isTrue</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>heq</var><b>: </b><span>t = t'</span></span></div></blockquote></div></small></div><span class="nv">heq</span></span><span class="alectryon-token"> <span class="bp">▸</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht'</var><b>: </b><span>HasType e t'</span></span></div></blockquote></div></small></div><span class="nv">ht&#39;</span></span><span class="alectryon-token">)
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isFalse</var><b>: </b><span>{p : Prop} → ¬p → Decidable p</span></span></div></blockquote></div></small></div>isFalse</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType e t</span></span></div></blockquote></div></small></div><span class="nv">ht</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>heq</var><b>: </b><span>¬t = t'</span></span></div></blockquote></div></small></div><span class="nv">heq</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType.det</var><b>: </b><span>∀ {e : Expr} {t₁ t₂ : Ty}, HasType e t₁ → HasType e t₂ → t₁ = t₂</span></span></div></blockquote></div></small></div>HasType.det</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht</var><b>: </b><span>HasType e t</span></span></div></blockquote></div></small></div><span class="nv">ht</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ht'</var><b>: </b><span>HasType e t'</span></span></div></blockquote></div></small></div><span class="nv">ht&#39;</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.unknown</var><b>: </b><span>{α : Type} → {p : α → Prop} → Maybe p</span></span></div></blockquote></div></small></div><span class="bp">.</span>unknown</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isFalse</var><b>: </b><span>{p : Prop} → ¬p → Decidable p</span></span></div></blockquote></div></small></div>isFalse</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr.typeCheck_complete</var><b>: </b><span>∀ {ty : Ty} {e : Expr}, Expr.typeCheck e = Maybe.unknown → ¬HasType e ty</span></span></div></blockquote></div></small></div>Expr.typeCheck_complete</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h'</var><b>: </b><span>Expr.typeCheck e = Maybe.unknown</span></span></div></blockquote></div></small></div><span class="nv">h&#39;</span></span><span class="alectryon-token">)</span></span></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="the-well-typed-interpreter"><a class="header" href="#the-well-typed-interpreter">The Well-Typed Interpreter</a></h1>
<p>In this example, we build an interpreter for a simple functional programming language,
with variables, function application, binary operators and an <code>if...then...else</code> construct.
We will use the dependent type system to ensure that any programs which can be represented are well-typed.</p>
<p>Remark: this example is based on an example found in the Idris manual.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<h2 id="vectors"><a class="header" href="#vectors">Vectors</a></h2>
<p>A <code>Vector</code> is a list of size <code>n</code> whose elements belong to a type <code>α</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector</var><b>: </b><span>Type u → Nat → Type u</span></span></div></blockquote></div></small></div><span class="nv">Vector</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type u} → Vector α 0</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector</var><b>: </b><span>Type u → Nat → Type u</span></span></div></blockquote></div></small></div><span class="nv">Vector</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type u} → {n : Nat} → α → Vector α n → Vector α (n + 1)</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector</var><b>: </b><span>Type u → Nat → Type u</span></span></div></blockquote></div></small></div><span class="nv">Vector</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector</var><b>: </b><span>Type u → Nat → Type u</span></span></div></blockquote></div></small></div><span class="nv">Vector</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)</span></span></pre>
<p>We can overload the <code>List.cons</code> notation <code>::</code> and use it to create <code>Vector</code>s.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">infix</span></span><span class="alectryon-token">:<span class="mi">67</span> <span class="s2">&quot; :: &quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector.cons</var><b>: </b><span>{α : Type u} → {n : Nat} → α → Vector α n → Vector α (n + 1)</span></span></div></blockquote></div></small></div>Vector.cons</span><span class="alectryon-token"></span></span></pre>
<p>Now, we define the types of our simple functional language.
We have integers, booleans, and functions, represented by <code>Ty</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>int</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>bool</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token">)</span></span></pre>
<p>We can write a function to translate <code>Ty</code> values to a Lean type
— remember that types are first class, so can be calculated just like any other value.
We mark <code>Ty.interp</code> as <code>[reducible]</code> to make sure the typeclass resolution procedure can
unfold/reduce it. For example, suppose Lean is trying to synthesize a value for the instance
<code>Add (Ty.interp Ty.int)</code>. Since <code>Ty.interp</code> is marked as <code>[reducible]</code>,
the typeclass resolution procedure can reduce <code>Ty.interp Ty.int</code> to <code>Int</code>, and use
the builtin instance for <code>Add Int</code> as the solution.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[reducible]</span> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Ty.interp</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>int</span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>bool</span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"></span></span></pre>
<p>Expressions are indexed by the types of the local variables, and the type of the expression itself.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>{n : Nat} → Fin n → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Fin</var><b>: </b><span>Nat → Type</span></span></div></blockquote></div></small></div>Fin</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector</var><b>: </b><span>Type → Nat → Type</span></span></div></blockquote></div></small></div>Vector</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>{n : Nat} → Fin n → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Fin (?m.3322 + 1)</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.3322</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pop</var><b>: </b><span>{x : Nat} → {k : Fin x} → {ctx : Vector Ty x} → {ty u : Ty} → HasType k ctx ty → HasType (Fin.succ k) (u :: ctx) ty</span></span></div></blockquote></div></small></div>pop</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>{n : Nat} → Fin n → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Fin ?m.3496</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.3496</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>{n : Nat} → Fin n → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">HasType</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Fin ?m.3496</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>succ</var><b>: </b><span>{n : Nat} → Fin n → Fin (Nat.succ n)</span></span></div></blockquote></div></small></div>succ</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.3496</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector</var><b>: </b><span>Type → Nat → Type</span></span></div></blockquote></div></small></div>Vector</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Expr ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>{n : Nat} → Fin n → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin ?m.4253</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4253</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4253</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → Int → Expr ctx Ty.int</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Int</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Int</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4274</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>Ty.int</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{n : Nat} → {a : Ty} → {ctx : Vector Ty n} → {ty : Ty} → Expr (a :: ctx) ty → Expr ctx (Ty.fn a ty)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4428</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4428</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>Ty.fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a ty : Ty} → Expr ctx (Ty.fn a ty) → Expr ctx a → Expr ctx ty</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4575</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>Ty.fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4575</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4575</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>op</var><b>: </b><span>{n : Nat} →
  {ctx : Vector Ty n} → {a b c : Ty} → (Ty.interp a → Ty.interp b → Ty.interp c) → Expr ctx a → Expr ctx b → Expr ctx c</span></span></div></blockquote></div></small></div>op</span><span class="alectryon-token">    : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>interp</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>interp</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>interp</span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4665</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4665</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4665</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ife</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a : Ty} → Expr ctx Ty.bool → Expr ctx a → Expr ctx a → Expr ctx a</span></span></div></blockquote></div></small></div>ife</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4786</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.bool</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>Ty.bool</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4786</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4786</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4786</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delay</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a : Ty} → (Unit → Expr ctx a) → Expr ctx a</span></span></div></blockquote></div></small></div>delay</span><span class="alectryon-token"> : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4829</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Expr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.4829</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"></span></span></pre>
<p>We use the command <code>open</code> to create the aliases <code>stop</code> and <code>pop</code> for <code>HasType.stop</code> and <code>HasType.pop</code> respectively.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> HasType (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pop</var><b>: </b><span>{x : Nat} → {k : Fin x} → {ctx : Vector Ty x} → {ty u : Ty} → HasType k ctx ty → HasType (Fin.succ k) (u :: ctx) ty</span></span></div></blockquote></div></small></div>pop</span><span class="alectryon-token">)</span></span></pre>
<p>Since expressions are indexed by their type, we can read the typing rules of the language from the definitions of the constructors.
Let us look at each constructor in turn.</p>
<p>We use a nameless representation for variables — they are de Bruijn indexed.
Variables are represented by a proof of their membership in the context, <code>HasType i ctx ty</code>,
which is a proof that variable <code>i</code> in context <code>ctx</code> has type <code>ty</code>.</p>
<p>We can treat <code>stop</code> as a proof that the most recently defined variable is well-typed,
and <code>pop n</code> as a proof that, if the <code>n</code>th most recently defined variable is well-typed, so is the <code>n+1</code>th.
In practice, this means we use <code>stop</code> to refer to the most recently defined variable,
<code>pop stop</code> to refer to the next, and so on, via the <code>Expr.var</code> constructor.</p>
<p>A value <code>Expr.val</code> carries a concrete representation of an integer.</p>
<p>A lambda <code>Expr.lam</code> creates a function. In the scope of a function of type <code>Ty.fn a ty</code>, there is a
new local variable of type <code>a</code>.</p>
<p>A function application <code>Expr.app</code> produces a value of type <code>ty</code> given a function from <code>a</code> to <code>ty</code> and a value of type <code>a</code>.</p>
<p>The constructor <code>Expr.op</code> allows us to use arbitrary binary operators, where the type of the operator informs what the types of the arguments must be.</p>
<p>Finally, the constructor <code>Exp.ife</code> represents a <code>if-then-else</code> expression. The condition is a Boolean, and each branch must have the same type.</p>
<p>The auxiliary constructor <code>Expr.delay</code> is used to delay evaluation.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<p>When we evaluate an <code>Expr</code>, we’ll need to know the values in scope, as well as their types. <code>Env</code> is an environment,
indexed over the types in scope. Since an environment is just another form of list, albeit with a strongly specified connection
to the vector of local variable types, we overload again the notation <code>::</code> so that we can use the usual list syntax.
Given a proof that a variable is defined in the context, we can then produce a value from the environment.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env</var><b>: </b><span>{n : Nat} → Vector Ty n → Type</span></span></div></blockquote></div></small></div><span class="nv">Env</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector</var><b>: </b><span>Type → Nat → Type</span></span></div></blockquote></div></small></div>Vector</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>Env Vector.nil</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env</var><b>: </b><span>{n : Nat} → Vector Ty n → Type</span></span></div></blockquote></div></small></div><span class="nv">Env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Vector.nil</var><b>: </b><span>{α : Type} → Vector α 0</span></span></div></blockquote></div></small></div>Vector.nil</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{a : Ty} → {x : Nat} → {ctx : Vector Ty x} → Ty.interp a → Env ctx → Env (a :: ctx)</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>Ty.interp</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env</var><b>: </b><span>{n : Nat} → Vector Ty n → Type</span></span></div></blockquote></div></small></div><span class="nv">Env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.9139</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env</var><b>: </b><span>{n : Nat} → Vector Ty n → Type</span></span></div></blockquote></div></small></div><span class="nv">Env</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.9139</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">infix</span></span><span class="alectryon-token">:<span class="mi">67</span> <span class="s2">&quot; :: &quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env.cons</var><b>: </b><span>{a : Ty} → {x : Nat} → {ctx : Vector Ty x} → Ty.interp a → Env ctx → Env (a :: ctx)</span></span></div></blockquote></div></small></div>Env.cons</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env.lookup</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Env ctx → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">Env.lookup</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HasType</var><b>: </b><span>{n : Nat} → Fin n → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div>HasType</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Fin ?m.12204</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.12204</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env</var><b>: </b><span>{n : Nat} → Vector Ty n → Type</span></span></div></blockquote></div></small></div>Env</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.12204</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>interp</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token">,  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>Env ctx✝</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pop</var><b>: </b><span>{x : Nat} → {k : Fin x} → {ctx : Vector Ty x} → {ty u : Ty} → HasType k ctx ty → HasType (Fin.succ k) (u :: ctx) ty</span></span></div></blockquote></div></small></div>pop</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>HasType k✝ ctx✝ ty</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.interp u✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>Env ctx✝</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lookup</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Env ctx → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">lookup</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>HasType k✝ ctx✝ ty</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>Env ctx✝</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"></span></span></pre>
<p>Given this, an interpreter is a function which translates an <code>Expr</code> into a Lean value with respect to a specific environment.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr.interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">Expr.interp</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env</var><b>: </b><span>{n : Nat} → Vector Ty n → Type</span></span></div></blockquote></div></small></div>Env</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.15086</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div>Expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.15086</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>interp</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Expr ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>HasType i✝ ctx ty</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lookup</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Env ctx → Ty.interp ty</span></span></div></blockquote></div></small></div>lookup</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>HasType i✝ ctx ty</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → Int → Expr ctx Ty.int</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Int</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Int</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{n : Nat} → {a : Ty} → {ctx : Vector Ty n} → {ty : Ty} → Expr (a :: ctx) ty → Expr ctx (Ty.fn a ty)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr (a✝ :: ctx) ty✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.interp a✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Expr (a✝ :: ctx) ty✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env.cons</var><b>: </b><span>{a : Ty} → {x : Nat} → {ctx : Vector Ty x} → Ty.interp a → Env ctx → Env (a :: ctx)</span></span></div></blockquote></div></small></div>Env.cons</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.interp a✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a ty : Ty} → Expr ctx (Ty.fn a ty) → Expr ctx a → Expr ctx ty</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Expr ctx (Ty.fn a✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr ctx a✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Expr ctx (Ty.fn a✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Expr ctx a✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>op</var><b>: </b><span>{n : Nat} →
  {ctx : Vector Ty n} → {a b c : Ty} → (Ty.interp a → Ty.interp b → Ty.interp c) → Expr ctx a → Expr ctx b → Expr ctx c</span></span></div></blockquote></div></small></div>op</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>Ty.interp a✝ → Ty.interp b✝ → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Expr ctx a✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Expr ctx b✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>o</var><b>: </b><span>Ty.interp a✝ → Ty.interp b✝ → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">o</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Expr ctx a✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Expr ctx b✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ife</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a : Ty} → Expr ctx Ty.bool → Expr ctx a → Expr ctx a → Expr ctx a</span></span></div></blockquote></div></small></div>ife</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Expr ctx Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Expr ctx ty</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr ctx ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Expr ctx Ty.bool</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Expr ctx ty</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Expr ctx ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="nv">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delay</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a : Ty} → (Unit → Expr ctx a) → Expr ctx a</span></span></div></blockquote></div></small></div>delay</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Unit → Expr ctx ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Unit → Expr ctx ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div><span class="na">interp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Env ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Expr</span></span></pre>
<p>We can make some simple test functions. Firstly, adding two inputs <code>fun x y =&gt; y + x</code> is written as follows.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → Expr ctx (Ty.fn Ty.int (Ty.fn Ty.int Ty.int))</span></span></div></blockquote></div></small></div><span class="nv">add</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div>Expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.19458</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>Ty.fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>Ty.int</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>Ty.fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>Ty.int</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>Ty.int</span><span class="alectryon-token">)) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{n : Nat} → {a : Ty} → {ctx : Vector Ty n} → {ty : Ty} → Expr (a :: ctx) ty → Expr ctx (Ty.fn a ty)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{n : Nat} → {a : Ty} → {ctx : Vector Ty n} → {ty : Ty} → Expr (a :: ctx) ty → Expr ctx (Ty.fn a ty)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>op</var><b>: </b><span>{n : Nat} →
  {ctx : Vector Ty n} → {a b c : Ty} → (Ty.interp a → Ty.interp b → Ty.interp c) → Expr ctx a → Expr ctx b → Expr ctx c</span></span></div></blockquote></div></small></div>op</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·)</var><b>: </b><span>Ty.interp Ty.int → Ty.interp Ty.int → Ty.interp Ty.int</span></span></div></blockquote></div></small></div>(<span class="bp">·+·</span>)</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Expr ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Expr ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pop</var><b>: </b><span>{x : Nat} → {k : Fin x} → {ctx : Vector Ty x} → {ty u : Ty} → HasType k ctx ty → HasType (Fin.succ k) (u :: ctx) ty</span></span></div></blockquote></div></small></div>pop</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token">))))

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="interp-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="interp-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">30</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → Expr ctx (Ty.fn Ty.int (Ty.fn Ty.int Ty.int))</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div>interp</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env.nil</var><b>: </b><span>Env Vector.nil</span></span></div></blockquote></div></small></div>Env.nil</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Ty.interp Ty.int</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>20</var><b>: </b><span>Ty.interp Ty.int</span></span></div></blockquote></div></small></div><span class="mi">20</span></span><span class="alectryon-token"></span></span></pre>
<p>More interestingly, a factorial function fact (e.g. <code>fun x =&gt; if (x == 0) then 1 else (fact (x-1) * x)</code>), can be written as.
Note that this is a recursive (non-terminating) definition. For every input value, the interpreter terminates, but the
definition itself is non-terminating. We use two tricks to make sure Lean accepts it. First, we use the auxiliary constructor
<code>Expr.delay</code> to delay its unfolding. Second, we add the annotation <code>decreasing_by sorry</code> which can be viewed as
&quot;trust me, this recursive definition makes sense&quot;. Recall that <code>sorry</code> is an unsound axiom in Lean.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="interp-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="interp-lean-chk1"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fact</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → Expr ctx (Ty.fn Ty.int Ty.int)</span></span></div></blockquote></div></small></div><span class="nv">fact</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Expr</var><b>: </b><span>{n : Nat} → Vector Ty n → Ty → Type</span></span></div></blockquote></div></small></div>Expr</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>Vector Ty ?m.19850</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>Ty.fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>Ty.int</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.int</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>Ty.int</span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{n : Nat} → {a : Ty} → {ctx : Vector Ty n} → {ty : Ty} → Expr (a :: ctx) ty → Expr ctx (Ty.fn a ty)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ife</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a : Ty} → Expr ctx Ty.bool → Expr ctx a → Expr ctx a → Expr ctx a</span></span></div></blockquote></div></small></div>ife</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>op</var><b>: </b><span>{n : Nat} →
  {ctx : Vector Ty n} → {a b c : Ty} → (Ty.interp a → Ty.interp b → Ty.interp c) → Expr ctx a → Expr ctx b → Expr ctx c</span></span></div></blockquote></div></small></div>op</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·==·)</var><b>: </b><span>Ty.interp Ty.int → Ty.interp Ty.int → Bool</span></span></div></blockquote></div></small></div>(<span class="bp">·==·</span>)</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Expr ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → Int → Expr ctx Ty.int</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Int</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">))
           (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → Int → Expr ctx Ty.int</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Int</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)
           (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>op</var><b>: </b><span>{n : Nat} →
  {ctx : Vector Ty n} → {a b c : Ty} → (Ty.interp a → Ty.interp b → Ty.interp c) → Expr ctx a → Expr ctx b → Expr ctx c</span></span></div></blockquote></div></small></div>op</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·*·)</var><b>: </b><span>Ty.interp Ty.int → Ty.interp Ty.int → Ty.interp Ty.int</span></span></div></blockquote></div></small></div>(<span class="bp">·*·</span>)</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>delay</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a : Ty} → (Unit → Expr ctx a) → Expr ctx a</span></span></div></blockquote></div></small></div>delay</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → {a ty : Ty} → Expr ctx (Ty.fn a ty) → Expr ctx a → Expr ctx ty</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fact</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → Expr ctx (Ty.fn Ty.int Ty.int)</span></span></div></blockquote></div></small></div><span class="nv">fact</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>op</var><b>: </b><span>{n : Nat} →
  {ctx : Vector Ty n} → {a b c : Ty} → (Ty.interp a → Ty.interp b → Ty.interp c) → Expr ctx a → Expr ctx b → Expr ctx c</span></span></div></blockquote></div></small></div>op</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·-·)</var><b>: </b><span>Ty.interp Ty.int → Ty.interp Ty.int → Ty.interp Ty.int</span></span></div></blockquote></div></small></div>(<span class="bp">·-·</span>)</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Expr ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{n : Nat} → {ctx : Vector Ty n} → Int → Expr ctx Ty.int</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Int</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">))) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{n : Nat} → {i : Fin n} → {ctx : Vector Ty n} → {ty : Ty} → HasType i ctx ty → Expr ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stop</var><b>: </b><span>{ty : Ty} → {x : Nat} → {ctx : Vector Ty x} → HasType 0 (ty :: ctx) ty</span></span></div></blockquote></div></small></div>stop</span><span class="alectryon-token">)))
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="interp-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="interp-lean-chk2"><span class="alectryon-token"><span class="k">decreasing_by</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>ctx</var><span class="hyp-type"><b>: </b><span>Vector Ty a<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(invImage (<span class="k">fun</span> a <span class="bp">=&gt;</span> PSigma.casesOn a <span class="k">fun</span> x1 snd <span class="bp">=&gt;</span> sizeOf x1) instWellFoundedRelation)<span class="bp">.</span><span class="mi">1</span>
  { fst := a<span class="bp">✝</span> <span class="bp">+</span> <span class="mi">1</span>, snd := Ty.int :: ctx } { fst := a<span class="bp">✝</span>, snd := ctx }</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="interp-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="interp-lean-chk3"><span class="alectryon-token"><span class="gr">sorry</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="interp-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="interp-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">3628800</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fact</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → Expr ctx (Ty.fn Ty.int Ty.int)</span></span></div></blockquote></div></small></div>fact</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>interp</var><b>: </b><span>{a : Nat} → {ctx : Vector Ty a} → {ty : Ty} → Env ctx → Expr ctx ty → Ty.interp ty</span></span></div></blockquote></div></small></div>interp</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Env.nil</var><b>: </b><span>Env Vector.nil</span></span></div></blockquote></div></small></div>Env.nil</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Ty.interp Ty.int</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token"></span></span></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="dependent-de-bruijn-indices"><a class="header" href="#dependent-de-bruijn-indices">Dependent de Bruijn Indices</a></h1>
<p>In this example, we represent program syntax terms in a type family parameterized by a list of types,
representing the typing context, or information on which free variables are in scope and what
their types are.</p>
<p>Remark: this example is based on an example in the book <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> by Adam Chlipala.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<p>Programmers who move to statically typed functional languages from scripting languages
often complain about the requirement that every element of a list have the same type. With
fancy type systems, we can partially lift this requirement. We can index a list type with a
“type-level” list that explains what type each element of the list should have. This has been
done in a variety of ways in Haskell using type classes, and we can do it much more cleanly
and directly in Lean.</p>
<p>We parameterize our heterogeneous lists by at type <code>α</code> and an <code>α</code>-indexed type <code>β</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>{α : Type v} → (α → Type u) → List α → Type (max u v)</span></span></div></blockquote></div></small></div><span class="nv">HList</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type v</var><b>: </b><span>Type (v + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> v</span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>α → Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type (max u v)</var><b>: </b><span>Type ((max u v) + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> (max u v)</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nil</var><b>: </b><span>{α : Type v} → {β : α → Type u} → HList β []</span></span></div></blockquote></div></small></div>nil</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>{α : Type v} → (α → Type u) → List α → Type (max u v)</span></span></div></blockquote></div></small></div><span class="nv">HList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>α → Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>cons</var><b>: </b><span>{α : Type v} → {β : α → Type u} → {i : α} → {is : List α} → β i → HList β is → HList β (i :: is)</span></span></div></blockquote></div></small></div>cons</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>α → Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>{α : Type v} → (α → Type u) → List α → Type (max u v)</span></span></div></blockquote></div></small></div><span class="nv">HList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>α → Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>is</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">is</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>{α : Type v} → (α → Type u) → List α → Type (max u v)</span></span></div></blockquote></div></small></div><span class="nv">HList</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>α → Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>is</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">is</span></span><span class="alectryon-token">)</span></span></pre>
<p>We overload the <code>List.cons</code> notation <code>::</code> so we can also use it to create
heterogeneous lists.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">infix</span></span><span class="alectryon-token">:<span class="mi">67</span> <span class="s2">&quot; :: &quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.cons</var><b>: </b><span>{α : Type v} → {β : α → Type u} → {i : α} → {is : List α} → β i → HList β is → HList β (i :: is)</span></span></div></blockquote></div></small></div>HList.cons</span><span class="alectryon-token"></span></span></pre>
<p>We similarly overload the <code>List</code> notation <code>[]</code> for the empty heterogeneous list.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">notation</span></span><span class="alectryon-token"> <span class="s2">&quot;[&quot;</span> <span class="s2">&quot;]&quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.nil</var><b>: </b><span>{α : Type v} → {β : α → Type u} → HList β []</span></span></div></blockquote></div></small></div>HList.nil</span><span class="alectryon-token"></span></span></pre>
<p>Variables are represented in a way isomorphic to the natural numbers, where
number 0 represents the first element in the context, number 1 the second element, and so
on. Actually, instead of numbers, we use the <code>Member</code> inductive family.</p>
<p>The value of type <code>Member a as</code> can be viewed as a certificate that <code>a</code> is
an element of the list <code>as</code>. The constructor <code>Member.head</code> says that <code>a</code>
is in the list if the list begins with it. The constructor <code>Member.tail</code>
says that if <code>a</code> is in the list <code>bs</code>, it is also in the list <code>b::bs</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Member</var><b>: </b><span>{α : Type} → α → List α → Type</span></span></div></blockquote></div></small></div><span class="nv">Member</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>head</var><b>: </b><span>{α : Type} → {a : α} → {as : List α} → Member a (a :: as)</span></span></div></blockquote></div></small></div>head</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Member</var><b>: </b><span>{α : Type} → α → List α → Type</span></span></div></blockquote></div></small></div><span class="nv">Member</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>?m.4850</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>?m.4850</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List ?m.4850</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tail</var><b>: </b><span>{α : Type} → {a : α} → {bs : List α} → {b : α} → Member a bs → Member a (b :: bs)</span></span></div></blockquote></div></small></div>tail</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Member</var><b>: </b><span>{α : Type} → α → List α → Type</span></span></div></blockquote></div></small></div><span class="nv">Member</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>?m.5012</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>List ?m.5012</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Member</var><b>: </b><span>{α : Type} → α → List α → Type</span></span></div></blockquote></div></small></div><span class="nv">Member</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>?m.5012</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>?m.5012</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bs</var><b>: </b><span>List ?m.5012</span></span></div></blockquote></div></small></div><span class="nv">bs</span></span><span class="alectryon-token">)</span></span></pre>
<p>Given a heterogeneous list <code>HList β is</code> and value of type <code>Member i is</code>, <code>HList.get</code>
retrieves an element of type <code>β i</code> from the list.
The pattern <code>.head</code> and <code>.tail h</code> are sugar for <code>Member.head</code> and <code>Member.tail h</code> respectively.
Lean can infer the namespace using the expected type.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList.get</var><b>: </b><span>{α : Type} → {β : α → Type u_1} → {is : List α} → {i : α} → HList β is → Member i is → β i</span></span></div></blockquote></div></small></div><span class="nv">HList.get</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>{α : Type} → (α → Type u_1) → List α → Type u_1</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>?m.5541 → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>is</var><b>: </b><span>List ?m.5541</span></span></div></blockquote></div></small></div><span class="nv">is</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Member</var><b>: </b><span>{α : Type} → α → List α → Type</span></span></div></blockquote></div></small></div>Member</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>?m.5541</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>is</var><b>: </b><span>List ?m.5541</span></span></div></blockquote></div></small></div><span class="nv">is</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>?m.5541 → Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>?m.5541</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>β i</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList β is✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.head</var><b>: </b><span>Member i (i :: is✝)</span></span></div></blockquote></div></small></div><span class="bp">.</span>head</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>β i</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk0"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>β i✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>a<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList β is✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.tail</var><b>: </b><span>{α : Type} → {a : α} → {bs : List α} → {b : α} → Member a bs → Member a (b :: bs)</span></span></div></blockquote></div></small></div><span class="bp">.</span>tail</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Member i is✝</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>HList β is✝</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type} → {β : α → Type u_1} → {is : List α} → {i : α} → HList β is → Member i is → β i</span></span></div></blockquote></div></small></div><span class="nv">get</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Member i is✝</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"></span></span></pre>
<p>Here is the definition of the simple type system for our programming language, a simply typed
lambda calculus with natural numbers as the base type.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"></span></span></pre>
<p>We can write a function to translate <code>Ty</code> values to a Lean type
— remember that types are first class, so can be calculated just like any other value.
We mark <code>Ty.denote</code> as <code>[reducible]</code> to make sure the typeclass resolution procedure can
unfold/reduce it. For example, suppose Lean is trying to synthesize a value for the instance
<code>Add (Ty.denote Ty.nat)</code>. Since <code>Ty.denote</code> is marked as <code>[reducible]</code>,
the typeclass resolution procedure can reduce <code>Ty.denote Ty.nat</code> to <code>Nat</code>, and use
the builtin instance for <code>Add Nat</code> as the solution.</p>
<p>Recall that the term <code>a.denote</code> is sugar for <code>denote a</code> where <code>denote</code> is the function being defined.
We call it the &quot;dot notation&quot;.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[reducible]</span> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Ty.denote</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"></span></span></pre>
<p>Here is the definition of the <code>Term</code> type, including variables, constants, addition,
function application and abstraction, and let binding of local variables.
Since <code>let</code> is a keyword in Lean, we use the &quot;escaped identifier&quot; <code>«let»</code>.
You can input the unicode (French double quotes) using <code>\f&lt;&lt;</code> (for <code>«</code>) and <code>\f&gt;&gt;</code> (for <code>»</code>).
The term <code>Term ctx .nat</code> is sugar for <code>Term ctx Ty.nat</code>, Lean infers the namespace using the expected type.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{ty : Ty} → {ctx : List Ty} → Member ty ctx → Term ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Member</var><b>: </b><span>{α : Type} → α → List α → Type</span></span></div></blockquote></div></small></div>Member</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx Ty.nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{ctx : List Ty} → Term ctx Ty.nat → Term ctx Ty.nat → Term ctx Ty.nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{ctx : List Ty} → {dom ran : Ty} → Term ctx (Ty.fn dom ran) → Term ctx dom → Term ctx ran</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{dom : Ty} → {ctx : List Ty} → {ran : Ty} → Term (dom :: ctx) ran → Term ctx (Ty.fn dom ran)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>«let»</var><b>: </b><span>{ctx : List Ty} → {ty₁ ty₂ : Ty} → Term ctx ty₁ → Term (ty₁ :: ctx) ty₂ → Term ctx ty₂</span></span></div></blockquote></div></small></div><span class="bp">«</span><span class="k">let</span><span class="bp">»</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₁</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₁</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₁</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₁</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₂</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₂</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₂</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₂</span></span><span class="alectryon-token"></span></span></pre>
<p>Here are two example terms encoding, the first addition packaged as a two-argument
curried function, and the second of a sample application of addition to constants.</p>
<p>The command <code>open Ty Term Member</code> opens the namespaces <code>Ty</code>, <code>Term</code>, and <code>Member</code>. Thus,
you can write <code>lam</code> instead of <code>Term.lam</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Ty Term Member
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>Term [] (fn nat (fn nat nat))</span></span></div></blockquote></div></small></div><span class="nv">add</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">)) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{dom : Ty} → {ctx : List Ty} → {ran : Ty} → Term (dom :: ctx) ran → Term ctx (fn dom ran)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{dom : Ty} → {ctx : List Ty} → {ran : Ty} → Term (dom :: ctx) ran → Term ctx (fn dom ran)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{ctx : List Ty} → Term ctx nat → Term ctx nat → Term ctx nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{ty : Ty} → {ctx : List Ty} → Member ty ctx → Term ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tail</var><b>: </b><span>{α : Type} → {a : α} → {bs : List α} → {b : α} → Member a bs → Member a (b :: bs)</span></span></div></blockquote></div></small></div>tail</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>head</var><b>: </b><span>{α : Type} → {a : α} → {as : List α} → Member a (a :: as)</span></span></div></blockquote></div></small></div>head</span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{ty : Ty} → {ctx : List Ty} → Member ty ctx → Term ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>head</var><b>: </b><span>{α : Type} → {a : α} → {as : List α} → Member a (a :: as)</span></span></div></blockquote></div></small></div>head</span><span class="alectryon-token">)))

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>three_the_hard_way</var><b>: </b><span>Term [] nat</span></span></div></blockquote></div></small></div><span class="nv">three_the_hard_way</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{ctx : List Ty} → {dom ran : Ty} → Term ctx (fn dom ran) → Term ctx dom → Term ctx ran</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{ctx : List Ty} → {dom ran : Ty} → Term ctx (fn dom ran) → Term ctx dom → Term ctx ran</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>Term [] (fn nat (fn nat nat))</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">)</span></span></pre>
<p>Since dependent typing ensures that any term is well-formed in its context and has a particular type,
it is easy to translate syntactic terms into Lean values.</p>
<p>The attribute <code>[simp]</code> instructs Lean to always try to unfold <code>Term.denote</code> applications when one applies
the <code>simp</code> tactic. We also say this is a hint for the Lean term simplifier.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term.denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">Term.denote</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HList</var><b>: </b><span>{α : Type} → (α → Type) → List α → Type</span></span></div></blockquote></div></small></div>HList</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>Ty.denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{ty : Ty} → {ctx : List Ty} → Member ty ctx → Term ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Member ty ctx</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">,     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{α : Type} → {β : α → Type} → {is : List α} → {i : α} → HList β is → Member i is → β i</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Member ty ctx</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">,   _   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{ctx : List Ty} → Term ctx nat → Term ctx nat → Term ctx nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">,  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{ctx : List Ty} → {dom ran : Ty} → Term ctx (fn dom ran) → Term ctx dom → Term ctx ran</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term ctx (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">,   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term ctx (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{dom : Ty} → {ctx : List Ty} → {ran : Ty} → Term (dom :: ctx) ran → Term ctx (fn dom ran)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (dom✝ :: ctx) ran✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">,     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.denote dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (dom✝ :: ctx) ran✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.denote dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>«let»</var><b>: </b><span>{ctx : List Ty} → {ty₁ ty₂ : Ty} → Term ctx ty₁ → Term (ty₁ :: ctx) ty₂ → Term ctx ty₂</span></span></div></blockquote></div></small></div><span class="bp">«</span><span class="k">let</span><span class="bp">»</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (ty₁✝ :: ctx) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (ty₁✝ :: ctx) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">)</span></span></pre>
<p>You can show that the denotation of <code>three_the_hard_way</code> is indeed <code>3</code> using reflexivity.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>Term.denote three_the_hard_way [] = 3</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>three_the_hard_way</var><b>: </b><span>Term [] nat</span></span></div></blockquote></div></small></div>three_the_hard_way</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>HList Ty.denote []</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Ty.denote nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token"></span></span></pre>
<p>We now define the constant folding optimization that traverses a term if replaces subterms such as
<code>plus (const m) (const n)</code> with <code>const (n+m)</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term.constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">Term.constFold</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{ty : Ty} → {ctx : List Ty} → Member ty ctx → Term ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Member ty ctx</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{ty : Ty} → {ctx : List Ty} → Member ty ctx → Term ctx ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Member ty ctx</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{ctx : List Ty} → {dom ran : Ty} → Term ctx (fn dom ran) → Term ctx dom → Term ctx ran</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term ctx (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{ctx : List Ty} → {dom ran : Ty} → Term ctx (fn dom ran) → Term ctx dom → Term ctx ran</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term ctx (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{dom : Ty} → {ctx : List Ty} → {ran : Ty} → Term (dom :: ctx) ran → Term ctx (fn dom ran)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (dom✝ :: ctx) ran✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{dom : Ty} → {ctx : List Ty} → {ran : Ty} → Term (dom :: ctx) ran → Term ctx (fn dom ran)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (dom✝ :: ctx) ran✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>«let»</var><b>: </b><span>{ctx : List Ty} → {ty₁ ty₂ : Ty} → Term ctx ty₁ → Term (ty₁ :: ctx) ty₂ → Term ctx ty₂</span></span></div></blockquote></div></small></div><span class="bp">«</span><span class="k">let</span><span class="bp">»</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (ty₁✝ :: ctx) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>«let»</var><b>: </b><span>{ctx : List Ty} → {ty₁ ty₂ : Ty} → Term ctx ty₁ → Term (ty₁ :: ctx) ty₂ → Term ctx ty₂</span></span></div></blockquote></div></small></div><span class="bp">«</span><span class="k">let</span><span class="bp">»</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term (ty₁✝ :: ctx) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{ctx : List Ty} → Term ctx nat → Term ctx nat → Term ctx nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{ctx : List Ty} → Nat → Term ctx nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">)
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token">,      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token">      <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{ctx : List Ty} → Term ctx nat → Term ctx nat → Term ctx nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>Term ctx nat</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token"></span></span></pre>
<p>The correctness of the <code>Term.constFold</code> is proved using induction, case-analysis, and the term simplifier.
We prove all cases but the one for <code>plus</code> using <code>simp [*]</code>. This tactic instructs the term simplifier to
use hypotheses such as <code>a = b</code> as rewriting/simplications rules.
We use the <code>split</code> to break the nested <code>match</code> expression in the <code>plus</code> case into two cases.
The local variables <code>iha</code> and <code>ihb</code> are the induction hypotheses for <code>a</code> and <code>b</code>.
The modifier <code>←</code> in a term simplifier argument instructs the term simplifier to use the equation as a rewriting rule in
the &quot;reverse direction&quot;. That is, given <code>h : a = b</code>, <code>← h</code> instructs the term simplifier to rewrite <code>b</code> subterms to <code>a</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term.constFold_sound</var><b>: </b><span>∀ {ctx : List Ty} {ty : Ty} {env : HList Ty.denote ctx} (e : Term ctx ty), denote (constFold e) env = denote e env</span></span></div></blockquote></div></small></div><span class="nv">Term.constFold_sound</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>List Ty → Ty → Type</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ctx</var><b>: </b><span>List Ty</span></span></div></blockquote></div></small></div><span class="nv">ctx</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → Term ctx ty</span></span></div></blockquote></div></small></div>constFold</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ctx : List Ty} → {ty : Ty} → Term ctx ty → HList Ty.denote ctx → Ty.denote ty</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>HList Ty.denote ctx</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk1"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk2"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term ctx ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ctx</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>env</var><span class="hyp-type"><b>: </b><span>HList Ty.denote ctx</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Term ctx ty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">denote (constFold e) env <span class="bp">=</span> denote e env</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk3"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [<span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk4"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{ctx : List Ty} → Term ctx nat → Term ctx nat → Term ctx nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term ctx✝ nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term ctx✝ nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>∀ {env : HList Ty.denote ctx✝}, denote (constFold a) env = denote a env</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>∀ {env : HList Ty.denote ctx✝}, denote (constFold b) env = denote b env</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ctx</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>ctx✝</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold a) env <span class="bp">=</span> denote a env</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold b) env <span class="bp">=</span> denote b env</span></span></span><br><span><var>env</var><span class="hyp-type"><b>: </b><span>HList Ty.denote ctx<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus</span></span><div class="goal-conclusion">denote
    (<span class="k">match</span> constFold a, constFold b <span class="k">with</span>
    <span class="bp">|</span> const n, const m <span class="bp">=&gt;</span> const (n <span class="bp">+</span> m)
    <span class="bp">|</span> a&#39;, b&#39; <span class="bp">=&gt;</span> plus a&#39; b&#39;)
    env <span class="bp">=</span>
  denote a env <span class="bp">+</span> denote b env</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk5"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ctx</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>ctx✝</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold a) env <span class="bp">=</span> denote a env</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold b) env <span class="bp">=</span> denote b env</span></span></span><br><span><var>env</var><span class="hyp-type"><b>: </b><span>HList Ty.denote ctx<span class="bp">✝</span></span></span></span><br><span><var>x✝¹, x✝</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>n✝, m✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>constFold a <span class="bp">=</span> const n<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>constFold b <span class="bp">=</span> const m<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_1</span></span><div class="goal-conclusion">denote (const (n<span class="bp">✝</span> <span class="bp">+</span> m<span class="bp">✝</span>)) env <span class="bp">=</span> denote a env <span class="bp">+</span> denote b env</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="deBruijn-lean-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ctx</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>ctx✝</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold a) env <span class="bp">=</span> denote a env</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold b) env <span class="bp">=</span> denote b env</span></span></span><br><span><var>env</var><span class="hyp-type"><b>: </b><span>HList Ty.denote ctx<span class="bp">✝</span></span></span></span><br><span><var>x✝², x✝¹</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (n m : Nat), constFold a <span class="bp">=</span> const n <span class="bp">→</span> constFold b <span class="bp">=</span> const m <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="deBruijn-lean-chk6"><hr><span class="goal-name">plus.h_2</span></label><div class="goal-conclusion">denote (plus (constFold a) (constFold b)) env <span class="bp">=</span> denote a env <span class="bp">+</span> denote b env</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk7"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₁</var><b>: </b><span>constFold a = const n✝</span></span></div></blockquote></div></small></div><span class="nv">he₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₂</var><b>: </b><span>constFold b = const m✝</span></span></div></blockquote></div></small></div><span class="nv">he₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ctx</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>ctx✝</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold a) env <span class="bp">=</span> denote a env</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold b) env <span class="bp">=</span> denote b env</span></span></span><br><span><var>env</var><span class="hyp-type"><b>: </b><span>HList Ty.denote ctx<span class="bp">✝</span></span></span></span><br><span><var>x✝¹, x✝</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>n✝, m✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>constFold a <span class="bp">=</span> const n<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>constFold b <span class="bp">=</span> const m<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_1</span></span><div class="goal-conclusion">denote (const (n<span class="bp">✝</span> <span class="bp">+</span> m<span class="bp">✝</span>)) env <span class="bp">=</span> denote a env <span class="bp">+</span> denote b env</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="deBruijn-lean-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ctx</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>ctx✝</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold a) env <span class="bp">=</span> denote a env</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold b) env <span class="bp">=</span> denote b env</span></span></span><br><span><var>env</var><span class="hyp-type"><b>: </b><span>HList Ty.denote ctx<span class="bp">✝</span></span></span></span><br><span><var>x✝², x✝¹</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (n m : Nat), constFold a <span class="bp">=</span> const n <span class="bp">→</span> constFold b <span class="bp">=</span> const m <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="deBruijn-lean-chk8"><hr><span class="goal-name">plus.h_2</span></label><div class="goal-conclusion">denote (plus (constFold a) (constFold b)) env <span class="bp">=</span> denote a env <span class="bp">+</span> denote b env</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chk9"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>∀ {env : HList Ty.denote ctx✝}, denote (constFold a) env = denote a env</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token">, <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>∀ {env : HList Ty.denote ctx✝}, denote (constFold b) env = denote b env</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₁</var><b>: </b><span>constFold a = const n✝</span></span></div></blockquote></div></small></div><span class="nv">he₁</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₂</var><b>: </b><span>constFold b = const m✝</span></span></div></blockquote></div></small></div><span class="nv">he₂</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chka"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ctx</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>ctx✝</var><span class="hyp-type"><b>: </b><span>List Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold a) env <span class="bp">=</span> denote a env</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> {env : HList Ty.denote ctx<span class="bp">✝</span>}, denote (constFold b) env <span class="bp">=</span> denote b env</span></span></span><br><span><var>env</var><span class="hyp-type"><b>: </b><span>HList Ty.denote ctx<span class="bp">✝</span></span></span></span><br><span><var>x✝², x✝¹</var><span class="hyp-type"><b>: </b><span>Term ctx<span class="bp">✝</span> nat</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (n m : Nat), constFold a <span class="bp">=</span> const n <span class="bp">→</span> constFold b <span class="bp">=</span> const m <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_2</span></span><div class="goal-conclusion">denote (plus (constFold a) (constFold b)) env <span class="bp">=</span> denote a env <span class="bp">+</span> denote b env</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="deBruijn-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="deBruijn-lean-chkb"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>∀ {env : HList Ty.denote ctx✝}, denote (constFold a) env = denote a env</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>∀ {env : HList Ty.denote ctx✝}, denote (constFold b) env = denote b env</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="parametric-higher-order-abstract-syntax"><a class="header" href="#parametric-higher-order-abstract-syntax">Parametric Higher-Order Abstract Syntax</a></h1>
<p>In contrast to first-order encodings, higher-order encodings avoid explicit modeling of variable identity.
Instead, the binding constructs of an object language (the language being
formalized) can be represented using the binding constructs of the meta language (the language in which the formalization is done).
The best known higher-order encoding is called higher-order abstract syntax (HOAS),
and we can start by attempting to apply it directly in Lean.</p>
<p>Remark: this example is based on an example in the book <a href="http://adam.chlipala.net/cpdt/">Certified Programming with Dependent Types</a> by Adam Chlipala.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<p>Here is the definition of the simple type system for our programming language, a simply typed
lambda calculus with natural numbers as the base type.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Ty</span></span><span class="alectryon-token"></span></span></pre>
<p>We can write a function to translate <code>Ty</code> values to a Lean type
— remember that types are first class, so can be calculated just like any other value.
We mark <code>Ty.denote</code> as <code>[reducible]</code> to make sure the typeclass resolution procedure can
unfold/reduce it. For example, suppose Lean is trying to synthesize a value for the instance
<code>Add (Ty.denote Ty.nat)</code>. Since <code>Ty.denote</code> is marked as <code>[reducible]</code>,
the typeclass resolution procedure can reduce <code>Ty.denote Ty.nat</code> to <code>Nat</code>, and use
the builtin instance for <code>Add Nat</code> as the solution.</p>
<p>Recall that the term <code>a.denote</code> is sugar for <code>denote a</code> where <code>denote</code> is the function being defined.
We call it the &quot;dot notation&quot;.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[reducible]</span> </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Ty.denote</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"></span></span></pre>
<p>With HOAS, each object language binding construct is represented with a function of
the meta language. Here is what we get if we apply that idea within an inductive definition
of term syntax. However a naive encondig in Lean fails to meet the strict positivity restrictions
imposed by the Lean kernel. An alternate higher-order encoding is parametric HOAS, as introduced by Washburn
and Weirich for Haskell and tweaked by Adam Chlipala for use in Coq. The key idea is to parameterize the
declaration by a type family <code>rep</code> standing for a &quot;representation of variables.&quot;</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div>var</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep Ty.nat</span></span></div></blockquote></div></small></div>const</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep Ty.nat → Term' rep Ty.nat → Term' rep Ty.nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token">  : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (Ty.fn dom ran)</span></span></div></blockquote></div></small></div>lam</span><span class="alectryon-token">   : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (Ty.fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div>app</span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>dom</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">dom</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ran</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ran</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="k">let</span></span><span class="alectryon-token">   : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₁</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₁</span></span><span class="alectryon-token"> <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₁</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₁</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₂</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₂</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">Term&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty₂</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty₂</span></span><span class="alectryon-token"></span></span></pre>
<p>Lean accepts this definition because our embedded functions now merely take variables as
arguments, instead of arbitrary terms. One might wonder whether there is an easy loophole
to exploit here, instantiating the parameter <code>rep</code> as term itself. However, to do that, we
would need to choose a variable representation for this nested mention of term, and so on
through an infinite descent into term arguments.</p>
<p>We write the final type of a closed term using polymorphic quantification over all possible
choices of <code>rep</code> type family</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Ty (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kn">namespace</span></span><span class="alectryon-token"> FirstTry

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token">) := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"></span></span></pre>
<p>In the next two example, note how each is written as a function over a <code>rep</code> choice,
such that the specific choice has no impact on the structure of the term.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>Term (fn nat (fn nat nat))</span></span></div></blockquote></div></small></div><span class="nv">add</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">)) := </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">_rep</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>_rep nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>_rep nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>_rep nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>_rep nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>three_the_hard_way</var><b>: </b><span>Term nat</span></span></div></blockquote></div></small></div><span class="nv">three_the_hard_way</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>Term (fn nat (fn nat nat))</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">end</span></span><span class="alectryon-token"> FirstTry</span></span></pre>
<p>The argument <code>rep</code> does not even appear in the function body for <code>add</code>. How can that be?
By giving our terms expressive types, we allow Lean to infer many arguments for us. In fact,
we do not even need to name the <code>rep</code> argument! By using Lean implicit arguments and lambdas,
we can completely hide <code>rep</code> in these examples.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div><span class="nv">Term</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token">) := {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>Term (fn nat (fn nat nat))</span></span></div></blockquote></div></small></div><span class="nv">add</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>fn</var><b>: </b><span>Ty → Ty → Ty</span></span></div></blockquote></div></small></div>fn</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token">)) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep✝ nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>rep✝ nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep✝ nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>rep✝ nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>three_the_hard_way</var><b>: </b><span>Term nat</span></span></div></blockquote></div></small></div><span class="nv">three_the_hard_way</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nat</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>Term (fn nat (fn nat nat))</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">)</span></span></pre>
<p>It may not be at all obvious that the PHOAS representation admits the crucial computable
operations. The key to effective deconstruction of PHOAS terms is one principle: treat
the <code>rep</code> parameter as an unconstrained choice of which data should be annotated on each
variable. We will begin with a simple example, that of counting how many variable nodes
appear in a PHOAS term. This operation requires no data annotated on variables, so we
simply annotate variables with <code>Unit</code> values. Note that, when we go under binders in the
cases for <code>lam</code> and <code>let</code>, we must provide the data value to annotate on the new variable we
pass beneath. For our current choice of <code>Unit</code> data, we always pass <code>()</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> _    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> _  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; Unit) nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' (fun x =&gt; Unit) nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; Unit) nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' (fun x =&gt; Unit) nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' (fun x =&gt; Unit) (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; Unit) dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' (fun x =&gt; Unit) (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; Unit) dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → Term' (fun x =&gt; Unit) ran✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → Term' (fun x =&gt; Unit) ran✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="bp">.</span><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; Unit) ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → Term' (fun x =&gt; Unit) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; Unit) ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div><span class="nv">countVars</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → Term' (fun x =&gt; Unit) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)</span></span></pre>
<p>We can now easily prove that <code>add</code> has two variables by using reflexivity</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>countVars add = 2</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>countVars</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; Unit) ty → Nat</span></span></div></blockquote></div></small></div>countVars</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>add</var><b>: </b><span>Term (fn nat (fn nat nat))</span></span></div></blockquote></div></small></div>add</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token"></span></span></pre>
<p>Here is another example, translating PHOAS terms into strings giving a first-order rendering.
To implement this translation, the key insight is to tag variables with strings, giving their names.
The function takes as an additional input <code>i</code> which is used to create variable names for binders.
We also use the string interpolation available in Lean. For example, <code>s!&quot;x_{i}&quot;</code> is expanded to
<code>&quot;x_&quot; ++ toString i</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' (fun x =&gt; String) ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' (fun x =&gt; String) ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' (fun x =&gt; String) (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; String) dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">   <span class="bp">=&gt;</span> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;({</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' (fun x =&gt; String) (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">} {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; String) dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">})<span class="s2">&quot;</span>
<span class="s2">  |</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; String) nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' (fun x =&gt; String) nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;({</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; String) nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">} <span class="bp">+</span> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' (fun x =&gt; String) nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">})<span class="s2">&quot;</span>
<span class="s2">  |</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>String → Term' (fun x =&gt; String) ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">     <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;x_{</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">}<span class="s2">&quot;</span>
    </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;(fun {</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">} <span class="bp">=&gt;</span> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>String → Term' (fun x =&gt; String) ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)})<span class="s2">&quot;</span>
<span class="s2">  |</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="bp">.</span><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; String) ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>String → Term' (fun x =&gt; String) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;x_{</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">}<span class="s2">&quot;</span>
    </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;(let {</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">} := {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (fun x =&gt; String) ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">}<span class="bp">;</span> <span class="bp">=&gt;</span> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div><span class="nv">pretty</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>String → Term' (fun x =&gt; String) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>optParam Nat 1</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)}<span class="s2">&quot;</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="s2">&quot;(((fun x_1 =&gt; (fun x_2 =&gt; (x_1 + x_2))) 1) 2)&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div>pretty</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>three_the_hard_way</var><b>: </b><span>Term nat</span></span></div></blockquote></div></small></div>three_the_hard_way</span><span class="alectryon-token"></span></span></pre>
<p>It is not necessary to convert to a different representation to support many common
operations on terms. For instance, we can implement substitution of terms for variables.
The key insight here is to tag variables with terms, so that, on encountering a variable, we
can simply replace it by the term in its tag. We will call this function initially on a term
with exactly one free variable, tagged with the appropriate substitute. During recursion,
new variables are added, but they are only tagged with their own term equivalents. Note
that this function squash is parameterized over a specific <code>rep</code> choice.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
 <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">
 <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">
 <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (Term' rep) nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' (Term' rep) nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (Term' rep) nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' (Term' rep) nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">)
 <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' rep dom✝ → Term' (Term' rep) ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' rep dom✝ → Term' (Term' rep) ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">))
 <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' (Term' rep) (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (Term' rep) dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' (Term' rep) (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (Term' rep) dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">)
 <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="bp">.</span><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (Term' rep) ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' rep ty₁✝ → Term' (Term' rep) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="bp">.</span><span class="k">let</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' (Term' rep) ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">squash</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' rep ty₁✝ → Term' (Term' rep) ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">))</span></span></pre>
<p>To define the final substitution function over terms with single free variables, we define
<code>Term1</code>, an analogue to Term that we defined before for closed terms.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term1</var><b>: </b><span>Ty → Ty → Type 1</span></span></div></blockquote></div></small></div><span class="nv">Term1</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty1</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty2</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty2</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token">) := {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Ty</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">} <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty1</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty1</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty2</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty2</span></span><span class="alectryon-token"></span></span></pre>
<p>Substitution is defined by (1) instantiating a <code>Term1</code> to tag variables with terms and (2)
applying the result to a specific term to be substituted. Note how the parameter <code>rep</code> of
<code>squash</code> is instantiated: the body of <code>subst</code> is itself a polymorphic quantification over <code>rep</code>,
standing for a variable tag choice in the output term; and we use that input to compute a
tag choice for the input term.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>subst</var><b>: </b><span>{ty1 ty2 : Ty} → Term1 ty1 ty2 → Term ty1 → Term ty2</span></span></div></blockquote></div></small></div><span class="nv">subst</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term1 ty1 ty2</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term1</var><b>: </b><span>Ty → Ty → Type 1</span></span></div></blockquote></div></small></div>Term1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty1</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty2</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty2</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e'</var><b>: </b><span>Term ty1</span></span></div></blockquote></div></small></div><span class="nv">e&#39;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty1</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty1</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term</var><b>: </b><span>Ty → Type 1</span></span></div></blockquote></div></small></div>Term</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty2</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty2</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squash</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' (Term' rep) ty → Term' rep ty</span></span></div></blockquote></div></small></div>squash</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term1 ty1 ty2</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e'</var><b>: </b><span>Term ty1</span></span></div></blockquote></div></small></div><span class="nv">e&#39;</span></span><span class="alectryon-token">)</span></span></pre>
<p>We can view <code>Term1</code> as a term with hole. In the following example,
<code>(fun x =&gt; plus (var x) (const 5))</code> can be viewed as the term <code>plus _ (const 5)</code> where
the hole <code>_</code> is instantiated by <code>subst</code> with <code>three_the_hard_way</code></p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="s2">&quot;((((fun x_1 =&gt; (fun x_2 =&gt; (x_1 + x_2))) 1) 2) + 5)&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pretty</var><b>: </b><span>{ty : Ty} → Term' (fun x =&gt; String) ty → optParam Nat 1 → String</span></span></div></blockquote></div></small></div>pretty</span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>subst</var><b>: </b><span>{ty1 ty2 : Ty} → Term1 ty1 ty2 → Term ty1 → Term ty2</span></span></div></blockquote></div></small></div>subst</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep✝ nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep✝ nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">)) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>three_the_hard_way</var><b>: </b><span>Term nat</span></span></div></blockquote></div></small></div>three_the_hard_way</span><span class="alectryon-token"></span></span></pre>
<p>One further development, which may seem surprising at first,
is that we can also implement a usual term denotation function,
when we tag variables with their denotations.</p>
<p>The attribute <code>[simp]</code> instructs Lean to always try to unfold <code>denote</code> applications when one applies
the <code>simp</code> tactic. We also say this is a hint for the Lean term simplifier.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>Ty.denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' Ty.denote nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' Ty.denote nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' Ty.denote nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' Ty.denote nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' Ty.denote (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' Ty.denote dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' Ty.denote (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' Ty.denote dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Ty.denote dom✝ → Term' Ty.denote ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.denote dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Ty.denote dom✝ → Term' Ty.denote ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Ty.denote dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="bp">.</span><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' Ty.denote ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty.denote ty₁✝ → Term' Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Ty.denote ty₁✝ → Term' Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">denote</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' Ty.denote ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">))

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>denote three_the_hard_way = 3</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>three_the_hard_way</var><b>: </b><span>Term nat</span></span></div></blockquote></div></small></div>three_the_hard_way</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Ty.denote nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rfl</var><b>: </b><span>∀ {α : Type} {a : α}, a = a</span></span></div></blockquote></div></small></div>rfl</span><span class="alectryon-token"></span></span></pre>
<p>To summarize, the PHOAS representation has all the expressive power of more
standard encodings (e.g., using de Bruijn indices), and a variety of translations are actually much more pleasant to
implement than usual, thanks to the novel ability to tag variables with data.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<p>We now define the constant folding optimization that traverses a term if replaces subterms such as
<code>plus (const m) (const n)</code> with <code>const (n+m)</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">@</span>[</span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rep</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div><span class="nv">rep</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep ty</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.var</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="bp">.</span>var</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep ty</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' rep (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' rep dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.app</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → Term' rep (fn dom ran) → Term' rep dom → Term' rep ran</span></span></div></blockquote></div></small></div><span class="bp">.</span>app</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Term' rep (fn dom✝ ty)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' rep dom✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>rep dom✝ → Term' rep ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.lam</var><b>: </b><span>{rep : Ty → Type} → {dom ran : Ty} → (rep dom → Term' rep ran) → Term' rep (fn dom ran)</span></span></div></blockquote></div></small></div><span class="bp">.</span>lam</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>rep dom✝ → Term' rep ran✝</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep dom✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="bp">.</span><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' rep ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>rep ty₁✝ → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">  <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.let</var><b>: </b><span>{rep : Ty → Type} → {ty₁ ty₂ : Ty} → Term' rep ty₁ → (rep ty₁ → Term' rep ty₂) → Term' rep ty₂</span></span></div></blockquote></div></small></div><span class="bp">.</span><span class="k">let</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' rep ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>rep ty₁✝ → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>rep ty₁✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div><span class="nv">constFold</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.const</var><b>: </b><span>{rep : Ty → Type} → Nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>const</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>n</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">n</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">)
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token">,       </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token">       <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div><span class="bp">.</span>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a'</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">a&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b'</var><b>: </b><span>Term' rep nat</span></span></div></blockquote></div></small></div><span class="nv">b&#39;</span></span><span class="alectryon-token"></span></span></pre>
<p>The correctness of the <code>constFold</code> is proved using induction, case-analysis, and the term simplifier.
We prove all cases but the one for <code>plus</code> using <code>simp [*]</code>. This tactic instructs the term simplifier to
use hypotheses such as <code>a = b</code> as rewriting/simplications rules.
We use the <code>split</code> to break the nested <code>match</code> expression in the <code>plus</code> case into two cases.
The local variables <code>iha</code> and <code>ihb</code> are the induction hypotheses for <code>a</code> and <code>b</code>.
The modifier <code>←</code> in a term simplifier argument instructs the term simplifier to use the equation as a rewriting rule in
the &quot;reverse direction. That is, given <code>h : a = b</code>, <code>← h</code> instructs the term simplifier to rewrite <code>b</code> subterms to <code>a</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold_sound</var><b>: </b><span>∀ {ty : Ty} (e : Term' Ty.denote ty), denote (constFold e) = denote e</span></span></div></blockquote></div></small></div><span class="nv">constFold_sound</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Term'</var><b>: </b><span>(Ty → Type) → Ty → Type</span></span></div></blockquote></div></small></div>Term&#39;</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Ty.denote</var><b>: </b><span>Ty → Type</span></span></div></blockquote></div></small></div>Ty.denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ty</var><b>: </b><span>Ty</span></span></div></blockquote></div></small></div><span class="nv">ty</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>constFold</var><b>: </b><span>{rep : Ty → Type} → {ty : Ty} → Term' rep ty → Term' rep ty</span></span></div></blockquote></div></small></div>constFold</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">) <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>denote</var><b>: </b><span>{ty : Ty} → Term' Ty.denote ty → Ty.denote ty</span></span></div></blockquote></div></small></div>denote</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk2"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk3"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Term' Ty.denote ty</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote ty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">denote (constFold e) <span class="bp">=</span> denote e</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk4"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [<span class="bp">*</span>]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk5"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>plus</var><b>: </b><span>{rep : Ty → Type} → Term' rep nat → Term' rep nat → Term' rep nat</span></span></div></blockquote></div></small></div>plus</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Term' Ty.denote nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Term' Ty.denote nat</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>denote (constFold a) = denote a</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>denote (constFold b) = denote b</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>denote (constFold a) <span class="bp">=</span> denote a</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>denote (constFold b) <span class="bp">=</span> denote b</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus</span></span><div class="goal-conclusion">denote
    (<span class="k">match</span> constFold a, constFold b <span class="k">with</span>
    <span class="bp">|</span> Term&#39;.const n, Term&#39;.const m <span class="bp">=&gt;</span> Term&#39;.const (n <span class="bp">+</span> m)
    <span class="bp">|</span> a&#39;, b&#39; <span class="bp">=&gt;</span> Term&#39;.plus a&#39; b&#39;) <span class="bp">=</span>
  denote a <span class="bp">+</span> denote b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk6"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>denote (constFold a) <span class="bp">=</span> denote a</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>denote (constFold b) <span class="bp">=</span> denote b</span></span></span><br><span><var>x✝¹, x✝</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>n✝, m✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>constFold a <span class="bp">=</span> Term&#39;.const n<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>constFold b <span class="bp">=</span> Term&#39;.const m<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_1</span></span><div class="goal-conclusion">denote (Term&#39;.const (n<span class="bp">✝</span> <span class="bp">+</span> m<span class="bp">✝</span>)) <span class="bp">=</span> denote a <span class="bp">+</span> denote b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="phoas-lean-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>denote (constFold a) <span class="bp">=</span> denote a</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>denote (constFold b) <span class="bp">=</span> denote b</span></span></span><br><span><var>x✝², x✝¹</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (n m : Nat), constFold a <span class="bp">=</span> Term&#39;.const n <span class="bp">→</span> constFold b <span class="bp">=</span> Term&#39;.const m <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="phoas-lean-chk7"><hr><span class="goal-name">plus.h_2</span></label><div class="goal-conclusion">denote (Term&#39;.plus (constFold a) (constFold b)) <span class="bp">=</span> denote a <span class="bp">+</span> denote b</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chk8"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₁</var><b>: </b><span>constFold a = Term'.const n✝</span></span></div></blockquote></div></small></div><span class="nv">he₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₂</var><b>: </b><span>constFold b = Term'.const m✝</span></span></div></blockquote></div></small></div><span class="nv">he₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>denote (constFold a) <span class="bp">=</span> denote a</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>denote (constFold b) <span class="bp">=</span> denote b</span></span></span><br><span><var>x✝¹, x✝</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>n✝, m✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>heq✝¹</var><span class="hyp-type"><b>: </b><span>constFold a <span class="bp">=</span> Term&#39;.const n<span class="bp">✝</span></span></span></span><br><span><var>heq✝</var><span class="hyp-type"><b>: </b><span>constFold b <span class="bp">=</span> Term&#39;.const m<span class="bp">✝</span></span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_1</span></span><div class="goal-conclusion">denote (Term&#39;.const (n<span class="bp">✝</span> <span class="bp">+</span> m<span class="bp">✝</span>)) <span class="bp">=</span> denote a <span class="bp">+</span> denote b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="phoas-lean-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>denote (constFold a) <span class="bp">=</span> denote a</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>denote (constFold b) <span class="bp">=</span> denote b</span></span></span><br><span><var>x✝², x✝¹</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (n m : Nat), constFold a <span class="bp">=</span> Term&#39;.const n <span class="bp">→</span> constFold b <span class="bp">=</span> Term&#39;.const m <span class="bp">→</span> False</span></span></span><br></div><label class="goal-separator" for="phoas-lean-chk9"><hr><span class="goal-name">plus.h_2</span></label><div class="goal-conclusion">denote (Term&#39;.plus (constFold a) (constFold b)) <span class="bp">=</span> denote a <span class="bp">+</span> denote b</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chka"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>denote (constFold a) = denote a</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token">, <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>denote (constFold b) = denote b</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₁</var><b>: </b><span>constFold a = Term'.const n✝</span></span></div></blockquote></div></small></div><span class="nv">he₁</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>he₂</var><b>: </b><span>constFold b = Term'.const m✝</span></span></div></blockquote></div></small></div><span class="nv">he₂</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chkb"><span class="alectryon-token"><span class="k">next</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ty</var><span class="hyp-type"><b>: </b><span>Ty</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>iha</var><span class="hyp-type"><b>: </b><span>denote (constFold a) <span class="bp">=</span> denote a</span></span></span><br><span><var>ihb</var><span class="hyp-type"><b>: </b><span>denote (constFold b) <span class="bp">=</span> denote b</span></span></span><br><span><var>x✝², x✝¹</var><span class="hyp-type"><b>: </b><span>Term&#39; Ty.denote nat</span></span></span><br><span><var>x✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (n m : Nat), constFold a <span class="bp">=</span> Term&#39;.const n <span class="bp">→</span> constFold b <span class="bp">=</span> Term&#39;.const m <span class="bp">→</span> False</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">plus.h_2</span></span><div class="goal-conclusion">denote (Term&#39;.plus (constFold a) (constFold b)) <span class="bp">=</span> denote a <span class="bp">+</span> denote b</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="phoas-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="phoas-lean-chkc"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>iha</var><b>: </b><span>denote (constFold a) = denote a</span></span></div></blockquote></div></small></div><span class="nv">iha</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihb</var><b>: </b><span>denote (constFold b) = denote b</span></span></div></blockquote></div></small></div><span class="nv">ihb</span></span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="organizational-features"><a class="header" href="#organizational-features">Organizational features</a></h1>
<p>In this section we introduce some organizational features of Lean that are not a part of its kernel per se,
but make it possible to work in the framework more efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-sections"><a class="header" href="#variables-and-sections">Variables and Sections</a></h1>
<p>Consider the following three function definitions:</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (α : Type) (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (α : Type) (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<p>Lean provides us with the <code>variable</code> command to make such declarations look more compact:</p>
<pre><code class="language-lean">variable (α β γ : Type)

def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<p>We can declare variables of any type, not just <code>Type</code> itself:</p>
<pre><code class="language-lean">variable (α β γ : Type)
variable (g : β → γ) (f : α → β) (h : α → α)
variable (x : α)

def compose := g (f x)
def doTwice := h (h x)
def doThrice := h (h (h x))

#print compose
#print doTwice
#print doThrice
</code></pre>
<p>Printing them out shows that all three groups of definitions have exactly the same effect.</p>
<p>The <code>variable</code> command instructs Lean to insert the declared variables as bound variables in definitions that refer to them.
Lean is smart enough to figure out which variables are used explicitly or implicitly in a definition. We can therefore proceed as
though <code>α</code>, <code>β</code>, <code>γ</code>, <code>g</code>, <code>f</code>, <code>h</code>, and <code>x</code> are fixed objects when we write our definitions, and let Lean abstract
the definitions for us automatically.</p>
<p>When declared in this way, a variable stays in scope until the end of the file we are working on.
Sometimes, however, it is useful to limit the scope of a variable. For that purpose, Lean provides the notion of a <code>section</code>:</p>
<pre><code class="language-lean">section useful
  variable (α β γ : Type)
  variable (g : β → γ) (f : α → β) (h : α → α)
  variable (x : α)

  def compose := g (f x)
  def doTwice := h (h x)
  def doThrice := h (h (h x))
end useful
</code></pre>
<p>When the section is closed, the variables go out of scope, and become nothing more than a distant memory.</p>
<p>You do not have to indent the lines within a section. Nor do you have to name a section, which is to say,
you can use an anonymous <code>section</code> / <code>end</code> pair.
If you do name a section, however, you have to close it using the same name.
Sections can also be nested, which allows you to declare new variables incrementally.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Lean provides us with the ability to group definitions into nested, hierarchical <em>namespaces</em>:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
  def ffa : Nat := f (f a)

  #check a
  #check f
  #check fa
  #check ffa
  #check Foo.fa
end Foo

-- #check a  -- error
-- #check f  -- error
#check Foo.a
#check Foo.f
#check Foo.fa
#check Foo.ffa

open Foo

#check a
#check f
#check fa
#check Foo.fa
</code></pre>
<p>When we declare that we are working in the namespace <code>Foo</code>, every identifier we declare has
a full name with prefix &quot;<code>Foo.</code>&quot; Within the namespace, we can refer to identifiers
by their shorter names, but once we end the namespace, we have to use the longer names.</p>
<p>The <code>open</code> command brings the shorter names into the current context. Often, when we import a
module, we will want to open one or more of the namespaces it contains, to have access to the short identifiers.
But sometimes we will want to leave this information hidden, for example, when they conflict with
identifiers in another namespace we want to use. Thus namespaces give us a way to manage our working environment.</p>
<p>For example, Lean groups definitions and theorems involving lists into a namespace <code>List</code>.</p>
<pre><code class="language-lean">#check List.nil
#check List.cons
#check List.map
</code></pre>
<p>We will discuss their types, below. The command <code>open List</code> allows us to use the shorter names:</p>
<pre><code class="language-lean">open List

#check nil
#check cons
#check map
</code></pre>
<p>Like sections, namespaces can be nested:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a

  namespace Bar
    def ffa : Nat := f (f a)

    #check fa
    #check ffa
  end Bar

  #check fa
  #check Bar.ffa
end Foo

#check Foo.fa
#check Foo.Bar.ffa

open Foo

#check fa
#check Bar.ffa
</code></pre>
<p>Namespaces that have been closed can later be reopened, even in another file:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
end Foo

#check Foo.a
#check Foo.f

namespace Foo
  def ffa : Nat := f (f a)
end Foo
</code></pre>
<p>Like sections, nested namespaces have to be closed in the order they are opened.
Namespaces and sections serve different purposes: namespaces organize data and sections declare variables for insertion in definitions.
Sections are also useful for delimiting the scope of commands such as <code>set_option</code> and <code>open</code>.</p>
<p>In many respects, however, a <code>namespace ... end</code> block behaves the same as a <code>section ... end</code> block.
In particular, if you use the <code>variable</code> command within a namespace, its scope is limited to the namespace.
Similarly, if you use an <code>open</code> command within a namespace, its effects disappear when the namespace is closed.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implicit-arguments"><a class="header" href="#implicit-arguments">Implicit Arguments</a></h2>
<p>Suppose we define the <code>compose</code> function as.</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>The function <code>compose</code> takes three types, <code>α</code>, <code>β</code>, and <code>γ</code>, and two functions, <code>g : β → γ</code> and <code>f : α → β</code>, a value <code>x : α</code>, and
returns <code>g (f x)</code>, the composition of <code>g</code> and <code>f</code>.
We say <code>compose</code> is polymorphic over types <code>α</code>, <code>β</code>, and <code>γ</code>. Now, let's use <code>compose</code>:</p>
<pre><code class="language-lean"><span class="boring">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
</span><span class="boring">  g (f x)
</span>def double (x : Nat) := 2*x
def triple (x : Nat) := 3*x

#check compose Nat Nat Nat double triple 10 -- Nat
#eval  compose Nat Nat Nat double triple 10 -- 60

def appendWorld (s : String) := s ++ &quot;world&quot;
#check String.length -- String → Nat

#check compose String String Nat String.length appendWorld &quot;hello&quot; -- Nat
#eval  compose String String Nat String.length appendWorld &quot;hello&quot; -- 10
</code></pre>
<p>Because <code>compose</code> is polymorphic over types <code>α</code>, <code>β</code>, and <code>γ</code>, we have to provide them in the examples above.
But this information is redundant: one can infer the types from the arguments <code>g</code> and <code>f</code>.
This is a central feature of dependent type theory: terms carry a lot of information, and often some of that information can be inferred from the context.
In Lean, one uses an underscore, <code>_</code>, to specify that the system should fill in the information automatically.</p>
<pre><code class="language-lean"><span class="boring">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
</span><span class="boring"> g (f x)
</span><span class="boring">def double (x : Nat) := 2*x
</span><span class="boring">def triple (x : Nat) := 3*x
</span>#check compose _ _ _ double triple 10 -- Nat
#eval  compose Nat Nat Nat double triple 10 -- 60
<span class="boring">def appendWorld (s : String) := s ++ &quot;world&quot;
</span><span class="boring">#check String.length -- String → Nat
</span>#check compose _ _ _ String.length appendWorld &quot;hello&quot; -- Nat
#eval  compose _ _ _ String.length appendWorld &quot;hello&quot; -- 10
</code></pre>
<p>It is still tedious, however, to type all these underscores. When a function takes an argument that can generally be inferred from context,
Lean allows us to specify that this argument should, by default, be left implicit. This is done by putting the arguments in curly braces, as follows:</p>
<pre><code class="language-lean">def compose {α β γ : Type} (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
<span class="boring">def double (x : Nat) := 2*x
</span><span class="boring">def triple (x : Nat) := 3*x
</span>#check compose double triple 10 -- Nat
#eval  compose double triple 10 -- 60
<span class="boring">def appendWorld (s : String) := s ++ &quot;world&quot;
</span><span class="boring">#check String.length -- String → Nat
</span>#check compose String.length appendWorld &quot;hello&quot; -- Nat
#eval  compose String.length appendWorld &quot;hello&quot; -- 10
</code></pre>
<p>All that has changed are the braces around <code>α β γ: Type</code>.
It makes these three arguments implicit. Notationally, this hides the specification of the type,
making it look as though <code>compose</code> simply takes 3 arguments.</p>
<p>Variables can also be specified as implicit when they are declared with
the <code>variable</code> command:</p>
<pre><code class="language-lean">universe u

section
  variable {α : Type u}
  variable (x : α)
  def ident := x
end

variable (α β : Type u)
variable (a : α) (b : β)

#check ident
#check ident a
#check ident b
</code></pre>
<p>This definition of <code>ident</code> here has the same effect as the one above.</p>
<p>Lean has very complex mechanisms for instantiating implicit arguments, and we will see that they can be used to infer function types, predicates, and even proofs.
The process of instantiating these &quot;holes,&quot; or &quot;placeholders,&quot; in a term is part of a bigger process called <em>elaboration</em>.
The presence of implicit arguments means that at times there may be insufficient information to fix the meaning of an expression precisely.
An expression like <code>ident</code> is said to be <em>polymorphic</em>, because it can take on different meanings in different contexts.</p>
<p>One can always specify the type <code>T</code> of an expression <code>e</code> by writing <code>(e : T)</code>.
This instructs Lean's elaborator to use the value <code>T</code> as the type of <code>e</code> when trying to elaborate it.
In the following example, this mechanism is used to specify the desired types of the expressions <code>ident</code>.</p>
<pre><code class="language-lean">def ident {α : Type u} (a : α) : α := a

#check (ident : Nat → Nat) -- Nat → Nat
</code></pre>
<p>Numerals are overloaded in Lean, but when the type of a numeral cannot be inferred, Lean assumes, by default, that it is a natural number.
So the expressions in the first two <code>#check</code> commands below are elaborated in the same way, whereas the third <code>#check</code> command interprets <code>2</code> as an integer.</p>
<pre><code class="language-lean">#check 2         -- Nat
#check (2 : Nat) -- Nat
#check (2 : Int) -- Int
</code></pre>
<p>Sometimes, however, we may find ourselves in a situation where we have declared an argument to a function to be implicit,
but now want to provide the argument explicitly. If <code>foo</code> is such a function, the notation <code>@foo</code> denotes the same function with all
the arguments made explicit.</p>
<pre><code class="language-lean"><span class="boring">def ident {α : Type u} (a : α) : α := a
</span>variable (α β : Type)

#check @ident           -- {α : Type u} → α → α
#check @ident α         -- α → α
#check @ident β         -- β → β
#check @ident Nat       -- Nat → Nat
#check @ident Bool true -- Bool
</code></pre>
<p>Notice that now the first <code>#check</code> command gives the type of the identifier, <code>ident</code>, without inserting any placeholders.
Moreover, the output indicates that the first argument is implicit.</p>
<p>Named arguments enable you to specify an argument for a parameter by matching the argument with
its name rather than with its position in the parameter list. You can use them to specify explicit <em>and</em> implicit arguments.
If you don't remember the order of the parameters but know their names, you can send the arguments in any order.
You may also provide the value for an implicit parameter when
Lean failed to infer it. Named arguments also improve the readability of your code by identifying what
each argument represents.</p>
<pre><code class="language-lean"><span class="boring">def ident {α : Type u} (a : α) : α := a
</span>
#check ident (α := Nat)  -- Nat → Nat
#check ident (α := Bool) -- Bool → Bool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="auto-bound-implicit-arguments"><a class="header" href="#auto-bound-implicit-arguments">Auto Bound Implicit Arguments</a></h2>
<p>In the previous section, we have shown how implicit arguments make functions more convenient to use.
However, functions such as <code>compose</code> are still quite verbose to define. Note that the universe
polymorphic <code>compose</code> is even more verbose than the one previously defined.</p>
<pre><code class="language-lean">universe u v w
def compose {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>You can avoid the <code>universe</code> command by providing the universe parameters when defining <code>compose</code>.</p>
<pre><code class="language-lean">def compose.{u, v, w}
            {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>Lean 4 supports a new feature called <em>auto bound implicit arguments</em>. It makes functions such as
<code>compose</code> much more convenient to write. When Lean processes the header of a declaration,
any unbound identifier is automatically added as an implicit argument <em>if</em> it is a single lower case or
greek letter. With this feature, we can write <code>compose</code> as</p>
<pre><code class="language-lean">def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

#check @compose
-- {β : Sort u_1} → {γ : Sort u_2} → {α : Sort u_3} → (β → γ) → (α → β) → α → γ
</code></pre>
<p>Note that, Lean inferred a more general type using <code>Sort</code> instead of <code>Type</code>.</p>
<p>Although we love this feature and use it extensively when implementing Lean,
we realize some users may feel uncomfortable with it. Thus, you can disable it using
the command <code>set_option autoImplicit false</code>.</p>
<pre><code class="language-lean">set_option autoImplicit false
/- The following definition produces `unknown identifier` errors -/
-- def compose (g : β → γ) (f : α → β) (x : α) : γ :=
--   g (f x)
</code></pre>
<p>The Lean language server provides <a href="./semantic_highlighting.html">semantic highlighting</a> information to editors, and it provides
visual feedback whether an identifier has been interpreted as an auto bound implicit argument.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-extensions"><a class="header" href="#syntax-extensions">Syntax Extensions</a></h1>
<p>Lean's syntax can be extended and customized
by users at every level, ranging from <a href="./notation.html">basic &quot;mixfix&quot; notations</a>
over <a href="./macro_overview.html">macro transformers</a> to
<a href="./elaborators.html">type-aware elaborators</a>. In fact, all builtin syntax is parsed and
processed using the same mechanisms and APIs open to users. In this
section, we will describe and explain the various extension points.
Significant syntax extensions already builtin into Lean such as the
<a href="./do.html"><code>do</code> notation</a> are described in subsections.</p>
<p>While introducing new syntax is a relatively rare feature in
programming languages and sometimes even frowned upon because of its
potential to obscure code, it is an invaluable tool in formalization
for expressing established conventions and notations of the respective
field succinctly in code. Going beyond basic notations, Lean's ability
to factor out common boilerplate code into (well-behaved) macros and
to embed entire custom domain specific languages (DSLs) to textually
encode subproblems efficiently and readably can be of great benefit to
both programmers and proof engineers alike.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-do-notation"><a class="header" href="#the-do-notation">The <code>do</code> notation</a></h1>
<p>Lean is a pure functional programming language, but you can write effectful code using the <code>do</code> embedded domain specific language (DSL). The following simple program prints two strings &quot;hello&quot; and &quot;world&quot; in the standard output and terminates with exit code 0. Note that the type of the program is <code>IO UInt32</code>. You can read this type as the type of values that perform input-output effects and produce a value of type <code>UInt32</code>.</p>
<pre><code class="language-lean">def main : IO UInt32 := do
  IO.println &quot;hello&quot;
  IO.println &quot;world&quot;
  return 0
</code></pre>
<p>The type of <code>IO.println</code> is <code>String → IO Unit</code>. That is, it is a function from <code>String</code> to <code>IO Unit</code> which indicates it may perform input-output effects and produce a value of type <code>Unit</code>. We often say that functions that may perform effects are <em>methods</em>.
We also say a method application, such as <code>IO.println &quot;hello&quot;</code> is an <em>action</em>.
Note that the examples above also demonstrates that braceless <code>do</code> blocks are whitespace sensitive.
If you like <code>;</code>s and curly braces, you can write the example above as</p>
<pre><code class="language-lean">def main : IO UInt32 := do {
  IO.println &quot;hello&quot;;
  IO.println &quot;world&quot;;
  return 0;
}
</code></pre>
<p>Semicolons can be used even when curly braces are not used. They are particularly useful when you want to &quot;pack&quot; more than one action in a single line.</p>
<pre><code class="language-lean">def main : IO UInt32 := do
  IO.println &quot;hello&quot;; IO.println &quot;world&quot;
  return 0
</code></pre>
<p>Whitespace sensitivity in programming languages is a controversial topic
among programmers. You should use your own style. We, the Lean developers, <strong>love</strong> the
braceless and semicolon-free style.
We believe it is clean and beautiful.</p>
<p>The <code>do</code> DSL expands into the core Lean language. Let's inspect the different components using the commands <code>#print</code> and <code>#check</code>.</p>
<pre><code class="language-lean"><span class="boring">def main : IO UInt32 := do
</span><span class="boring"> IO.println &quot;hello&quot;
</span><span class="boring"> IO.println &quot;world&quot;
</span><span class="boring"> return 0
</span>
#check IO.println &quot;hello&quot;
-- IO Unit
#print main
-- Output contains the infix operator `&gt;&gt;=` and `pure`
-- The following `set_option` disables notation such as `&gt;&gt;=` in the output
set_option pp.notation false in
#print main
-- Output contains `bind` and `pure`
#print bind
-- bind : {m : Type u → Type v} → [self : Bind m] → {α β : Type u} →
--        m α → (α → m β) → m β
#print pure
-- pure : {m : Type u → Type v} → [self : Pure m] → {α : Type u} →
--        α → m α

-- IO implements the type classes `Bind` and `Pure`.
#check (inferInstance : Bind IO)
#check (inferInstance : Pure IO)
</code></pre>
<p>The types of <code>bind</code> and <code>pure</code> may look daunting at first sight.
They both have many implicit arguments. Let's focus first on the explicit arguments.
<code>bind</code> has two explicit arguments <code>m α</code> and <code>α → m β</code>. The first one should
be viewed as an action with effects <code>m</code> and producing a value of type <code>α</code>.
The second is a function that takes a value of type <code>α</code> and produces an action
with effects <code>m</code> and a value of type <code>β</code>. The result is <code>m β</code>. The method <code>bind</code> is composing
these two actions. We often say <code>bind</code> is an abstract semicolon. The method <code>pure</code> converts
a value <code>α</code> into an action that produces an action <code>m α</code>.</p>
<p>Here is the same function being defined using <code>bind</code> and <code>pure</code> without the <code>do</code> DSL.</p>
<pre><code class="language-lean">def main : IO UInt32 :=
  bind (IO.println &quot;hello&quot;) fun _ =&gt;
  bind (IO.println &quot;world&quot;) fun _ =&gt;
  pure 0
</code></pre>
<p>The notations <code>let x &lt;- action1; action2</code> and <code>let x ← action1; action2</code> are just syntax sugar for <code>bind action1 fun x =&gt; action2</code>.
Here is a small example using it.</p>
<pre><code class="language-lean">def isGreaterThan0 (x : Nat) : IO Bool := do
  IO.println s!&quot;value: {x}&quot;
  return x &gt; 0

def f (x : Nat) : IO Unit := do
  let c &lt;- isGreaterThan0 x
  if c then
    IO.println s!&quot;{x} is greater than 0&quot;
  else
    pure ()

#eval f 10
-- value: 10
-- 10 is greater than 0
</code></pre>
<h2 id="nested-actions"><a class="header" href="#nested-actions">Nested actions</a></h2>
<p>Note that we cannot write <code>if isGreaterThan0 x then ... else ...</code> because the condition in a <code>if-then-else</code> is a <strong>pure</strong> value without effects, but <code>isGreaterThan0 x</code> has type <code>IO Bool</code>. You can use the nested action notation to avoid this annoyance. Here is an equivalent definition for <code>f</code> using a nested action.</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f (x : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) then
    IO.println s!&quot;{x} is greater than 0&quot;
  else
    pure ()

#print f
</code></pre>
<p>Lean &quot;lifts&quot; the nested actions and introduces the <code>bind</code> for us.
Here is an example with two nested actions. Note that both actions are executed
even if <code>x = 0</code>.</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) &amp;&amp; (&lt;- isGreaterThan0 y) then
    IO.println s!&quot;{x} and {y} are greater than 0&quot;
  else
    pure ()

#eval f 0 10
-- value: 0
-- value: 10

-- The function `f` above is equivalent to
def g (x y : Nat) : IO Unit := do
  let c1 &lt;- isGreaterThan0 x
  let c2 &lt;- isGreaterThan0 y
  if c1 &amp;&amp; c2 then
    IO.println s!&quot;{x} and {y} are greater than 0&quot;
  else
    pure ()

theorem fgEqual : f = g :=
  rfl -- proof by reflexivity
</code></pre>
<p>Here are two ways to achieve the short-circuit semantics in the example above</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f1 (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x &lt;&amp;&amp;&gt; isGreaterThan0 y) then
    IO.println s!&quot;{x} and {y} are greater than 0&quot;
  else
    pure ()

-- `&lt;&amp;&amp;&gt;` is the effectful version of `&amp;&amp;`
-- Given `x y : IO Bool`, `x &lt;&amp;&amp;&gt; y` : m Bool`
-- It only executes `y` if `x` returns `true`.

#eval f1 0 10
-- value: 0
#eval f1 1 10
-- value: 1
-- value: 10
-- 1 and 10 are greater than 0

def f2 (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) then
    if (&lt;- isGreaterThan0 y) then
      IO.println s!&quot;{x} and {y} are greater than 0&quot;
    else
      pure ()
  else
    pure ()
</code></pre>
<h2 id="if-then-notation"><a class="header" href="#if-then-notation"><code>if-then</code> notation</a></h2>
<p>In the <code>do</code> DSL, we can write <code>if c then action</code> as a shorthand for <code>if c then action else pure ()</code>. Here is the method <code>f2</code> using this shorthand.</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f2 (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) then
    if (&lt;- isGreaterThan0 y) then
      IO.println s!&quot;{x} and {y} are greater than 0&quot;
</code></pre>
<h2 id="reassignments"><a class="header" href="#reassignments">Reassignments</a></h2>
<p>When writing effectful code, it is natural to think imperatively.
For example, suppose we want to create an empty array <code>xs</code>,
add <code>0</code> if some condition holds, add <code>1</code> if another condition holds,
and then print it. In the following example, we use variable
&quot;shadowing&quot; to simulate this kind of &quot;update&quot;.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let xs := #[]
  let xs := if b1 then xs.push 0 else xs
  let xs := if b2 then xs.push 1 else xs
  IO.println xs

#eval f true true
-- #[0, 1]
#eval f false true
-- #[1]
#eval f true false
-- #[0]
#eval f false false
-- #[]
</code></pre>
<p>We can use tuples to simulate updates on multiple variables.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let xs := #[]
  let ys := #[]
  let (xs, ys) := if b1 then (xs.push 0, ys) else (xs, ys.push 0)
  let (xs, ys) := if b2 then (xs.push 1, ys) else (xs, ys.push 1)
  IO.println s!&quot;xs: {xs}, ys: {ys}&quot;

#eval f true false
-- xs: #[0], ys: #[1]
</code></pre>
<p>We can also simulate the control-flow above using <em>join-points</em>.
A join-point is a <code>let</code> that is always tail called and fully applied.
The Lean compiler implements them using <code>goto</code>s.
Here is the same example using join-points.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let jp1 xs ys := IO.println s!&quot;xs: {xs}, ys: {ys}&quot;
  let jp2 xs ys := if b2 then jp1 (xs.push 1) ys else jp1 xs (ys.push 1)
  let xs := #[]
  let ys := #[]
  if b1 then jp2 (xs.push 0) ys else jp2 xs (ys.push 0)

#eval f true false
-- xs: #[0], ys: #[1]
</code></pre>
<p>You can capture complex control-flow using join-points.
The <code>do</code> DSL offers the variable reassignment feature to make this kind of code more comfortable to write. In the following example, the <code>mut</code> modifier at <code>let mut xs := #[]</code> indicates that variable <code>xs</code> can be reassigned. The example contains two reassignments <code>xs := xs.push 0</code> and <code>xs := xs.push 1</code>. The reassignments are compiled using join-points. There is no hidden state being updated.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let mut xs := #[]
  if b1 then xs := xs.push 0
  if b2 then xs := xs.push 1
  IO.println xs

#eval f true true
-- #[0, 1]
</code></pre>
<p>The notation <code>x &lt;- action</code> reassigns <code>x</code> with the value produced by the action. It is equivalent to <code>x := (&lt;- action)</code></p>
<h2 id="iteration"><a class="header" href="#iteration">Iteration</a></h2>
<p>The <code>do</code> DSL provides a unified notation for iterating over datastructures. Here are a few examples.</p>
<pre><code class="language-lean">def sum (xs : Array Nat) : IO Nat := do
  let mut s := 0
  for x in xs do
    IO.println s!&quot;x: {x}&quot;
    s := s + x
  return s

#eval sum #[1, 2, 3]
-- x: 1
-- x: 2
-- x: 3
-- 6

-- We can write pure code using the `Id.run &lt;| do` DSL too.
def sum' (xs : Array Nat) : Nat := Id.run &lt;| do
  let mut s := 0
  for x in xs do
    s := s + x
  return s

#eval sum' #[1, 2, 3]
-- 6

def sumEven (xs : Array Nat) : IO Nat := do
  let mut s := 0
  for x in xs do
    if x % 2 == 0 then
      IO.println s!&quot;x: {x}&quot;
      s := s + x
  return s

#eval sumEven #[1, 2, 3, 6]
-- x: 2
-- x: 6
-- 8

def splitEvenOdd (xs : List Nat) : IO Unit := do
  let mut evens := #[]
  let mut odds  := #[]
  for x in xs do
    if x % 2 == 0 then
      evens := evens.push x
    else
      odds := odds.push x
  IO.println s!&quot;evens: {evens}, odds: {odds}&quot;

#eval splitEvenOdd [1, 2, 3, 4]
-- evens: #[2, 4], odds: #[1, 3]

def findNatLessThan (x : Nat) (p : Nat → Bool) : IO Nat := do
  -- [:x] is notation for the range [0, x)
  for i in [:x] do
    if p i then
      return i -- `return` from the `do` block
  throw (IO.userError &quot;value not found&quot;)

#eval findNatLessThan 10 (fun x =&gt; x &gt; 5 &amp;&amp; x % 4 == 0)
-- 8

def sumOddUpTo (xs : List Nat) (threshold : Nat) : IO Nat := do
  let mut s := 0
  for x in xs do
    if x % 2 == 0 then
      continue -- it behaves like the `continue` statement in imperative languages
    IO.println s!&quot;x: {x}&quot;
    s := s + x
    if s &gt; threshold then
      break -- it behaves like the `break` statement in imperative languages
  IO.println s!&quot;result: {s}&quot;
  return s

#eval sumOddUpTo [2, 3, 4, 11, 20, 31, 41, 51, 107] 40
-- x: 3
-- x: 11
-- x: 31
-- result: 45
-- 45
</code></pre>
<p>TODO: describe <code>forIn</code></p>
<h2 id="try-catch"><a class="header" href="#try-catch">Try-catch</a></h2>
<p>TODO</p>
<h2 id="returning-early-from-a-failed-match"><a class="header" href="#returning-early-from-a-failed-match">Returning early from a failed match</a></h2>
<p>Inside a <code>do</code> block, the pattern <code>let _ ← &lt;success&gt; | &lt;fail&gt;</code> will continue with the rest of the block if the match on the left hand side succeeds, but will execute the right hand side and exit the block on failure:</p>
<pre><code class="language-lean">def showUserInfo (getUsername getFavoriteColor : IO (Option String)) : IO Unit := do
  let some n ← getUsername | IO.println &quot;no username!&quot;
  IO.println s!&quot;username: {n}&quot;
  let some c ← getFavoriteColor | IO.println &quot;user didn't provide a favorite color!&quot;
  IO.println s!&quot;favorite color: {c}&quot;

-- username: JohnDoe
-- favorite color: red
#eval showUserInfo (pure &lt;| some &quot;JohnDoe&quot;) (pure &lt;| some &quot;red&quot;)

-- no username
#eval showUserInfo (pure none) (pure &lt;| some &quot;purple&quot;)

-- username: JaneDoe
-- user didn't provide a favorite color
#eval showUserInfo (pure &lt;| some &quot;JaneDoe&quot;) (pure none)
</code></pre>
<h2 id="if-let"><a class="header" href="#if-let">If-let</a></h2>
<p>Inside a <code>do</code> block, users can employ the <code>if let</code> pattern to destructure actions:</p>
<pre><code class="language-lean">def tryIncrement (getInput : IO (Option Nat)) : IO (Except String Nat) := do
  if let some n ← getInput
  then return Except.ok n.succ
  else return Except.error &quot;argument was `none`&quot;

-- Except.ok 2
#eval tryIncrement (pure &lt;| some 1)

-- Except.error &quot;argument was `none`&quot;
#eval tryIncrement (pure &lt;| none)
</code></pre>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h2>
<p>TODO</p>
<h2 id="monads"><a class="header" href="#monads">Monads</a></h2>
<p>TODO</p>
<h2 id="readert"><a class="header" href="#readert">ReaderT</a></h2>
<p>TODO</p>
<h2 id="statet"><a class="header" href="#statet">StateT</a></h2>
<p>TODO</p>
<h2 id="statereft"><a class="header" href="#statereft">StateRefT</a></h2>
<p>TODO</p>
<h2 id="exceptt"><a class="header" href="#exceptt">ExceptT</a></h2>
<p>TODO</p>
<h2 id="monadlift-and-automatic-lifting"><a class="header" href="#monadlift-and-automatic-lifting">MonadLift and automatic lifting</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-interpolation"><a class="header" href="#string-interpolation">String interpolation</a></h1>
<p>The <code>s!</code> prefix identifies a string literal as an interpolated string.
An interpolated string is a string literal that might contain interpolation expressions.
When an interpolated string is resolved to a result string, items with interpolation expressions are
replaced by the string representations of the expression results. The polymorphic method <code>toString</code> is used
to convert the value into a string.</p>
<p>String interpolation provides a more readable and convenient syntax to create formatted strings than
a string composite formatting feature. The following example uses both features to produce the same output:</p>
<pre><code class="language-lean">def name := &quot;John&quot;
def age  := 28

#eval IO.println s!&quot;Hello, {name}! Are you {age} years old?&quot;

#eval IO.println (&quot;Hello, &quot; ++ name ++ &quot;! Are you &quot; ++ toString age ++ &quot; years old?&quot;)

-- `println! &lt;interpolated-string&gt;` is a macro for `IO.println s!&lt;interpolated-string&gt;`
#eval println! &quot;Hello, {name}! Are you {age} years old?&quot;
</code></pre>
<h1 id="structure-of-an-interpolated-string"><a class="header" href="#structure-of-an-interpolated-string">Structure of an interpolated string</a></h1>
<p>To identify a string literal as an interpolated string, prepend it with <code>s!</code>.
Terms inside braces <code>{}</code> are ordinary expressions whose type implements the type class <code>ToString</code>.
To include a curly brace <code>{</code> in your interpolated string, you must escape it using <code>\{</code>.
You can nest interpolated strings inside interpolated strings.</p>
<pre><code class="language-lean">def vals := [1, 2, 3]

#eval IO.println s!&quot;\{ vals := {vals} }&quot;

#eval IO.println s!&quot;variables: {vals.map (fun i =&gt; s!&quot;x_{i}&quot;)}&quot;
</code></pre>
<h1 id="tostring-instances"><a class="header" href="#tostring-instances"><code>ToString</code> instances</a></h1>
<p>You can define a <code>ToString</code> instance for your own datatypes.</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString : Person -&gt; String
    | { name := n, age := v } =&gt; s!&quot;\{ name := {n}, age := {v} }&quot;

def person1 : Person := {
  name := &quot;John&quot;
  age  := 28
}

#eval println! &quot;person1: {person1}&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notations-and-precedence"><a class="header" href="#notations-and-precedence">Notations and Precedence</a></h1>
<p>The most basic syntax extension commands allow introducing new (or
overloading existing) prefix, infix, and postfix operators.</p>
<pre><code class="language-lean">infixl:65   &quot; + &quot; =&gt; HAdd.hAdd  -- left-associative
infix:50    &quot; = &quot; =&gt; Eq         -- non-associative
infixr:80   &quot; ^ &quot; =&gt; HPow.hPow  -- right-associative
prefix:75  &quot;-&quot;   =&gt; Neg.neg
<span class="boring">set_option quotPrecheck false
</span>postfix:max &quot;⁻¹&quot;  =&gt; Inv.inv
</code></pre>
<p>After the initial command name describing the operator kind (its
&quot;fixity&quot;), we give the <em>parsing precedence</em> of the operator preceded
by a colon <code>:</code>, then a new or existing token surrounded by double
quotes (the whitespace is used for pretty printing), then the function
this operator should be translated to after the arrow <code>=&gt;</code>.</p>
<p>The precedence is a natural number describing how &quot;tightly&quot; an
operator binds to its arguments, encoding the order of operations. We
can make this more precise by looking at what the commands above unfold to:</p>
<pre><code class="language-lean">notation:65 lhs:65 &quot; + &quot; rhs:66 =&gt; HAdd.hAdd lhs rhs
notation:50 lhs:51 &quot; = &quot; rhs:51 =&gt; Eq lhs rhs
notation:80 lhs:81 &quot; ^ &quot; rhs:80 =&gt; HPow.hPow lhs rhs
notation:75 &quot;-&quot; arg:75 =&gt; Neg.neg arg
<span class="boring">set_option quotPrecheck false
</span>notation:1024 arg:1024 &quot;⁻¹&quot; =&gt; Inv.inv arg  -- `max` is a shorthand for precedence 1024
</code></pre>
<p>It turns out that all commands from the first code block are in fact
command <em>macros</em> translating to the more general <code>notation</code> command.
We will learn about writing such macros below. Instead of a single
token, the <code>notation</code> command accepts a mixed sequence of tokens and
named term placeholders with precedences, which can be referenced on
the right-hand side of <code>=&gt;</code> and will be replaced by the respective
term parsed at that position. A placeholder with precedence <code>p</code>
accepts only notations with precedence at least <code>p</code> in that place.
Thus the string <code>a + b + c</code> cannot be parsed as the equivalent of <code>a + (b + c)</code> because the right-hand side operand of an <code>infixl</code> notation
has precedence one greater than the notation itself. In contrast,
<code>infixr</code> reuses the notation's precedence for the right-hand side
operand, so <code>a ^ b ^ c</code> <em>can</em> be parsed as <code>a ^ (b ^ c)</code>. Note that if
we used <code>notation</code> directly to introduce an infix notation like</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:65 lhs:65 &quot; ~ &quot; rhs:65 =&gt; wobble lhs rhs
</code></pre>
<p>where the precedences do not sufficiently determine associativity,
Lean's parser will default to right associativity. More precisely,
Lean's parser follows a local <em>longest parse</em> rule in the presence of
ambiguous grammars: when parsing the right-hand side of <code>a ~</code> in <code>a ~ b ~ c</code>, it will continue parsing as long as possible (as the current
precedence allows), not stopping after <code>b</code> but parsing <code>~ c</code> as well.
Thus the term is equivalent to <code>a ~ (b ~ c)</code>.</p>
<p>As mentioned above, the <code>notation</code> command allows us to define
arbitrary <em>mixfix</em> syntax freely mixing tokens and placeholders.</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:max &quot;(&quot; e &quot;)&quot; =&gt; e
notation:10 Γ &quot; ⊢ &quot; e &quot; : &quot; τ =&gt; Typing Γ e τ
</code></pre>
<p>Placeholders without precedence default to <code>0</code>, i.e. they accept
notations of any precedence in their place. If two notations overlap,
we again apply the longest parse rule:</p>
<pre><code class="language-lean">notation:65 a &quot; + &quot; b:66 &quot; + &quot; c:66 =&gt; a + b - c
#eval 1 + 2 + 3  -- 0
</code></pre>
<p>The new notation is preferred to the binary notation since the latter,
before chaining, would stop parsing after <code>1 + 2</code>. If there are
multiple notations accepting the same longest parse, the choice will
be delayed until elaboration, which will fail unless exactly one
overload is type correct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro-overview"><a class="header" href="#macro-overview">Macro Overview</a></h1>
<p>The official paper describing the mechanics behind Lean 4's macro system can be
found in <a href="https://arxiv.org/abs/2001.10490">Beyond Notations: Hygienic Macro Expansion for Theorem Proving
Languages</a> by Sebastian Ullrich and Leonardo
de Moura, and the accompanying repo with example code can be found in the
paper's code <a href="https://github.com/Kha/macro-supplement">supplement</a>. The
supplement also includes a working implementation of the macro expander, so it's
a good case study for people interested in the details.</p>
<h2 id="what-is-a-macro-in-lean"><a class="header" href="#what-is-a-macro-in-lean">What is a macro in Lean?</a></h2>
<p>A macro is a function that takes in a syntax tree and produces a new syntax
tree. Macros are useful for many reasons, but two of the big ones are a)
allowing users to extend the language with new syntactic constructs without
having to actually expand the core language, and b) allowing users to automate
tasks that would otherwise be extremely repetitive, time-consuming, and/or
error-prone.</p>
<p>A motivating example is set builder notation. We would like to be able to write
the set of natural numbers 0, 1, and 2 as just <code>{0, 1, 2}</code>. However, Lean does
not natively support this syntax, and the actual definition of a set in Mathlib
does not let us just declare sets in this manner; naively using the set API
would force us to write <code>Set.insert 1 (Set.insert 2 (Set.singleton 3))</code>.
Instead, we can teach Lean's macro system to recognize <code>{0, 1, 2}</code> as a
shorthand for a composition of existing methods and let it do the repetitive
work of creating the <code>Set.insert...</code> invocation for us. In this way, we can have
our more readable and more convenient syntax without having to extend Lean
itself, and while retaining the simple insert/singleton API.</p>
<h2 id="how-macros-are-handled"><a class="header" href="#how-macros-are-handled">How macros are handled</a></h2>
<p>The general procedure is as follows:</p>
<ol>
<li>
<p>Lean parses a command, creating a Lean syntax tree which contains any
unexpanded macros.</p>
</li>
<li>
<p>Lean repeats the cycle (elaboration ~&gt; (macro hygiene and expansion) ~&gt;
elaboration...)</p>
</li>
</ol>
<p>The cycle in step 2 repeats until there are no more macros which need to be
expanded, and elaboration can finish normally. This repetition is required since
macros can expand to other macros, and may expand to code that needs information
from the elaborator. As you can see, the process of macro parsing and expansion
is interleaved with the parsing and elaboration of non-macro code.</p>
<p>By default, macros in Lean are hygienic, which means the system avoids
accidental name capture when reusing the same name inside and outside the macro.
Users may occasionally want to disable hygiene, which can be accomplished with
the command <code>set_option hygiene false</code>. More in-depth information about hygiene
and how it's implemented in the official paper and supplement linked at the top
of this guide.</p>
<h2 id="elements-of-a-macro-important-types"><a class="header" href="#elements-of-a-macro-important-types">Elements of &quot;a&quot; macro (important types)</a></h2>
<p>In the big picture, a macro has two components that must be implemented by the
user, parsers and syntax transformers, where the latter is a function that says
what the input syntax should expand to. There is a third component, syntax
categories, such as <code>term</code>, <code>tactic</code>, and <code>command</code>, but declaring a new syntax
category is not always necessary. When we say &quot;parser&quot; in the context of a
macro, we refer to the core type <code>Lean.ParserDescr</code>, which parses elements of
type <code>Lean.Syntax</code>, where <code>Lean.Syntax</code> represents elements of a Lean syntax
tree. Syntax transformers are functions of type <code>Syntax -&gt; MacroM Syntax</code>. Lean
has a synonym for this type, which is simply <code>Macro</code>. <code>MacroM</code> is a monad that
carries state needed for macro expansion to work nicely, including the info
needed to implement hygiene.</p>
<p>As an example, we again refer to Mathlib's set builder notation:</p>
<pre><code class="language-lean">/- Declares a parser -/
syntax (priority := high) &quot;{&quot; term,+ &quot;}&quot; : term

/- Declares two expansions/syntax transformers -/
macro_rules
  | `({$x}) =&gt; `(Set.singleton $x)
  | `({$x, $xs:term,*}) =&gt; `(Set.insert $x {$xs,*})

/- Provided `Set` has been imported (from Mathlib4), these are all we need for `{1, 2, 3}` to be valid notation to create a literal set -/

</code></pre>
<p>This example should also make clear the reason why macros (and pretty much all
of Lean 4's metaprogramming facilities) are functions that take an argument of
type <code>Syntax</code> e.g. <code>Syntax -&gt; MacroM Syntax</code>; the leading syntax element is the
thing that actually triggers the macro expansion by matching with the declared
parser, and as a user, you will almost always be interested in inspecting and
transforming that initial syntax element (though there are cases in which it can
just be ignored, as in the parameter-less exfalso tactic).</p>
<p>Returning briefly to the API provided by Lean, <code>Lean.Syntax</code>, is pretty much
what you would expect a basic syntax tree type to look like. Below is a slightly
simplified representation which omits details in the <code>atom</code> and <code>ident</code>
constructors; users can create atoms and idents which comport with this
simplified representation using the <code>mkAtom</code> and <code>mkIdent</code> methods provided in
the <code>Lean</code> namespace.</p>
<pre><code class="language-lean"><span class="boring">open Lean
</span>inductive Syntax where
  | missing : Syntax
  | node (kind : SyntaxNodeKind) (args : Array Syntax) : Syntax
  | atom : String -&gt; Syntax
  | ident : Name -&gt; Syntax
</code></pre>
<p>For those interested, <code>MacroM</code> is a <code>ReaderT</code>:</p>
<pre><code class="language-lean"><span class="boring">open Lean
</span>abbrev MacroM := ReaderT Macro.Context (EStateM Macro.Exception Macro.State)
</code></pre>
<p>The other relevant components are defined as follows:</p>
<pre><code class="language-lean"><span class="boring">open Lean
</span>structure Context where
  methods        : MethodsRef
  mainModule     : Name
  currMacroScope : MacroScope
  currRecDepth   : Nat := 0
  maxRecDepth    : Nat := defaultMaxRecDepth
  ref            : Syntax

inductive Exception where
  | error             : Syntax → String → Exception
  | unsupportedSyntax : Exception

structure State where
  macroScope : MacroScope
  traceMsgs  : List (Prod Name String) := List.nil
  deriving Inhabited
</code></pre>
<p>As a review/checklist, the three (sometimes only two depending on whether you
need a new syntax category) components users need to be concerned with are:</p>
<ol start="0">
<li>You may or may not need to declare a new syntax category using
<code>declare_syntax_cat</code></li>
<li>Declare a parser with either <code>syntax</code> or <code>macro</code></li>
<li>Declare an expansion/syntax transformer with either <code>macro_rules</code> or <code>macro</code></li>
</ol>
<p>Parsers and syntax transformers can be declared manually, but use of the pattern
language and <code>syntax</code>, <code>macro_rules</code>, and <code>macro</code> is recommended.</p>
<h2 id="syntax-categories-with-declare_syntax_cat"><a class="header" href="#syntax-categories-with-declare_syntax_cat">syntax categories with declare_syntax_cat</a></h2>
<p><code>declare_syntax_cat</code> declares a new syntax category, like <code>command</code>, <code>tactic</code>,
or mathlib4's <code>binderterm</code>. These are the different categories of things that
can be referred to in a quote/antiquote. <code>declare_syntax_cat</code> results in a call
to <code>registerParserCategory</code> and produces a new parser descriptor:</p>
<pre><code class="language-lean">set_option trace.Elab.definition true in
declare_syntax_cat binderterm

/-
Output:

[Elab.definition.body] binderterm.quot : Lean.ParserDescr :=
Lean.ParserDescr.node `Lean.Parser.Term.quot 1024
  (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.symbol &quot;`(binderterm|&quot;)
    (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.cat `binderterm 0)
      (Lean.ParserDescr.symbol &quot;)&quot;)))
-/
</code></pre>
<p>Declaring a new syntax category like this one automatically declares a quotation
operator <code> `(binderterm| ...)</code>. These pipe prefixes <code>&lt;thing&gt;|</code> are used in
syntax quotations to say what category a given quotation is expected to be an
element of. The pipe prefixes are <em>not</em> used for elements in the <code>term</code> and
<code>command</code> categories (since they're considered the default), but need to be used
for everything else.</p>
<h2 id="parsers-and-the-syntax-keyword"><a class="header" href="#parsers-and-the-syntax-keyword">Parsers and the <code>syntax</code> keyword</a></h2>
<p>Internally, elements of type <code>Lean.ParserDescr</code> are implemented as parser
combinators. However, Lean offers the ability to write parsers using the
macro/pattern language by way of the <code>syntax</code> keyword. This is the recommended
means of writing parsers. As an example, the parser for the <code>rwa</code> (rewrite, then
use assumption) tactic is:</p>
<pre><code class="language-lean"><span class="boring">open Lean.Parser.Tactic
</span>set_option trace.Elab.definition true in
syntax &quot;rwa &quot; rwRuleSeq (location)? : tactic

/-
which expands to:
[Elab.definition.body] tacticRwa__ : Lean.ParserDescr :=
Lean.ParserDescr.node `tacticRwa__ 1022
  (Lean.ParserDescr.binary `andthen
    (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.nonReservedSymbol &quot;rwa &quot; false) Lean.Parser.Tactic.rwRuleSeq)
    (Lean.ParserDescr.unary `optional Lean.Parser.Tactic.location))

-/

</code></pre>
<p>Literals are written as double-quoted strings (<code>&quot;rwa &quot;</code> expects the literal
sequence of characters <code>rwa</code>, while the trailing space provides a hint to the
formatter that it should add a space after <code>rwa</code> when pretty printing this
syntax); <code>rwRuleSeq</code> and <code>location</code> are themselves <code>ParserDescr</code>s, and we finish
with <code>: tactic</code> specifying that the preceding parser is for an element in the
<code>tactic</code> syntax category. The parentheses around <code>(location)?</code> are necessary
(rather than <code>location?</code>) because Lean 4 allows question marks to be used in
identifiers, so <code>location?</code> is one single identifier that ends with a question
mark, which is not what we want.</p>
<p>The name <code>tacticRwa__</code> is automatically generated. You can name parser
descriptors declared with the <code>syntax</code> keyword like so:</p>
<pre><code class="language-lean">set_option trace.Elab.definition true in
syntax (name := introv) &quot;introv &quot; (colGt ident)* : tactic

/-
[Elab.definition.body] introv : Lean.ParserDescr :=
Lean.ParserDescr.node `introv 1022
  (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.nonReservedSymbol &quot;introv &quot; false)
    (Lean.ParserDescr.unary `many
      (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.const `colGt) (Lean.ParserDescr.const `ident))))
-/
</code></pre>
<h2 id="the-pattern-language"><a class="header" href="#the-pattern-language">The pattern language</a></h2>
<p>Available quantifiers are <code>?</code> (one or zero occurrences, see note below), <code>*</code>
(zero or more occurrences), and <code>+</code> (one or more occurrences).</p>
<p>Keep in mind that Lean makes <code>?</code> available for use in identifiers, so if we want
a parser to look for an optional <code>location</code>, we would need to write
<code>(location)?</code> with parenthesis acting as a separator, since <code>location?</code> would
look for something under the identifier <code>location?</code> (where the <code>?</code> is part of
the identifier).</p>
<p>Parentheses can be used as delimiters.</p>
<p>Separated lists can be constructed like so: <code>$ts,*</code> for a comma separated list.</p>
<p>&quot;extended splices&quot; can be constructed as <code>$[..]</code>. See the official paper (p. 12)
for more details.</p>
<p>Literals are written as double-quoted strings. A literal may use trailing
whitespace (see e.g. the <code>rwa</code> or <code>introv</code> tactics) to tell the pretty-printer
how it should be displayed, but such whitespace will not prevent a literal with
no trailing whitespace from matching. The spaces are relevant, but not
interpreted literally. When the ParserDescr is turned into a Parser, the actual
token matcher <a href="https://github.com/leanprover/lean4/blob/53ec43ff9b8f55989b12c271e368287b7b997b54/src/Lean/Parser/Basic.lean#L1193">uses the .trim of the provided
string</a>,
but the generated formatter <a href="https://github.com/leanprover/lean4/blob/8d370f151f7c88a687152a5b161dcb484c446ce2/src/Lean/PrettyPrinter/Formatter.lean#L328">uses the spaces as
specified</a>,
that is, turning the atom &quot;rwa&quot; in the syntax into the string rwa as part of the
pretty printed output.</p>
<h2 id="syntax-expansions-with-macro_rules-and-how-it-desugars"><a class="header" href="#syntax-expansions-with-macro_rules-and-how-it-desugars">Syntax expansions with <code>macro_rules</code>, and how it desugars.</a></h2>
<p><code>macro_rules</code> lets you declare expansions for a given <code>Syntax</code> element using a
syntax similar to a <code>match</code> statement. The left-hand side of a match arm is a
quotation (with a leading <code>&lt;cat&gt;|</code> for categories other than <code>term</code> and
<code>command</code>) in which users can specify the pattern they'd like to write an
expansion for. The right-hand side returns a syntax quotation which is the
output the user wants to expand to.</p>
<p>A feature of Lean's macro system is that if there are multiple expansions for a
particular match, Lean will try the most recently declared expansion first, and
will retry with other matching expansions if the previous attempt failed. This
is particularly useful for extending existing tactics.</p>
<p>The following example shows both the retry behavior, and the fact that macros
declared using the shorthand <code>macro</code> syntax can still have additional expansions
declared with <code>macro_rules</code>. This <code>transitivity</code> tactic is implemented such that
it will work for either Nat.le or Nat.lt. The Nat.lt version was declared &quot;most
recently&quot;, so it will be tried first, but if it fails (for example, if the
actual term in question is Nat.le) the next potential expansion will be tried:</p>
<pre><code class="language-lean">macro &quot;transitivity&quot; e:(colGt term) : tactic =&gt; `(tactic| apply Nat.le_trans (m := $e))
macro_rules
  | `(tactic| transitivity $e) =&gt; `(tactic| apply Nat.lt_trans (m := $e))

example (a b c : Nat) (h0 : a &lt; b) (h1 : b &lt; c) : a &lt; c := by
  transitivity b &lt;;&gt;
  assumption

example (a b c : Nat) (h0 : a &lt;= b) (h1 : b &lt;= c) : a &lt;= c := by
  transitivity b &lt;;&gt;
  assumption

/- This will fail, but is interesting in that it exposes the &quot;most-recent first&quot; behavior, since the
  error message complains about being unable to unify mvar1 &lt;= mvar2, rather than mvar1 &lt; mvar2. -/
/-
example (a b c : Nat) (h0 : a &lt;= b) (h1 : b &lt;= c) : False := by
  transitivity b &lt;;&gt;
  assumption
-/
</code></pre>
<p>To see the desugared definition of the actual expansion, we can again use
<code>set_option trace.Elab.definition true in</code> and observe the output of the humble
<code>exfalso</code> tactic defined in Mathlib4:</p>
<pre><code class="language-lean">
set_option trace.Elab.definition true in
macro &quot;exfalso&quot; : tactic =&gt; `(tactic| apply False.elim)

/-
Results in the expansion:

[Elab.definition.body] _aux___macroRules_tacticExfalso_1 : Lean.Macro :=
fun x =&gt;
  let discr := x;
  /- This is where Lean tries to actually identify that it's an invocation of the exfalso tactic -/
  if Lean.Syntax.isOfKind discr `tacticExfalso = true then
    let discr := Lean.Syntax.getArg discr 0;
    let x := discr;
    do
      /- Lean getting scope/meta info from the macro monad -/
      let info ← Lean.MonadRef.mkInfoFromRefPos
      let scp ← Lean.getCurrMacroScope
      let mainModule ← Lean.getMainModule
      pure
          (Lean.Syntax.node Lean.SourceInfo.none `Lean.Parser.Tactic.seq1
            #[Lean.Syntax.node Lean.SourceInfo.none `null
                #[Lean.Syntax.node Lean.SourceInfo.none `Lean.Parser.Tactic.apply
                    #[Lean.Syntax.atom info &quot;apply&quot;,
                      Lean.Syntax.ident info (String.toSubstring &quot;False.elim&quot;)
                        (Lean.addMacroScope mainModule `False.elim scp) [(`False.elim, [])]]]])
  else
    /- If this wasn't actually an invocation of the exfalso tactic, throw the &quot;unsupportedSyntax&quot; error -/
    let discr := x;
    throw Lean.Macro.Exception.unsupportedSyntax
-/
</code></pre>
<p>We can also create the syntax transformer declaration ourselves instead of using
<code>macro_rules</code>. We'll need to name our parser and use the attribute <code>@[macro myExFalsoParser]</code> to associate our declaration with the parser:</p>
<pre><code class="language-lean"><span class="boring">open Lean
</span>syntax (name := myExfalsoParser) &quot;myExfalso&quot; : tactic

-- remember that `Macro` is a synonym for `Syntax -&gt; TacticM Unit`
@[macro myExfalsoParser] def implMyExfalso : Macro :=
fun stx =&gt; `(tactic| apply False.elim)

example (p : Prop) (h : p) (f : p -&gt; False) : 3 = 2 := by
  myExfalso
  exact f h
</code></pre>
<p>In the above example, we're still using the sugar Lean provides for creating
quotations, as it feels more intuitive and saves us some work. It is possible to
forego the sugar altogether:</p>
<pre><code class="language-lean">syntax (name := myExfalsoParser) &quot;myExfalso&quot; : tactic

@[macro myExfalsoParser] def implMyExfalso : Lean.Macro :=
  fun stx =&gt; pure (Lean.mkNode `Lean.Parser.Tactic.apply
    #[Lean.mkAtomFrom stx &quot;apply&quot;, Lean.mkCIdentFrom stx ``False.elim])

example (p : Prop) (h : p) (f : p -&gt; False) : 3 = 2 := by
  myExfalso
  exact f h
</code></pre>
<h2 id="the-macro-keyword"><a class="header" href="#the-macro-keyword">The <code>macro</code> keyword</a></h2>
<p><code>macro</code> is a shortcut which allows users to declare both a parser and an
expansion at the same time as a matter of convenience. Additional expansions for
the parser generated by the <code>macro</code> invocation can be added with a separate
<code>macro_rules</code> block (see the example in the <code>macro_rules</code> section).</p>
<h2 id="unexpanders"><a class="header" href="#unexpanders">Unexpanders</a></h2>
<p>TODO; for now, see the unexpander in Mathlib.Set for an example.</p>
<h2 id="more-illustrative-examples"><a class="header" href="#more-illustrative-examples">More illustrative examples:</a></h2>
<p>The
<a href="https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/Basic.lean">Tactic.Basic</a>
file in Mathlib4 contains many good examples to learn from.</p>
<h2 id="practical-tips"><a class="header" href="#practical-tips">Practical tips:</a></h2>
<p>You can observe the output of commands and functions that in some way use the
macro system by setting this option to true : <code>set_option trace.Elab.definition true</code></p>
<p>Lean also offers the option of limiting the region in which option is set with
the syntax <code>set_option ... in</code>):</p>
<p>Hygiene can be disabled with the command option <code>set_option hygiene false</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="elaborators"><a class="header" href="#elaborators">Elaborators</a></h2>
<p>TODO. See <a href="https://youtu.be/hxQ1vvhYN_U">Lean Together 2021: Metaprogramming in Lean
4</a> for an overview as well <a href="https://youtu.be/vy4JWIiiXSY">the
continuation</a> about tactic programming.
For more information on antiquotations, see also §4.1 of <a href="https://arxiv.org/pdf/2001.10490.pdf#page=11">Beyond
Notations: Hygienic Macro Expansion for Theorem Proving
Languages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-metaprogramming-examples"><a class="header" href="#syntax-metaprogramming-examples">Syntax Metaprogramming Examples</a></h1>
<ul>
<li><a href="./syntax_example.html">Balanced Parentheses</a></li>
<li><a href="./metaprogramming-arith.html">Arithmetic DSL</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="balanced-parentheses-as-an-embedded-domain-specific-language"><a class="header" href="#balanced-parentheses-as-an-embedded-domain-specific-language">Balanced Parentheses as an Embedded Domain Specific Language</a></h1>
<p>Let's look at how to use macros to extend the Lean 4 parser and embed a language for building <em>balanced parentheses</em>.
This language accepts strings given by the <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF grammar</a></p>
<pre><code>Dyck ::=
  &quot;(&quot; Dyck &quot;)&quot;
  | &quot;{&quot; Dyck &quot;}&quot;
  | end
</code></pre>
<p>We begin by defining an inductive data type of the grammar we wish to parse:</p>
<pre><code class="language-lean ignore">inductive Dyck : Type where
  | round : Dyck → Dyck  -- ( &lt;inner&gt; )
  | curly : Dyck → Dyck  -- { &lt;inner&gt; }
  | leaf : Dyck
</code></pre>
<p>We begin by declaring a <em>syntax category</em> using the <code>declare_syntax_cat &lt;category&gt;</code> command.
This names our grammar and allows us to specify parsing rules associated with our grammar.</p>
<pre><code class="language-lean ignore">declare_syntax_cat brack
</code></pre>
<p>Next, we specify the grammar using the <code>syntax &lt;parse rule&gt;</code> command:</p>
<pre><code class="language-lean ignore">syntax &quot;end&quot; : brack
</code></pre>
<p>The above means that the token &quot;end&quot; lives in syntax category <code>brack</code>.</p>
<p>Similarly, we declare the rules <code>&quot;(&quot; Dyck &quot;)&quot;</code> and <code>&quot;{&quot; Dyck &quot;}&quot;</code> using the rules:</p>
<pre><code class="language-lean ignore">syntax &quot;(&quot; brack &quot;)&quot; : brack
syntax &quot;{&quot; brack &quot;}&quot; : brack
</code></pre>
<p>Finally, we need a way to build <em>Lean 4 terms</em> from this grammar -- that is, we must translate out of this
grammar into a <code>Dyck</code> value, which is a Lean 4 term. For this, we create a new kind of &quot;quotation&quot; that
consumes syntax in <code>brack</code> and produces a <code>term</code>.</p>
<pre><code class="language-lean ignore">syntax &quot;`[Dyck| &quot; brack &quot;]&quot; : term
</code></pre>
<p>To specify the transformation rules, we use <code>macro_rules</code> to declare how the syntax <code>`[Dyck| &lt;brack&gt;]</code>
produces terms. This is written using a pattern-matching style syntax, where the left-hand side
declares the syntax pattern to be matched, and the right-hand side declares the production. Syntax placeholders (antiquotations)
are introduced via the <code>$&lt;var-name&gt;</code> syntax. The right-hand side is
an arbitrary Lean term that we are producing.</p>
<pre><code class="language-lean ignore">macro_rules
  | `(`[Dyck| end])    =&gt; `(Dyck.leaf)
  | `(`[Dyck| ($b)]) =&gt; `(Dyck.round `[Dyck| $b])  -- recurse
  | `(`[Dyck| {$b}]) =&gt; `(Dyck.curly `[Dyck| $b])  -- recurse
</code></pre>
<pre><code class="language-lean ignore">#check `[Dyck| end]      -- Dyck.leaf
#check `[Dyck| {(end)}]  -- Dyck.curl (Dyck.round Dyck.leaf)
</code></pre>
<p>In summary, we've seen:</p>
<ul>
<li>How to declare a syntax category for the Dyck grammar.</li>
<li>How to specify parse trees of this grammar using <code>syntax</code></li>
<li>How to translate out of this grammar into Lean 4 terms using <code>macro_rules</code>.</li>
</ul>
<p>The full program listing is given below:</p>
<pre><code class="language-lean">inductive Dyck : Type where
  | round : Dyck → Dyck  -- ( &lt;inner&gt; )
  | curly : Dyck → Dyck  -- { &lt;inner&gt; }
  | leaf : Dyck

-- declare Dyck grammar parse trees
declare_syntax_cat brack
syntax &quot;(&quot; brack &quot;)&quot; : brack
syntax &quot;{&quot; brack &quot;}&quot; : brack
syntax &quot;end&quot; : brack

-- notation for translating `brack` into `term`
syntax &quot;`[Dyck| &quot; brack &quot;]&quot; : term

-- rules to translate Dyck grammar into inductive value of type Dyck
macro_rules
  | `(`[Dyck| end])    =&gt; `(Dyck.leaf)
  | `(`[Dyck| ($b)]) =&gt; `(Dyck.round `[Dyck| $b])  -- recurse
  | `(`[Dyck| {$b}]) =&gt; `(Dyck.curly `[Dyck| $b])  -- recurse

-- tests
#check `[Dyck| end]      -- Dyck.leaf
#check `[Dyck| {(end)}]  -- Dyck.curl (Dyck.round Dyck.leaf)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-as-an-embedded-domain-specific-language"><a class="header" href="#arithmetic-as-an-embedded-domain-specific-language">Arithmetic as an embedded domain-specific language</a></h1>
<p>Let's parse another classic grammar, the grammar of arithmetic expressions with
addition, multiplication, integers, and variables.  In the process, we'll learn
how to:</p>
<ul>
<li>Convert identifiers such as <code>x</code> into strings within a macro.</li>
<li>add the ability to &quot;escape&quot; the macro context from within the macro. This is useful to interpret identifiers with their <em>original</em> meaning (predefined values)
instead of their new meaning within a macro (treat as a symbol).</li>
</ul>
<p>Let's begin with the simplest thing possible. We'll define an AST, and use operators <code>+</code> and <code>*</code> to denote
building an arithmetic AST.</p>
<p>Here's the AST that we will be parsing:</p>
<pre><code class="language-lean ignore">inductive Arith : Type
  | add : Arith → Arith → Arith  -- e + f
  | mul : Arith → Arith → Arith  -- e * f
  | int : Int → Arith  -- constant
  | symbol : String → Arith  -- variable
</code></pre>
<p>We declare a syntax category to describe the grammar that we will be parsing.
See that we control the precedence of <code>+</code> and <code>*</code> by writing <code>syntax:50</code> for addition and <code>syntax:60</code> for multiplication,
indicating that multiplication binds tighter than addition (higher the number, tighter the binding).
This allows us to declare <em>precedence</em> when defining new syntax.</p>
<pre><code class="language-lean ignore">declare_syntax_cat arith

syntax num : arith  -- int for Arith.int
syntax str : arith  -- strings for Arith.symbol
syntax:60 arith:60 &quot;+&quot; arith:61 : arith  -- Arith.add
syntax:70 arith:70 &quot;*&quot; arith:71 : arith  -- Arith.mul
syntax &quot;(&quot; arith &quot;)&quot; : arith  -- parenthesized expressions
</code></pre>
<p>Further, if we look at <code>syntax:60  arith:60 &quot;+&quot; arith:61 : arith</code>, the
precedence declarations at <code>arith:60 &quot;+&quot; arith:61</code> conveys that the left
argument must have precedence at least <code>60</code> or greater, and the right argument
must have precedence at least<code>61</code> or greater.  Note that this forces left
associativity. To understand this, let's compare two hypothetical parses:</p>
<pre><code>-- syntax:60  arith:60 &quot;+&quot; arith:61 : arith -- Arith.add
-- a + b + c
(a:60 + b:61):60 + c
a + (b:60 + c:61):60
</code></pre>
<p>In the parse tree of <code>a + (b:60 + c:61):60</code>, we see that the right argument <code>(b + c)</code> is given the precedence <code>60</code>. However,
the rule for addition expects the right argument to have a precedence of <strong>at least</strong> 61, as witnessed by the <code>arith:61</code> at
the right-hand-side of <code>syntax:60 arith:60 &quot;+&quot; arith:61 : arith</code>. Thus, the rule <code>syntax:60  arith:60 &quot;+&quot; arith:61 : arith</code>
ensures that addition is left associative.</p>
<p>Since addition is declared arguments of precedence <code>60/61</code> and multiplication with <code>70/71</code>, this causes multiplication to bind
tighter than addition. Once again, let's compare two hypothetical parses:</p>
<pre><code>-- syntax:60  arith:60 &quot;+&quot; arith:61 : arith -- Arith.add
-- syntax:70 arith:70 &quot;*&quot; arith:71 : arith -- Arith.mul
-- a * b + c
a * (b:60 + c:61):60
(a:70 * b:71):70 + c
</code></pre>
<p>While parsing <code>a * (b + c)</code>, <code>(b + c)</code> is assigned a precedence <code>60</code> by the addition rule. However, multiplication expects
the right argument to have precedence <strong>at least</strong> 71. Thus, this parse is invalid. In contrast, <code>(a * b) + c</code> assigns
a precedence of <code>70</code> to <code>(a * b)</code>. This is compatible with addition which expects the left argument to have precedence
**at least <code>60</code> ** (<code>70</code> is greater than <code>60</code>). Thus, the string <code>a * b + c</code> is parsed as <code>(a * b) + c</code>.
For more details, please look at the <a href="../syntax.html#notations-and-precedence">Lean manual on syntax extensions</a>.</p>
<p>To go from strings into <code>Arith</code>, we define a macro to
translate the syntax category <code>arith</code> into an <code>Arith</code> inductive value that
lives in <code>term</code>:</p>
<pre><code class="language-lean ignore">-- auxiliary notation for translating `arith` into `term`
syntax &quot;`[Arith| &quot; arith &quot;]&quot; : term
</code></pre>
<p>Our macro rules perform the &quot;obvious&quot; translation:</p>
<pre><code class="language-lean ignore">macro_rules
  | `(`[Arith| $s:str]) =&gt; `(Arith.symbol $s)
  | `(`[Arith| $num:num]) =&gt; `(Arith.int $num)
  | `(`[Arith| $x + $y]) =&gt; `(Arith.add `[Arith| $x] `[Arith| $y])
  | `(`[Arith| $x * $y]) =&gt; `(Arith.mul `[Arith| $x] `[Arith| $y])
  | `(`[Arith| ($x)]) =&gt; `(`[Arith| $x])
</code></pre>
<p>And some examples:</p>
<pre><code class="language-lean ignore">#check `[Arith| &quot;x&quot; * &quot;y&quot;]  -- mul
-- Arith.mul (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)

#check `[Arith| &quot;x&quot; + &quot;y&quot;]  -- add
-- Arith.add (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)

#check `[Arith| &quot;x&quot; + 20]  -- symbol + int
-- Arith.add (Arith.symbol &quot;x&quot;) (Arith.int 20)

#check `[Arith| &quot;x&quot; + &quot;y&quot; * &quot;z&quot;]  -- precedence
-- Arith.add (Arith.symbol &quot;x&quot;) (Arith.mul (Arith.symbol &quot;y&quot;) (Arith.symbol &quot;z&quot;))

#check `[Arith| &quot;x&quot; * &quot;y&quot; + &quot;z&quot;]  -- precedence
-- Arith.add (Arith.mul (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)) (Arith.symbol &quot;z&quot;)

#check `[Arith| (&quot;x&quot; + &quot;y&quot;) * &quot;z&quot;]  -- parentheses
-- Arith.mul (Arith.add (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)) (Arith.symbol &quot;z&quot;)
</code></pre>
<p>Writing variables as strings, such as <code>&quot;x&quot;</code>  gets old; wouldn't it be so much
prettier if we could write <code>x * y</code>, and have the macro translate this into <code>Arith.mul (Arith.Symbol &quot;x&quot;) (Arith.mul &quot;y&quot;)</code>?
We can do this, and this will be our first taste of manipulating macro variables --- we'll use <code>x.getId</code> instead of directly evaluating <code>$x</code>.
We also write a macro rule for <code>Arith|</code> that translates an identifier into
a string, using <code>$(Lean.quote (toString x.getId))</code>:</p>
<pre><code class="language-lean ignore">syntax ident : arith

macro_rules
  | `(`[Arith| $x:ident]) =&gt; `(Arith.symbol $(Lean.quote (toString x.getId)))
</code></pre>
<p>Let's test and see that we can now write expressions such as <code>x * y</code> directly instead of having to write <code>&quot;x&quot; * &quot;y&quot;</code>:</p>
<pre><code class="language-lean ignore">#check `[Arith| x]  -- Arith.symbol &quot;x&quot;

def xPlusY := `[Arith| x + y]
#print xPlusY  -- def xPlusY : Arith := Arith.add (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)
</code></pre>
<p>We now show an unfortunate consequence of the above definitions. Suppose we want to build <code>(x + y) + z</code>.
Since we already have defined <code>xPlusY</code> as <code>x + y</code>, perhaps we should reuse it! Let's try:</p>
<pre><code class="language-lean ignore">#check `[Arith| xPlusY + z]  -- Arith.add (Arith.symbol &quot;xPlusY&quot;) (Arith.symbol &quot;z&quot;)
</code></pre>
<p>Whoops, that didn't work! What happened? Lean treats <code>xPlusY</code> <em>itself</em> as an identifier! So we need to add some syntax
to be able to &quot;escape&quot; the <code>Arith|</code> context. Let's use the syntax <code>&lt;[ $e:term ]&gt;</code> to mean: evaluate <code>$e</code> as a real term,
not an identifier. The macro looks like follows:</p>
<pre><code class="language-lean ignore">syntax &quot;&lt;[&quot; term &quot;]&gt;&quot; : arith  -- escape for embedding terms into `Arith`

macro_rules
  | `(`[Arith| &lt;[ $e:term ]&gt;]) =&gt; pure e
</code></pre>
<p>Let's try our previous example:</p>
<pre><code class="language-lean ignore">#check `[Arith| &lt;[ xPlusY ]&gt; + z]  -- Arith.add xPlusY (Arith.symbol &quot;z&quot;)
</code></pre>
<p>Perfect!</p>
<p>In this tutorial, we expanded on the previous tutorial to parse a more
realistic grammar with multiple levels of precedence, how to parse identifiers directly
within a macro, and how to provide an escape from within the macro context.</p>
<h4 id="full-code-listing"><a class="header" href="#full-code-listing">Full code listing</a></h4>
<pre><code class="language-lean">inductive Arith : Type
  | add : Arith → Arith → Arith  -- e + f
  | mul : Arith → Arith → Arith  -- e * f
  | int : Int → Arith  -- constant
  | symbol : String → Arith  -- variable

declare_syntax_cat arith

syntax num : arith  -- int for Arith.int
syntax str : arith  -- strings for Arith.symbol
syntax:60 arith:60 &quot;+&quot; arith:61 : arith  -- Arith.add
syntax:70 arith:70 &quot;*&quot; arith:71 : arith  -- Arith.mul
syntax &quot;(&quot; arith &quot;)&quot; : arith  -- parenthesized expressions

-- auxiliary notation for translating `arith` into `term`
syntax &quot;`[Arith| &quot; arith &quot;]&quot; : term

macro_rules
  | `(`[Arith| $s:str]) =&gt; `(Arith.symbol $s)
  | `(`[Arith| $num:num]) =&gt; `(Arith.int $num)
  | `(`[Arith| $x + $y]) =&gt; `(Arith.add `[Arith| $x] `[Arith| $y])
  | `(`[Arith| $x * $y]) =&gt; `(Arith.mul `[Arith| $x] `[Arith| $y])
  | `(`[Arith| ($x)]) =&gt; `(`[Arith| $x])

#check `[Arith| &quot;x&quot; * &quot;y&quot;]  -- mul
-- Arith.mul (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)

#check `[Arith| &quot;x&quot; + &quot;y&quot;]  -- add
-- Arith.add (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)

#check `[Arith| &quot;x&quot; + 20]  -- symbol + int
-- Arith.add (Arith.symbol &quot;x&quot;) (Arith.int 20)

#check `[Arith| &quot;x&quot; + &quot;y&quot; * &quot;z&quot;]  -- precedence
-- Arith.add (Arith.symbol &quot;x&quot;) (Arith.mul (Arith.symbol &quot;y&quot;) (Arith.symbol &quot;z&quot;))

#check `[Arith| &quot;x&quot; * &quot;y&quot; + &quot;z&quot;]  -- precedence
-- Arith.add (Arith.mul (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)) (Arith.symbol &quot;z&quot;)

#check `[Arith| (&quot;x&quot; + &quot;y&quot;) * &quot;z&quot;]  -- parentheses
-- Arith.mul (Arith.add (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)) (Arith.symbol &quot;z&quot;)

syntax ident : arith

macro_rules
  | `(`[Arith| $x:ident]) =&gt; `(Arith.symbol $(Lean.quote (toString x.getId)))

#check `[Arith| x]  -- Arith.symbol &quot;x&quot;

def xPlusY := `[Arith| x + y]
#print xPlusY  -- def xPlusY : Arith := Arith.add (Arith.symbol &quot;x&quot;) (Arith.symbol &quot;y&quot;)

syntax &quot;&lt;[&quot; term &quot;]&gt;&quot; : arith  -- escape for embedding terms into `Arith`

macro_rules
  | `(`[Arith| &lt;[ $e:term ]&gt;]) =&gt; pure e

#check `[Arith| &lt;[ xPlusY ]&gt; + z]  -- Arith.add xPlusY (Arith.symbol &quot;z&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-new-types"><a class="header" href="#declaring-new-types">Declaring New Types</a></h1>
<p>In Lean's library, every concrete type other than the universes and every type constructor other than the dependent function type is
an instance of a general family of type constructions known as <em>inductive types</em>. It is remarkable that it is possible to develop
complex programs and formalize mathematics based on nothing more than the type universes, dependent function types,
and inductive types; everything else follows from those.</p>
<p>Intuitively, an inductive type is built up from a specified list of constructors. In Lean, the basic syntax for specifying such a type is as follows:</p>
<pre><code>inductive NewType where
  | constructor_1 : ... → NewType
  | constructor_2 : ... → NewType
  ...
  | constructor_n : ... → NewType
</code></pre>
<p>The intuition is that each constructor specifies a way of building new objects of <code>NewType</code>, possibly from previously constructed values.
The type <code>NewType</code> consists of nothing more than the objects that are constructed in this way.</p>
<p>We will see below that the arguments to the constructors can include objects of type <code>NewType</code>,
subject to a certain &quot;positivity&quot; constraint, which guarantees that elements of <code>NewType</code> are built
from the bottom up. Roughly speaking, each <code>...</code> can be any function type constructed from <code>NewType</code>
and previously defined types, in which <code>NewType</code> appears, if at all, only as the &quot;target&quot; of the function type.</p>
<p>We will provide a number of examples of inductive types. We will also consider slight generalizations of the scheme above,
to mutually defined inductive types, and so-called <em>inductive families</em>.</p>
<p>Every inductive type comes with constructors, which show how to construct an element of the type, and elimination rules,
which show how to &quot;use&quot; an element of the type in another construction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerated-types"><a class="header" href="#enumerated-types">Enumerated Types</a></h1>
<p>The simplest kind of inductive type is simply a type with a finite, enumerated list of elements.
The following command declares the enumerated type <code>Weekday</code>.</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday    : Weekday
  | monday    : Weekday
  | tuesday   : Weekday
  | wednesday : Weekday
  | thursday  : Weekday
  | friday    : Weekday
  | saturday  : Weekday
</code></pre>
<p>The <code>Weekday</code> type has 7 constructors/elements. The constructors live in the <code>Weekday</code> namespace
Think of <code>sunday</code>, <code>monday</code>, …, <code>saturday</code> as being distinct elements of <code>Weekday</code>,
with no other distinguishing properties.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span>#check Weekday.sunday   -- Weekday
#check Weekday.monday   -- Weekday
</code></pre>
<p>You can define functions by pattern matching.
The following function converts a <code>Weekday</code> into a natural number.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span>def natOfWeekday (d : Weekday) : Nat :=
  match d with
  | Weekday.sunday    =&gt; 1
  | Weekday.monday    =&gt; 2
  | Weekday.tuesday   =&gt; 3
  | Weekday.wednesday =&gt; 4
  | Weekday.thursday  =&gt; 5
  | Weekday.friday    =&gt; 6
  | Weekday.saturday  =&gt; 7

#eval natOfWeekday Weekday.tuesday -- 3
</code></pre>
<p>It is often useful to group definitions related to a type in a namespace with the same name.
For example, we can put the function above into the <code>Weekday</code> namespace.
We are then allowed to use the shorter name when we open the namespace.</p>
<p>In the following example, we define functions from <code>Weekday</code> to <code>Weekday</code> in the namespace <code>Weekday</code>.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span>namespace Weekday

def next (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; monday
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; saturday
  | saturday  =&gt; sunday

end Weekday
</code></pre>
<p>It is so common to start a definition with a <code>match</code> in Lean, that Lean provides a syntax sugar for it.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span><span class="boring">namespace Weekday
</span>def previous : Weekday -&gt; Weekday
  | sunday    =&gt; saturday
  | monday    =&gt; sunday
  | tuesday   =&gt; monday
  | wednesday =&gt; tuesday
  | thursday  =&gt; wednesday
  | friday    =&gt; thursday
  | saturday  =&gt; friday
<span class="boring">end Weekday
</span></code></pre>
<p>We can use the command <code>#eval</code> to test our definitions.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous : Weekday -&gt; Weekday
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>def toString : Weekday -&gt; String
  | sunday    =&gt; &quot;Sunday&quot;
  | monday    =&gt; &quot;Monday&quot;
  | tuesday   =&gt; &quot;Tuesday&quot;
  | wednesday =&gt; &quot;Wednesday&quot;
  | thursday  =&gt; &quot;Thursday&quot;
  | friday    =&gt; &quot;Friday&quot;
  | saturday  =&gt; &quot;Saturday&quot;

#eval toString (next sunday)             -- &quot;Monday&quot;
#eval toString (next tuesday)            -- &quot;Wednesday&quot;
#eval toString (previous wednesday)      -- &quot;Tuesday&quot;
#eval toString (next (previous sunday))  -- &quot;Sunday&quot;
#eval toString (next (previous monday))  -- &quot;Monday&quot;
-- ..
<span class="boring">end Weekday
</span></code></pre>
<p>We can now prove the general theorem that <code>next (previous d) = d</code> for any weekday <code>d</code>.
The idea is to perform a proof by cases using <code>match</code>, and rely on the fact for each constructor both
sides of the equality reduce to the same term.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous : Weekday -&gt; Weekday
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>theorem nextOfPrevious (d : Weekday) : next (previous d) = d :=
  match d with
  | sunday    =&gt; rfl
  | monday    =&gt; rfl
  | tuesday   =&gt; rfl
  | wednesday =&gt; rfl
  | thursday  =&gt; rfl
  | friday    =&gt; rfl
  | saturday  =&gt; rfl
<span class="boring">end Weekday
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inductive-types"><a class="header" href="#inductive-types">Inductive Types</a></h1>
<p><a href="https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html">Theorem Proving in Lean</a> has a chapter about inductive datatypes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<p>Structure is a special case of inductive datatype. It has only one constructor and is not recursive.
Similar to the <code>inductive</code> command, the <code>structure</code> command introduces a namespace with the same name.
The general form is as follows:</p>
<pre><code>structure &lt;name&gt; &lt;parameters&gt; &lt;parent-structures&gt; where
  &lt;constructor-name&gt; :: &lt;fields&gt;
</code></pre>
<p>Most parts are optional. Here is our first example.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
</code></pre>
<p>In the example above, the constructor name is not provided. So, the constructor is named <code>mk</code> by Lean.
Values of type <code>Point</code> are created using <code>Point.mk a b</code> or <code>{ x := a, y := b : Point α }</code>. The latter can be
written as <code>{ x := a, y := b }</code> when the expected type is known.
The fields of a point <code>p</code> are accessed using <code>Point.x p</code> and <code>Point.y p</code>. You can also the more compact notation <code>p.x</code> and <code>p.y</code> as a shorthand
for <code>Point.x p</code> and <code>Point.y p</code>.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>#check Point
#check Point       -- Type u -&gt; Type u
#check @Point.mk   -- {α : Type u} → α → α → Point α
#check @Point.x    -- {α : Type u} → Point α → α
#check @Point.y    -- {α : Type u} → Point α → α

#check Point.mk 10 20                   -- Point Nat
#check { x := 10, y := 20 : Point Nat } -- Point Nat

def mkPoint (a : Nat) : Point Nat :=
  { x := a, y := a }

#eval (Point.mk 10 20).x                   -- 10
#eval (Point.mk 10 20).y                   -- 20
#eval { x := 10, y := 20 : Point Nat }.x   -- 10
#eval { x := 10, y := 20 : Point Nat }.y   -- 20

def addXY (p : Point Nat) : Nat :=
  p.x + p.y

#eval addXY { x := 10, y := 20 }    -- 30
</code></pre>
<p>In the notation <code>{ ... }</code>, if the fields are in different lines, the <code>,</code> is optional.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>def mkPoint (a : Nat) : Point Nat := {
  x := a
  y := a
}
</code></pre>
<p>You can also use <code>where</code> instead of <code>:= { ... }</code>.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>def mkPoint (a : Nat) : Point Nat where
  x := a
  y := a
</code></pre>
<p>Here are some simple theorems about our <code>Point</code> type.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>theorem ex1 (a b : α) : (Point.mk a b).x = a :=
  rfl

theorem ex2 (a b : α) : (Point.mk a b).y = b :=
  rfl

theorem ex3 (a b : α) : Point.mk a b = { x := a, y := b } :=
  rfl
</code></pre>
<p>The dot notation is convenient not just for accessing the projections of a structure,
but also for applying functions defined in a namespace with the same name.
If <code>p</code> has type <code>Point</code>, the expression <code>p.foo</code> is interpreted as <code>Point.foo p</code>,
assuming that the first argument to <code>foo</code> has type <code>Point</code>.
The expression <code>p.add q</code> is therefore shorthand for <code>Point.add p q</code> in the example below.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

def Point.add (p q : Point Nat) : Point Nat :=
  { x := p.x + q.x, y := p.y + q.y }

def p : Point Nat := Point.mk 1 2
def q : Point Nat := Point.mk 3 4

#eval (p.add q).x  -- 4
#eval (p.add q).y  -- 6
</code></pre>
<p>After we introduce type classes, we show how to define a function like <code>add</code> so that
it works generically for elements of <code>Point α</code> rather than just <code>Point Nat</code>,
assuming <code>α</code> has an associated addition operation.</p>
<p>More generally, given an expression <code>p.foo x y z</code>, Lean will insert <code>p</code> at the first argument to <code>foo</code> of type <code>Point</code>.
For example, with the definition of scalar multiplication below, <code>p.smul 3</code> is interpreted as <code>Point.smul 3 p</code>.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

def Point.smul (n : Nat) (p : Point Nat) :=
  Point.mk (n * p.x) (n * p.y)

def p : Point Nat :=
  Point.mk 1 2

#eval (p.smul 3).x -- 3
#eval (p.smul 3).y -- 6
</code></pre>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>We can <em>extend</em> existing structures by adding new fields. This feature allows us to simulate a form of <em>inheritance</em>.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

inductive Color where
  | red
  | green
  | blue

structure ColorPoint (α : Type u) extends Point α where
  color : Color

#check { x := 10, y := 20, color := Color.red : ColorPoint Nat }
-- { toPoint := { x := 10, y := 20 }, color := Color.red }
</code></pre>
<p>The output for the <code>check</code> command above suggests how Lean encoded inheritance and multiple inheritance.
Lean uses fields to each parent structure.</p>
<pre><code class="language-lean">structure Foo where
  x : Nat
  y : Nat

structure Boo where
  w : Nat
  z : Nat

structure Bla extends Foo, Boo where
  bit : Bool

#check Bla.mk -- Foo → Boo → Bool → Bla
#check Bla.mk { x := 10, y := 20 } { w := 30, z := 40 } true
#check { x := 10, y := 20, w := 30, z := 40, bit := true : Bla }
#check { toFoo := { x := 10, y := 20 },
         toBoo := { w := 30, z := 40 },
         bit := true : Bla }

theorem ex :
    Bla.mk { x := x, y := y } { w := w, z := z } b
    =
    { x := x, y := y, w := w, z := z, bit := b } :=
  rfl
</code></pre>
<h2 id="default-field-values"><a class="header" href="#default-field-values">Default field values</a></h2>
<p>You can assign default value to fields when declaring a new structure.</p>
<pre><code class="language-lean">inductive MessageSeverity
  | error | warning

structure Message where
  fileName : String
  pos      : Option Nat      := none
  severity : MessageSeverity := MessageSeverity.error
  caption  : String          := &quot;&quot;
  data     : String

def msg1 : Message :=
  { fileName := &quot;foo.lean&quot;, data := &quot;failed to import file&quot; }

#eval msg1.pos      -- none
#eval msg1.fileName -- &quot;foo.lean&quot;
#eval msg1.caption  -- &quot;&quot;
</code></pre>
<p>When extending a structure, you can not only add new fields, but provide new default values for existing fields.</p>
<pre><code class="language-lean"><span class="boring">inductive MessageSeverity
</span><span class="boring"> | error | warning
</span><span class="boring">structure Message where
</span><span class="boring"> fileName : String
</span><span class="boring"> pos      : Option Nat      := none
</span><span class="boring"> severity : MessageSeverity := MessageSeverity.error
</span><span class="boring"> caption  : String          := &quot;&quot;
</span><span class="boring"> data     : String
</span>structure MessageExt extends Message where
  timestamp : Nat
  caption   := &quot;extended&quot; -- new default value for field `caption`

def msg2 : MessageExt where
  fileName  := &quot;bar.lean&quot;
  data      := &quot;error at initialization&quot;
  timestamp := 10

#eval msg2.fileName  -- &quot;bar.lean&quot;
#eval msg2.timestamp -- 10
#eval msg2.caption   -- &quot;extended&quot;
</code></pre>
<h2 id="updating-structure-fields"><a class="header" href="#updating-structure-fields">Updating structure fields</a></h2>
<p>Structure fields can be updated using <code>{ &lt;struct-val&gt; with &lt;field&gt; := &lt;new-value&gt;, ... }</code>:</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>def incrementX (p : Point Nat) : Point Nat := { p with x := p.x + 1 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-classes"><a class="header" href="#type-classes">Type classes</a></h1>
<p>Typeclasses were introduced as a principled way of enabling
ad-hoc polymorphism in functional programming languages. We first observe that it
would be easy to implement an ad-hoc polymorphic function (such as addition) if the
function simply took the type-specific implementation of addition as an argument
and then called that implementation on the remaining arguments. For example,
suppose we declare a structure in Lean to hold implementations of addition</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>structure Add (a : Type) where
  add : a -&gt; a -&gt; a

#check @Add.add
-- Add.add : {a : Type} → Add a → a → a → a
<span class="boring">end Ex
</span></code></pre>
<p>In the above Lean code, the field <code>add</code> has type
<code>Add.add : {α : Type} → Add α → α → α → α</code>
where the curly braces around the type <code>a</code> mean that it is an implicit argument.
We could implement <code>double</code> by</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">structure Add (a : Type) where
</span><span class="boring"> add : a -&gt; a -&gt; a
</span>def double (s : Add a) (x : a) : a :=
  s.add x x

#eval double { add := Nat.add } 10
-- 20

#eval double { add := Nat.mul } 10
-- 100

#eval double { add := Int.add } 10
-- 20

<span class="boring">end Ex
</span></code></pre>
<p>Note that you can double a natural number <code>n</code> by <code>double { add := Nat.add } n</code>.
Of course, it would be highly cumbersome for users to manually pass the
implementations around in this way.
Indeed, it would defeat most of the potential benefits of ad-hoc
polymorphism.</p>
<p>The main idea behind typeclasses is to make arguments such as <code>Add a</code> implicit,
and to use a database of user-defined instances to synthesize the desired instances
automatically through a process known as typeclass resolution. In Lean, by changing
<code>structure</code> to <code>class</code> in the example above, the type of <code>Add.add</code> becomes</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Add (a : Type) where
  add : a -&gt; a -&gt; a

#check @Add.add
-- Add.add : {a : Type} → [self : Add a] → a → a → a
<span class="boring">end Ex
</span></code></pre>
<p>where the square brackets indicate that the argument of type <code>Add a</code> is <em>instance implicit</em>,
i.e. that it should be synthesized using typeclass resolution. This version of
<code>add</code> is the Lean analogue of the Haskell term <code>add :: Add a =&gt; a -&gt; a -&gt; a</code>.
Similarly, we can register an instance by</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring"> add : a -&gt; a -&gt; a
</span>instance : Add Nat where
  add := Nat.add

<span class="boring">end Ex
</span></code></pre>
<p>Then for <code>n : Nat</code> and <code>m : Nat</code>, the term <code>Add.add n m</code> triggers typeclass resolution with the goal
of <code>Add Nat</code>, and typeclass resolution will synthesize the instance above. In
general, instances may depend on other instances in complicated ways. For example,
you can declare an (anonymous) instance stating that if <code>a</code> has addition, then <code>Array a</code>
has addition:</p>
<pre><code class="language-lean">instance [Add a] : Add (Array a) where
  add x y := Array.zipWith x y (· + ·)

#eval Add.add #[1, 2] #[3, 4]
-- #[4, 6]

#eval #[1, 2] + #[3, 4]
-- #[4, 6]
</code></pre>
<p>Note that <code>x + y</code> is notation for <code>Add.add x y</code> in Lean.</p>
<p>The example above demonstrates how type classes are used to overload notation.
Now, we explore another application. We often need an arbitrary element of a given type.
Recall that types may not have any elements in Lean.
It often happens that we would like a definition to return an arbitrary element in a &quot;corner case.&quot;
For example, we may like the expression <code>head xs</code> to be of type <code>a</code> when <code>xs</code> is of type <code>List a</code>.
Similarly, many theorems hold under the additional assumption that a type is not empty.
For example, if <code>a</code> is a type, <code>exists x : a, x = x</code> is true only if <code>a</code> is not empty.
The standard library defines a type class <code>Inhabited</code> to enable type class inference to infer a
&quot;default&quot; or &quot;arbitrary&quot; element of an inhabited type.
Let us start with the first step of the program above, declaring an appropriate class:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Inhabited (a : Sort u) where
  default : a

#check @Inhabited.default
-- Inhabited.default : {a : Sort u} → [self : Inhabited a] → a
<span class="boring">end Ex
</span></code></pre>
<p>Note <code>Inhabited.default</code> doesn't have any explicit argument.</p>
<p>An element of the class <code>Inhabited a</code> is simply an expression of the form <code>Inhabited.mk x</code>, for some element <code>x : a</code>.
The projection <code>Inhabited.default</code> will allow us to &quot;extract&quot; such an element of <code>a</code> from an element of <code>Inhabited a</code>.
Now we populate the class with some instances:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Sort _) where
</span><span class="boring"> default : a
</span>instance : Inhabited Bool where
  default := true

instance : Inhabited Nat where
  default := 0

instance : Inhabited Unit where
  default := ()

instance : Inhabited Prop where
  default := True

#eval (Inhabited.default : Nat)
-- 0

#eval (Inhabited.default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<p>You can use the command <code>export</code> to create the alias <code>default</code> for <code>Inhabited.default</code></p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Sort _) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">instance : Inhabited Unit where
</span><span class="boring"> default := ()
</span><span class="boring">instance : Inhabited Prop where
</span><span class="boring"> default := True
</span>export Inhabited (default)

#eval (default : Nat)
-- 0

#eval (default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<h2 id="chaining-instances"><a class="header" href="#chaining-instances">Chaining Instances</a></h2>
<p>If that were the extent of type class inference, it would not be all that impressive;
it would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table.
What makes type class inference powerful is that one can <em>chain</em> instances. That is,
an instance declaration can in turn depend on an implicit instance of a type class.
This causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.</p>
<p>For example, the following definition shows that if two types <code>a</code> and <code>b</code> are inhabited, then so is their product:</p>
<pre><code class="language-lean">instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)
</code></pre>
<p>With this added to the earlier instance declarations, type class instance can infer, for example, a default element of <code>Nat × Bool</code>:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Sort u) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">opaque default [Inhabited a] : a :=
</span><span class="boring"> Inhabited.default
</span>instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (default, default)

#eval (default : Nat × Bool)
-- (0, true)
<span class="boring">end Ex
</span></code></pre>
<p>Similarly, we can inhabit type function with suitable constant functions:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Sort u) where
</span><span class="boring"> default : a
</span><span class="boring">opaque default [Inhabited a] : a :=
</span><span class="boring"> Inhabited.default
</span>instance [Inhabited b] : Inhabited (a -&gt; b) where
  default := fun _ =&gt; default
<span class="boring">end Ex
</span></code></pre>
<p>As an exercise, try defining default instances for other types, such as <code>List</code> and <code>Sum</code> types.</p>
<p>The Lean standard library contains the definition <code>inferInstance</code>. It has type <code>{α : Sort u} → [i : α] → α</code>,
and is useful for triggering the type class resolution procedure when the expected type is an instance.</p>
<pre><code class="language-lean">#check (inferInstance : Inhabited Nat) -- Inhabited Nat

def foo : Inhabited (Nat × Nat) :=
  inferInstance

theorem ex : foo.default = (default, default) :=
  rfl
</code></pre>
<p>You can use the command <code>#print</code> to inspect how simple <code>inferInstance</code> is.</p>
<pre><code class="language-lean">#print inferInstance
</code></pre>
<h2 id="tostring"><a class="header" href="#tostring">ToString</a></h2>
<p>The polymorphic method <code>toString</code> has type <code>{α : Type u} → [ToString α] → α → String</code>. You implement the instance
for your own types and use chaining to convert complex values into strings. Lean comes with <code>ToString</code> instances
for most builtin types.</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString p := p.name ++ &quot;@&quot; ++ toString p.age

#eval toString { name := &quot;Leo&quot;, age := 542 : Person }
#eval toString ({ name := &quot;Daniel&quot;, age := 18 : Person }, &quot;hello&quot;)
</code></pre>
<h2 id="numerals"><a class="header" href="#numerals">Numerals</a></h2>
<p>Numerals are polymorphic in Lean. You can use a numeral (e.g., <code>2</code>) to denote an element of any type that implements
the type class <code>OfNat</code>.</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#eval (2 : Rational) -- 2/1

#check (2 : Rational) -- Rational
#check (2 : Nat)      -- Nat
</code></pre>
<p>Lean elaborate the terms <code>(2 : Nat)</code> and <code>(2 : Rational)</code> as
<code>OfNat.ofNat Nat 2 (instOfNatNat 2)</code> and
<code>OfNat.ofNat Rational 2 (instOfNatRational 2)</code> respectively.
We say the numerals <code>2</code> occurring in the elaborated terms are <em>raw</em> natural numbers.
You can input the raw natural number <code>2</code> using the macro <code>nat_lit 2</code>.</p>
<pre><code class="language-lean">#check nat_lit 2  -- Nat
</code></pre>
<p>Raw natural numbers are <em>not</em> polymorphic.</p>
<p>The <code>OfNat</code> instance is parametric on the numeral. So, you can define instances for particular numerals.
The second argument is often a variable as in the example above, or a <em>raw</em> natural number.</p>
<pre><code class="language-lean">class Monoid (α : Type u) where
  unit : α
  op   : α → α → α

instance [s : Monoid α] : OfNat α (nat_lit 1) where
  ofNat := s.unit

def getUnit [Monoid α] : α :=
  1
</code></pre>
<p>Because many users were forgetting the <code>nat_lit</code> when defining <code>OfNat</code> instances, Lean also accepts <code>OfNat</code> instance
declarations not using <code>nat_lit</code>. Thus, the following is also accepted.</p>
<pre><code class="language-lean">class Monoid (α : Type u) where
  unit : α
  op   : α → α → α

instance [s : Monoid α] : OfNat α 1 where
  ofNat := s.unit

def getUnit [Monoid α] : α :=
  1
</code></pre>
<h2 id="output-parameters"><a class="header" href="#output-parameters">Output parameters</a></h2>
<p>By default, Lean only tries to synthesize an instance <code>Inhabited T</code> when the term <code>T</code> is known and does not
contain missing parts. The following command produces the error
&quot;failed to create type class instance for <code>Inhabited (Nat × ?m.1499)</code>&quot; because the type has a missing part (i.e., the <code>_</code>).</p>
<pre><code class="language-lean"><span class="boring">-- FIXME: should fail
</span>#check (inferInstance : Inhabited (Nat × _))
</code></pre>
<p>You can view the parameter of the type class <code>Inhabited</code> as an <em>input</em> value for the type class synthesizer.
When a type class has multiple parameters, you can mark some of them as output parameters.
Lean will start type class synthesizer even when these parameters have missing parts.
In the following example, we use output parameters to define a <em>heterogeneous</em> polymorphic
multiplication.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Nat (Array Nat) (Array Nat) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3           -- 12
#eval hMul 4 #[2, 3, 4]  -- #[8, 12, 16]
<span class="boring">end Ex
</span></code></pre>
<p>The parameters <code>α</code> and <code>β</code> are considered input parameters and <code>γ</code> an output one.
Given an application <code>hMul a b</code>, after types of <code>a</code> and <code>b</code> are known, the type class
synthesizer is invoked, and the resulting type is obtained from the output parameter <code>γ</code>.
In the example above, we defined two instances. The first one is the homogeneous
multiplication for natural numbers. The second is the scalar multiplication for arrays.
Note that, you chain instances and generalize the second instance.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Int Int Int where
  hMul := Int.mul

instance [HMul α β γ] : HMul α (Array β) (Array γ) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3                    -- 12
#eval hMul 4 #[2, 3, 4]           -- #[8, 12, 16]
#eval hMul (-2) #[3, -1, 4]       -- #[-6, 2, -8]
#eval hMul 2 #[#[2, 3], #[0, 4]]  -- #[#[4, 6], #[0, 8]]
<span class="boring">end Ex
</span></code></pre>
<p>You can use our new scalar array multiplication instance on arrays of type <code>Array β</code>
with a scalar of type <code>α</code> whenever you have an instance <code>HMul α β γ</code>.
In the last <code>#eval</code>, note that the instance was used twice on an array of arrays.</p>
<h2 id="default-instances"><a class="header" href="#default-instances">Default instances</a></h2>
<p>In the class <code>HMul</code>, the parameters <code>α</code> and <code>β</code> are treated as input values.
Thus, type class synthesis only starts after these two types are known. This may often
be too restrictive.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

<span class="boring">-- TODO: fix error message
</span>-- Error &quot;failed to create type class instance for HMul Int ?m.1767 (?m.1797 x)&quot;
-- #check fun y =&gt; xs.map (fun x =&gt; hMul x y)
<span class="boring">end Ex
</span></code></pre>
<p>The instance <code>HMul</code> is not synthesized by Lean because the type of <code>y</code> has not been provided.
However, it is natural to assume that the type of <code>y</code> and <code>x</code> should be the same in
this kind of situation. We can achieve exactly that using <em>default instances</em>.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

@[default_instance]
instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

#check fun y =&gt; xs.map (fun x =&gt; hMul x y)  -- Int -&gt; List Int
<span class="boring">end Ex
</span></code></pre>
<p>By tagging the instance above with the attribute <code>default_instance</code>, we are instructing Lean
to use this instance on pending type class synthesis problems.
The actual Lean implementation defines homogeneous and heterogeneous classes for arithmetical operators.
Moreover, <code>a+b</code>, <code>a*b</code>, <code>a-b</code>, <code>a/b</code>, and <code>a%b</code> are notations for the heterogeneous versions.
The instance <code>OfNat Nat n</code> is the default instance (with priority <code>100</code>) for the <code>OfNat</code> class. This is why the numeral
<code>2</code> has type <code>Nat</code> when the expected type is not known. You can define default instances with higher
priority to override the builtin ones.</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

@[default_instance 200]
instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#check 2 -- Rational
</code></pre>
<p>Priorities are also useful to control the interaction between different default instances.
For example, suppose <code>xs</code> has type <code>α</code>, when elaboration <code>xs.map (fun x =&gt; 2 * x)</code>, we want the homogeneous instance for multiplication
to have higher priority than the default instance for <code>OfNat</code>. This is particularly important when we have implemented only the instance
<code>HMul α α α</code>, and did not implement <code>HMul Nat α α</code>.
Now, we reveal how the notation <code>a*b</code> is defined in Lean.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class OfNat (α : Type u) (n : Nat) where
  ofNat : α

@[default_instance]
instance (n : Nat) : OfNat Nat n where
  ofNat := n

class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

class Mul (α : Type u) where
  mul : α → α → α

@[default_instance 10]
instance [Mul α] : HMul α α α where
  hMul a b := Mul.mul a b

infixl:70 &quot; * &quot;  =&gt; HMul.hMul
<span class="boring">end Ex
</span></code></pre>
<p>The <code>Mul</code> class is convenient for types that only implement the homogeneous multiplication.</p>
<h2 id="scoped-instances"><a class="header" href="#scoped-instances">Scoped Instances</a></h2>
<p>TODO</p>
<h2 id="local-instances"><a class="header" href="#local-instances">Local Instances</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unification-hints"><a class="header" href="#unification-hints">Unification Hints</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-types"><a class="header" href="#builtin-types">Builtin Types</a></h1>
<h2 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h2>
<p>Lean supports the basic mathematical operations you’d expect for all of the number types: addition, subtraction, multiplication, division, and remainder.
The following code shows how you’d use each one in a <code>def</code> commands:</p>
<pre><code class="language-lean">-- addition
def sum := 5 + 10

-- subtraction
def difference := 95.5 - 4.3

-- multiplication
def product := 4 * 30

-- division
def quotient := 53.7 / 32.2

-- remainder/modulo
def modulo := 43 % 5
</code></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates to a single value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="natural-numbers"><a class="header" href="#natural-numbers">Natural numbers</a></h1>
<p>The <code>Nat</code> type represents the natural numbers, i.e., arbitrary-precision unsigned integers.
There are no overflows.</p>
<pre><code class="language-lean">#eval 100000000000000000 * 200000000000000000000 * 1000000000000000000000
</code></pre>
<p>A numeral is considered to be a <code>Nat</code> if there are no typing constraints.</p>
<pre><code class="language-lean">#check 10    -- Nat
#check id 10 -- Nat

def f (x : Int) : Int :=
  x - 1

#eval f (3 - 5) -- 3 and 5 are `Int` since `f` expects an `Int`.
-- -3
</code></pre>
<p>The operator <code>-</code> for <code>Nat</code> implements truncated subtraction.</p>
<pre><code class="language-lean">#eval 10 - 5 -- 5
#eval 5 - 10 -- 0

theorem ex : 5 - 10 = 0 :=
  rfl

#eval (5:Int) - 10 -- -5
</code></pre>
<p>The operator <code>/</code> for <code>Nat</code> implements Euclidean division.</p>
<pre><code class="language-lean">#eval 10 / 4 -- 2

#check 10.0 / 4.0 -- Float
#eval 10.0 / 4.0  -- 2.5
</code></pre>
<p>As we described in the previous sections, we define the <code>Nat</code> type as an <code>inductive</code> datatype.</p>
<pre><code class="language-lean"><span class="boring">namespace hidden
</span>inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
<span class="boring">end hidden
</span></code></pre>
<p>However, the internal representation of <code>Nat</code> is optimized. Small natural numbers (i.e., &lt; <code>2^63</code> in a 64-bit machine) are
represented by a single machine word. Big numbers are implemented using <a href="https://gmplib.org/manual/">GMP</a> numbers.
We recommend you use fixed precision numeric types only in performance critical code.</p>
<p>The Lean kernel has builtin support for the <code>Nat</code> type too, and can efficiently reduce <code>Nat</code> expressions during type checking.</p>
<pre><code class="language-lean">#reduce 100000000000000000 * 200000000000000000000 * 1000000000000000000000

theorem ex
      : 1000000000000000 * 2000000000000000000 = 2000000000000000000000000000000000 :=
  rfl
</code></pre>
<p>The sharp-eyed reader will notice that GMP is part of the Lean kernel trusted code base.
We believe this is not a problem because you can use external type checkers to double-check your developments,
and we consider GMP very trustworthy.
Existing external type checkers for Lean 3 (e.g., <a href="https://github.com/gebner/trepplein">Trepplein</a> and <a href="https://github.com/leanprover/tc">TC</a>)
can be easily adapted to Lean 4.
If you are still concerned after checking your development with multiple different external checkers because
they may all rely on buggy arbitrary-precision libraries,
you can develop your own certified arbitrary-precision library and use it to implement your own type checker for Lean.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integers"><a class="header" href="#integers">Integers</a></h1>
<p>The <code>Int</code> type represents the arbitrary-precision integers. There are no overflows.</p>
<pre><code class="language-lean">#eval (100000000000000000 : Int) * 200000000000000000000 * 1000000000000000000000
</code></pre>
<p>Recall that nonnegative numerals are considered to be a <code>Nat</code> if there are no typing constraints.</p>
<pre><code class="language-lean">#check 1 -- Nat
#check -1 -- Int
#check (1:Int) -- Int
</code></pre>
<p>The operator <code>/</code> for <code>Int</code> implements integer division.</p>
<pre><code class="language-lean">#eval -10 / 4 -- -2
</code></pre>
<p>Similar to <code>Nat</code>, the internal representation of <code>Int</code> is optimized. Small integers are
represented by a single machine word. Big integers are implemented using <a href="https://gmplib.org/manual/">GMP</a> numbers.
We recommend you use fixed precision numeric types only in performance critical code.</p>
<p>The Lean kernel does not have special support for reducing <code>Int</code> during type checking.
However, since <code>Int</code> is defined as</p>
<pre><code class="language-lean"><span class="boring">namespace hidden
</span>inductive Int : Type where
  | ofNat   : Nat → Int
  | negSucc : Nat → Int
<span class="boring">end hidden
</span></code></pre>
<p>the type checker will be able reduce <code>Int</code> expressions efficiently by relying on the special support for <code>Nat</code>.</p>
<pre><code class="language-lean">theorem ex : -2000000000 * 1000000000 = -2000000000000000000 :=
 rfl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixed-precision-unsigned-integers"><a class="header" href="#fixed-precision-unsigned-integers">Fixed precision unsigned integers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="float"><a class="header" href="#float">Float</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>The <code>Array</code> type implements a <em>dynamic</em> (aka growable) array.
It is defined as</p>
<pre><code class="language-lean"><span class="boring">namespace hidden
</span>structure Array (α : Type u) where
  data : List α
<span class="boring">end hidden
</span></code></pre>
<p>but its execution time representation is optimized, and it is similar to C++ <code>std::vector&lt;T&gt;</code> and Rust <code>Vec&lt;T&gt;</code>.
The Lean type checker has no special support for reducing <code>Array</code>s.</p>
<p>You can create arrays in several ways. You can create a small array by listing consecutive values between
<code>#[</code> and <code>]</code> and separated by commas, as shown in the following examples.</p>
<pre><code class="language-lean">#check #[1, 2, 3] -- Array Nat

#check #[] -- Array ?m
</code></pre>
<p>The type of the array elements is inferred from the literals used and must be consistent.</p>
<pre><code class="language-lean">#check #[&quot;hello&quot;, &quot;world&quot;] -- Array String

-- The following is not valid
#check_failure #[10, &quot;hello&quot;]
</code></pre>
<p>Recall that the command <code>#check_failure &lt;term&gt;</code> only succeeds when the given term is not type correct.</p>
<p>To create an array of size <code>n</code> in which all the elements are initialized to some value <code>a</code>, use <code>mkArray</code>.</p>
<pre><code class="language-lean">#eval mkArray 5 'a'
-- #['a', 'a', 'a', 'a', 'a']
</code></pre>
<h2 id="accessing-elements"><a class="header" href="#accessing-elements">Accessing elements</a></h2>
<p>You can access array elements by using brackets (<code>[</code> and <code>]</code>).</p>
<pre><code class="language-lean">def f (a : Array Nat) (i : Fin a.size) :=
  a[i] + a[i]
</code></pre>
<p>Note that the index <code>i</code> has type <code>Fin a.size</code>, i.e., it is natural number less than <code>a.size</code>.
You can also write</p>
<pre><code class="language-lean">def f (a : Array Nat) (i : Nat) (h  : i &lt; a.size) :=
  a[i] + a[i]
</code></pre>
<p>The bracket operator is whitespace sensitive.</p>
<pre><code class="language-lean">def f (xs : List Nat) : List Nat :=
  xs ++ xs

def as : Array Nat :=
  #[1, 2, 3, 4]

def idx : Fin 4 :=
  2

#eval f [1, 2, 3] -- This is a function application

#eval as[idx] -- This is an array access
</code></pre>
<p>The notation <code>a[i]</code> has two variants: <code>a[i]!</code> and <code>a[i]?</code>. In both cases, <code>i</code> has type <code>Nat</code>. The first one
produces a panic error message if the index <code>i</code> is out of bounds. The latter returns an <code>Option</code> type.</p>
<pre><code class="language-lean">#eval #['a', 'b', 'c'][1]?
-- some 'b'
#eval #['a', 'b', 'c'][5]?
-- none
#eval #['a', 'b', 'c'][1]!
-- 'b!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">List</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="characters"><a class="header" href="#characters">Characters</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thunks-tasks-and-threads"><a class="header" href="#thunks-tasks-and-threads">Thunks, Tasks, and Threads</a></h1>
<p>A <code>Thunk</code> is defined as</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">universe u
</span>structure Thunk (α : Type u) : Type u where
  fn : Unit → α
<span class="boring">end Ex
</span></code></pre>
<p>A <code>Thunk</code> encapsulates a computation without evaluation.
That is, a <code>Thunk</code> stores the way of how the value would be computed.
The Lean runtime has special support for <code>Thunk</code>s. It caches their values
after they are computed for the first time. This feature is useful for implementing
data structures such as lazy lists.
Here is a small example using a <code>Thunk</code>.</p>
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 0
  | 1   =&gt; 1
  | x+2 =&gt; fib (x+1) + fib x

def f (c : Bool) (x : Thunk Nat) : Nat :=
  if c then
    x.get
  else
    0

def g (c : Bool) (x : Nat) : Nat :=
  f c (Thunk.mk (fun _ =&gt; fib x))

#eval g false 1000
</code></pre>
<p>The function <code>f</code> above uses <code>x.get</code> to evaluate the <code>Thunk</code> <code>x</code>.
The expression <code>Thunk.mk (fun _ =&gt; fib x)</code> creates a <code>Thunk</code> for computing <code>fib x</code>.
Note that <code>fib</code> is a very naive function for computing the Fibonacci numbers,
and it would an unreasonable amount of time to compute <code>fib 1000</code>. However, our
test terminates instantaneously because the <code>Thunk</code> is not evaluated when <code>c</code> is <code>false</code>.
Lean has a builtin coercion from any type <code>a</code> to <code>Thunk a</code>. You write the function <code>g</code> above as</p>
<pre><code class="language-lean"><span class="boring">def fib : Nat → Nat
</span><span class="boring"> | 0   =&gt; 0
</span><span class="boring"> | 1   =&gt; 1
</span><span class="boring"> | x+2 =&gt; fib (x+1) + fib x
</span><span class="boring">def f (c : Bool) (x : Thunk Nat) : Nat :=
</span><span class="boring"> if c then
</span><span class="boring">   x.get
</span><span class="boring"> else
</span><span class="boring">   0
</span>def g (c : Bool) (x : Nat) : Nat :=
  f c (fib x)

#eval g false 1000
</code></pre>
<p>In the following example, we use the macro <code>dbg_trace</code> to demonstrate
that the Lean runtime caches the value computed by a <code>Thunk</code>.
We remark that the macro <code>dbg_trace</code> should be used for debugging purposes
only.</p>
<pre><code class="language-lean">def add1 (x : Nat) : Nat :=
  dbg_trace &quot;add1: {x}&quot;
  x + 1

def double (x : Thunk Nat) : Nat :=
  x.get + x.get

def triple (x : Thunk Nat) : Nat :=
  double x + x.get

def test (x : Nat) : Nat :=
  triple (add1 x)

#eval test 2
-- add1: 2
-- 9
</code></pre>
<p>Note that the message <code>add1: 2</code> is printed only once.
Now, consider the same example using <code>Unit -&gt; Nat</code> instead of <code>Thunk Nat</code>.</p>
<pre><code class="language-lean">def add1 (x : Nat) : Nat :=
  dbg_trace &quot;add1: {x}&quot;
  x + 1

def double (x : Unit -&gt; Nat) : Nat :=
  x () + x ()

def triple (x : Unit -&gt; Nat) : Nat :=
  double x + x ()

def test (x : Nat) : Nat :=
  triple (fun _ =&gt; add1 x)

#eval test 2
-- add1: 2
-- add1: 2
-- 9
</code></pre>
<p>Now, the message <code>add1: 2</code> is printed twice.
It may come as a surprise that it was printed twice instead of three times.
As we pointed out, <code>dbg_trace</code> is a macro used for debugging purposes only,
and <code>add1</code> is still considered to be a pure function.
The Lean compiler performs common subexpression elimination when compiling <code>double</code>,
and the produced code for <code>double</code> executes <code>x ()</code> only once instead of twice.
This transformation is safe because <code>x : Unit -&gt; Nat</code> is pure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task"><a class="header" href="#task">Task</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are the fundamental unit of program execution in any programming language.
As in other languages, a Lean function has a name, can have parameters and take arguments, and has a body.
Lean also supports functional programming constructs such as treating functions as values,
using unnamed functions in expressions, composition of functions to form new functions,
curried functions, and the implicit definition of functions by way of
the partial application of function arguments.</p>
<p>You define functions by using the <code>def</code> keyword followed by its name, a parameter list, return type and its body.
The parameter list consists of successive parameters that are separated by spaces.
You can specify an explicit type for each parameter.
If you do not specify a specific argument type, the compiler tries to infer the type from the function body.
An error is returned when it cannot be inferred.
The expression that makes up the function body is typically a compound expression consisting of a number of expressions
that culminate in a final expression that is the return value.
The return type is a colon followed by a type and is optional.
If you do not specify the type of the return value explicitly,
the compiler tries to determine the return type from the final expression.</p>
<pre><code class="language-lean">def f x := x + 1
</code></pre>
<p>In the previous example, the function name is <code>f</code>, the argument is <code>x</code>, which has type <code>Nat</code>,
the function body is <code>x + 1</code>, and the return value is of type <code>Nat</code>.
The following example defines the factorial recursive function using pattern matching.</p>
<pre><code class="language-lean">def fact x :=
  match x with
  | 0   =&gt; 1
  | n+1 =&gt; (n+1) * fact n

#eval fact 100
</code></pre>
<p>By default, Lean only accepts total functions (see <a href="declarations.html#_the_equation_compiler">The Equation
Compiler</a> for how Lean determines
whether functions are total).
The <code>partial</code> keyword may be used to define a recursive function without a termination proof; <code>partial</code> functions compute in compiled programs, but are opaque in proofs and during type checking.</p>
<pre><code class="language-lean">partial def g (x : Nat) (p : Nat -&gt; Bool) : Nat :=
  if p x then
    x
  else
    g (x+1) p

#eval g 0 (fun x =&gt; x &gt; 10)
</code></pre>
<p>In the previous example, <code>g x p</code> only terminates if there is a <code>y &gt;= x</code> such that <code>p y</code> returns <code>true</code>.
Of course, <code>g 0 (fun x =&gt; false)</code> never terminates.</p>
<p>However, the use of <code>partial</code> is restricted to functions whose return type is not empty so the soundness
of the system is not compromised.</p>
<pre><code class="language-lean ignore">partial def loop? : α := -- failed to compile partial definition 'loop?', failed to
  loop?                  -- show that type is inhabited and non empty

partial def loop [Inhabited α] : α := -- compiles
  loop

example : True := -- accepted
  loop

example : False :=
  loop -- failed to synthesize instance Inhabited False
</code></pre>
<p>If we were able to partially define <code>loop?</code>, we could prove <code>False</code> with it.</p>
<h1 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda expressions</a></h1>
<p>A lambda expression is an unnamed function.
You define lambda expressions by using the <code>fun</code> keyword. A lambda expression resembles a function definition, except that instead of the <code>:=</code> token,
the <code>=&gt;</code> token is used to separate the argument list from the function body. As in a regular function definition,
the argument types can be inferred or specified explicitly, and the return type of the lambda expression is inferred from the type of the
last expression in the body.</p>
<pre><code class="language-lean">def twice (f : Nat -&gt; Nat) (x : Nat) : Nat :=
  f (f x)

#eval twice (fun x =&gt; x + 1) 3
#eval twice (fun (x : Nat) =&gt; x * 2) 3

#eval List.map (fun x =&gt; x + 1) [1, 2, 3]
-- [2, 3, 4]

#eval List.map (fun (x, y) =&gt; x + y) [(1, 2), (3, 4)]
-- [3, 7]
</code></pre>
<h1 id="syntax-sugar-for-simple-lambda-expressions"><a class="header" href="#syntax-sugar-for-simple-lambda-expressions">Syntax sugar for simple lambda expressions</a></h1>
<p>Simple functions can be defined using parentheses and <code>·</code> as a placeholder.</p>
<pre><code class="language-lean">#check (· + 1)
-- fun a =&gt; a + 1
#check (2 - ·)
-- fun a =&gt; 2 - a
#eval [1, 2, 3, 4, 5].foldl (· * ·) 1
-- 120

def h (x y z : Nat) :=
  x + y + z

#check (h · 1 ·)
-- fun a b =&gt; h a 1 b

#eval [(1, 2), (3, 4), (5, 6)].map (·.1)
-- [1, 3, 5]
</code></pre>
<p>In the previous example, the term <code>(·.1)</code> is syntax sugar for <code>fun x =&gt; x.1</code>.</p>
<h1 id="pipelining"><a class="header" href="#pipelining">Pipelining</a></h1>
<p>Pipelining enables function calls to be chained together as successive operations. Pipelining works as follows:</p>
<pre><code class="language-lean">def add1 x := x + 1
def times2 x := x * 2

#eval times2 (add1 100)
#eval 100 |&gt; add1 |&gt; times2
#eval times2 &lt;| add1 &lt;| 100
</code></pre>
<p>The result of the previous <code>#eval</code> commands is 202.
The forward pipeline <code>|&gt;</code> operator takes a function and an argument and return a value.
In contrast, the backward pipeline <code>&lt;|</code> operator takes an argument and a function and returns a value.
These operators are useful for minimizing the number of parentheses.</p>
<pre><code class="language-lean">def add1Times3FilterEven (xs : List Nat) :=
  List.filter (· % 2 == 0) (List.map (· * 3) (List.map (· + 1) xs))

#eval add1Times3FilterEven [1, 2, 3, 4]
-- [6, 12]

-- Define the same function using pipes
def add1Times3FilterEven' (xs : List Nat) :=
  xs |&gt; List.map (· + 1) |&gt; List.map (· * 3) |&gt; List.filter (· % 2 == 0)

#eval add1Times3FilterEven' [1, 2, 3, 4]
-- [6, 12]
</code></pre>
<p>Lean also supports the operator <code>|&gt;.</code> which combines forward pipeline <code>|&gt;</code> operator with the <code>.</code> field notation.</p>
<pre><code class="language-lean">-- Define the same function using pipes
def add1Times3FilterEven'' (xs : List Nat) :=
  xs.map (· + 1) |&gt;.map (· * 3) |&gt;.filter (· % 2 == 0)

#eval add1Times3FilterEven'' [1, 2, 3, 4]
-- [6, 12]
</code></pre>
<p>For users familiar with the Haskell programming language,
Lean also supports the notation <code>f $ a</code> for the backward pipeline <code>f &lt;| a</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monads-1"><a class="header" href="#monads-1">Monads</a></h1>
<p>Monads are used heavily in Lean, as they are also in Haskell. Monads come from the wonderful world
of <a href="https://en.wikipedia.org/wiki/Monad_%28category_theory%29">Category Theory</a>.</p>
<p>Monads in Lean are so similar to Haskell that this introduction to monads is heavily based on the
similar chapter of the <a href="https://mmhaskell.com/monads/">Monday Morning Haskell</a>. Many thanks to
the authors of that material for allowing us to reuse it here.</p>
<p>Monads build on the following fundamental type classes which you will need to understand
first before fully understanding monads. Shown in light blue are some concrete functors
and monads that will also be covered in this chapter:</p>
<p><img src="monads/../images/monads.svg" alt="image" /></p>
<p>This chapter is organized to give you a bottom up introduction to monads, starting with functors and
applicative functors, you'll get an intuition for how these abstract structures work in Lean. Then
you'll dive into monads and learn how to use some of the most useful built-in ones.</p>
<h2 id="functor"><a class="header" href="#functor"><a href="monads/functors.lean.html">Functor</a></a></h2>
<p>A functor is a type class that provides a map function and the map function is something many
people are already familiar with so this should be easy to follow.  Here you will see some
concrete examples in action with <code>List</code> and <code>Option</code>.</p>
<h2 id="applicative-functors"><a class="header" href="#applicative-functors"><a href="monads/applicatives.lean.html">Applicative Functors</a></a></h2>
<p>Applicatives are a little more difficult to understand than functors, but their functionality can
still be summed up in a couple simple functions.  Here you will learn how to create an
<code>Applicative List</code> and a completely custom <code>Applicative</code> type.</p>
<h2 id="monads-tutorial"><a class="header" href="#monads-tutorial"><a href="monads/monads.lean.html">Monads Tutorial</a></a></h2>
<p>Now that you have an intuition for how abstract structures work, you'll examine some of the problems
that functors and applicative functors don't help you solve. Then you'll learn the specifics of how
to actually use monads with some examples using the <code>Option</code> monad and the all important <code>IO</code> monad.</p>
<h2 id="reader-monad"><a class="header" href="#reader-monad"><a href="monads/readers.lean.html">Reader Monad</a></a></h2>
<p>Now that you understand the details of what makes a monadic structure work, in this section, you'll
learn about one of the most useful built in monads <code>ReaderM</code>, which gives your programs a
global read-only context.</p>
<h2 id="state-monad"><a class="header" href="#state-monad"><a href="monads/states.lean.html">State Monad</a></a></h2>
<p>This section introduces the <code>StateM</code> monad. This monad allows you to access a particular type that you can
both read from and write to. It opens the door to fully stateful programming, allowing you to do many
of the things a function programming language supposedly &quot;can't&quot; do.</p>
<h2 id="except-monad"><a class="header" href="#except-monad"><a href="monads/except.lean.html">Except Monad</a></a></h2>
<p>Similar to the <code>Option</code> monad the <code>Except</code> monad allows you to change the signature of a function so
that it can return an <code>ok</code> value or an <code>error</code> and it provides the classic exception handling
operations <code>throw/try/catch</code> so that your programs can do monad-based exception handling.</p>
<h2 id="monad-transformers"><a class="header" href="#monad-transformers"><a href="monads/transformers.lean.html">Monad Transformers</a></a></h2>
<p>Now that you are familiar with all the above monads it is time to answer the question - how you can
make them work together? After all, there are definitely times when you need multiple kinds of
monadic behavior. This section introduces the concept of monad transformers, which allow you to
combine multiple monads into one.</p>
<h2 id="monad-laws"><a class="header" href="#monad-laws"><a href="monads/laws.lean.html">Monad Laws</a></a></h2>
<p>This section examines what makes a monad a legal monad. You could just implement your monadic type
classes any way you want and write &quot;monad&quot; instances, but starting back with functors and
applicative functors, you'll learn that all these structures have &quot;laws&quot; that they are expected to
obey with respect to their behavior. You can make instances that don't follow these laws. But you do
so at your peril, as other programmers will be very confused when they try to use them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functor-1"><a class="header" href="#functor-1">Functor</a></h1>
<p>A <code>Functor</code> is any type that can act as a generic container that allows you to transform the
underlying values inside the container using a function, so that the values are all updated, but the
structure of the container is the same. This is called &quot;mapping&quot;.</p>
<p>A List is one of the most basic examples of a <code>Functor</code>.</p>
<p>A list contains zero or more elements of the same, underlying type.  When you <code>map</code> a function over
a list, you create a new list with the same number of elements, where each has been transformed by
the function:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="s2">&quot;1&quot;</span>, <span class="s2">&quot;2&quot;</span>, <span class="s2">&quot;3&quot;</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.map</var><b>: </b><span>{α β : Type} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div>List.map</span><span class="alectryon-token"> (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] <span class="c1">-- [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span>

<span class="c1">-- you can also write this using dot notation on the List object</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="s2">&quot;1&quot;</span>, <span class="s2">&quot;2&quot;</span>, <span class="s2">&quot;3&quot;</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)  <span class="c1">-- [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span></span></pre>
<p>Here we converted a list of natural numbers (Nat) to a list of strings where the lambda function
here used <code>toString</code> to do the transformation of each element. Notice that when you apply <code>map</code> the
&quot;structure&quot; of the object remains the same, in this case the result is always a <code>List</code> of the same
size.</p>
<p>Note that in Lean a lambda function can be written using <code>fun</code> keyword or the unicode
symbol <code>λ</code> which you can type in VS code using <code>\la </code>.</p>
<p>List has a specialized version of <code>map</code> defined as follows:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α : Type u_1} → {β : Type u_2} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div><span class="nv">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_2</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_2 → Type u_2</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_2</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
  <span class="bp">|</span> []    <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List β</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">::</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α : Type u_1} → {β : Type u_2} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div><span class="nv">map</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"></span></span></pre>
<p>This is a very generic <code>map</code> function that can take any function that converts <code>(α → β)</code> and use it
to convert <code>List α → List β</code>. Notice the function call <code>f a</code> above, this application of <code>f</code> is
producing the converted items for the new list.</p>
<p>Let's look at some more examples:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="c1">-- List String → List Nat</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">8</span>, <span class="mi">5</span>, <span class="mi">7</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;elephant&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;elephant&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;tiger&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;tiger&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;giraffe&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;giraffe&quot;</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">)
<span class="c1">-- [8, 5, 7]</span>

<span class="c1">-- List Nat → List Float</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk3"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">1</span><span class="bp">.</span><span class="mi">000000</span>, <span class="mi">8</span><span class="bp">.</span><span class="mi">000000</span>, <span class="mi">27</span><span class="bp">.</span><span class="mi">000000</span>, <span class="mi">64</span><span class="bp">.</span><span class="mi">000000</span>, <span class="mi">125</span><span class="bp">.</span><span class="mi">000000</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toFloat</var><b>: </b><span>Nat → Float</span></span></div></blockquote></div></small></div>toFloat</span><span class="alectryon-token">) <span class="bp">^</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3.0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">3</span><span class="bp">.</span><span class="mi">0</span></span><span class="alectryon-token">)
<span class="c1">-- [1.000000, 8.000000, 27.000000, 64.000000, 125.000000]</span>

<span class="c1">--- List String → List String</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="s2">&quot;Chris&quot;</span>, <span class="s2">&quot;David&quot;</span>, <span class="s2">&quot;Mark&quot;</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;chris&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;chris&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;david&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;david&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;mark&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;mark&quot;</span></span><span class="alectryon-token">]<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>capitalize</var><b>: </b><span>String → String</span></span></div></blockquote></div></small></div>capitalize</span><span class="alectryon-token">)
<span class="c1">-- [&quot;Chris&quot;, &quot;David&quot;, &quot;Mark&quot;]</span></span></span></pre>
<p>Another example of a functor is the <code>Option</code> type. Option contains a value or nothing and is handy
for code that has to deal with optional values, like optional command line arguments.</p>
<p>Remember you can construct an Option using the type constructors <code>some</code> or <code>none</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk5"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">5</span> : Option Nat</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> <span class="c1">-- Option Nat</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">5</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">  <span class="c1">-- some 5</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk7"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">6</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) <span class="c1">-- some 6</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk8"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="s2">&quot;5&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="c1">-- some &quot;5&quot;</span></span></span></pre>
<p>Lean also provides a convenient short hand syntax for <code>(fun x =&gt; x + 1)</code>, namely <code>(· + 1)</code>
using the middle dot unicode character which you can type in VS code using <code>\. </code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk9"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">20</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· * 5)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">*</span> <span class="mi">5</span>)</span><span class="alectryon-token">  <span class="c1">-- some 20</span></span></span></pre>
<p>The <code>map</code> function preserves the <code>none</code> state of the Option, so again
map preserves the structure of the object.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chka"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">none
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div>map</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="c1">-- none</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chkb"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Option.map (<span class="k">fun</span> x <span class="bp">=&gt;</span> toString x) x : Option String</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div>map</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) <span class="c1">-- Option String</span></span></span></pre>
<p>Notice that even in the <code>none</code> case it has transformed <code>Option Nat</code> into <code>Option String</code> as
you see in the <code>#check</code> command.</p>
<h2 id="how-to-make-a-functor-instance"><a class="header" href="#how-to-make-a-functor-instance">How to make a Functor Instance?</a></h2>
<p>The <code>List</code> type is made an official <code>Functor</code> by the following type class instance:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Functor List</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  map := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.map</var><b>: </b><span>{α β : Type u_1} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div>List.map</span><span class="alectryon-token"></span></span></pre>
<p>Notice all you need to do is provide the <code>map</code> function implementation.  For a quick
example, let's supposed you create a new type describing the measurements of a home
or apartment:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>totalSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>totalSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numBedrooms</var><b>: </b><span>{α : Type} → LivingSpace α → Nat</span></span></div></blockquote></div></small></div>numBedrooms</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>masterBedroomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>masterBedroomSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>livingRoomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>livingRoomSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>kitchenSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>kitchenSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BEq</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>BEq</span><span class="alectryon-token"></span></span></pre>
<p>Now you can construct a <code>LivingSpace</code> in square feet using floating point values:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>SquareFeet</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">SquareFeet</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mySpace</var><b>: </b><span>LivingSpace SquareFeet</span></span></div></blockquote></div></small></div><span class="nv">mySpace</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>SquareFeet</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>SquareFeet</span><span class="alectryon-token"> :=
  { totalSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1800</var><b>: </b><span>SquareFeet</span></span></div></blockquote></div></small></div><span class="mi">1800</span></span><span class="alectryon-token">, numBedrooms := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, masterBedroomSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>500</var><b>: </b><span>SquareFeet</span></span></div></blockquote></div></small></div><span class="mi">500</span></span><span class="alectryon-token">,
    livingRoomSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>900</var><b>: </b><span>SquareFeet</span></span></div></blockquote></div></small></div><span class="mi">900</span></span><span class="alectryon-token">, kitchenSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>400</var><b>: </b><span>SquareFeet</span></span></div></blockquote></div></small></div><span class="mi">400</span></span><span class="alectryon-token"> }</span></span></pre>
<p>Now, suppose you want anyone to be able to map a <code>LivingSpace</code> from one type of measurement unit to
another.  Then you would provide a <code>Functor</code> instance as follows:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace.map</var><b>: </b><span>{α β : Type} → (α → β) → LivingSpace α → LivingSpace β</span></span></div></blockquote></div></small></div><span class="nv">LivingSpace.map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  { totalSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>totalSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>totalSize</span><span class="alectryon-token">
    numBedrooms := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numBedrooms</var><b>: </b><span>{α : Type} → LivingSpace α → Nat</span></span></div></blockquote></div></small></div>numBedrooms</span><span class="alectryon-token">
    masterBedroomSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>masterBedroomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>masterBedroomSize</span><span class="alectryon-token">
    livingRoomSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>livingRoomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>livingRoomSize</span><span class="alectryon-token">
    kitchenSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>kitchenSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>kitchenSize</span><span class="alectryon-token"> }

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Functor LivingSpace</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  map := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace.map</var><b>: </b><span>{α β : Type} → (α → β) → LivingSpace α → LivingSpace β</span></span></div></blockquote></div></small></div>LivingSpace.map</span><span class="alectryon-token"></span></span></pre>
<p>Notice this functor instance takes <code>LivingSpace</code> and not the fully qualified type <code>LivingSpace SquareFeet</code>.
Notice below that <code>LivingSpace</code> is a function from Type to Type.  For example, if you give it type <code>SquareFeet</code>
it gives you back the fully qualified type <code>LivingSpace SquareFeet</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chkc"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">LivingSpace (α : <span class="kt">Type</span>) : <span class="kt">Type</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> <span class="c1">-- Type → Type</span></span></span></pre>
<p>So the <code>instance : Functor</code> then is operating on the more abstract, or generic <code>LivingSpace</code> saying
for the whole family of types <code>LivingSpace α</code> you can map to <code>LivingSpace β</code> using the generic
<code>LivingSpace.map</code> map function by simply providing a function that does the more primitive mapping
from <code>(f : α → β)</code>.  So <code>LivingSpace.map</code> is a sort of function applicator.
This is called a &quot;higher order function&quot; because it takes a function as input
<code>(α → β)</code> and returns another function as output <code>F α → F β</code>.</p>
<p>Notice that <code>LivingSpace.map</code> applies a function <code>f</code> to convert the units of all the LivingSpace
fields, except for <code>numBedrooms</code> which is a count (and therefore is not a measurement that needs
converting).</p>
<p>So now you can define a simple conversion function, let's say you want square meters instead:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>SquareMeters</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">SquareMeters</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squareFeetToMeters</var><b>: </b><span>SquareFeet → SquareMeters</span></span></div></blockquote></div></small></div><span class="nv">squareFeetToMeters</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ft</var><b>: </b><span>SquareFeet</span></span></div></blockquote></div></small></div><span class="nv">ft</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>SquareFeet</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>SquareFeet</span><span class="alectryon-token"> ) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>SquareMeters</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>SquareMeters</span><span class="alectryon-token"> := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ft</var><b>: </b><span>SquareFeet</span></span></div></blockquote></div></small></div><span class="nv">ft</span></span><span class="alectryon-token"> <span class="bp">/</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10.7639104</var><b>: </b><span>SquareMeters</span></span></div></blockquote></div></small></div><span class="mi">10</span><span class="bp">.</span><span class="mi">7639104</span></span><span class="alectryon-token">)</span></span></pre>
<p>and now bringing it all together you can use the simple function <code>squareFeetToMeters</code> to map
<code>mySpace</code> to square meters:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chkd"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{ totalSize := <span class="mi">167</span><span class="bp">.</span><span class="mi">225472</span>,
  numBedrooms := <span class="mi">4</span>,
  masterBedroomSize := <span class="mi">46</span><span class="bp">.</span><span class="mi">451520</span>,
  livingRoomSize := <span class="mi">83</span><span class="bp">.</span><span class="mi">612736</span>,
  kitchenSize := <span class="mi">37</span><span class="bp">.</span><span class="mi">161216</span> }
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>mySpace</var><b>: </b><span>LivingSpace SquareFeet</span></span></div></blockquote></div></small></div>mySpace</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → LivingSpace α → LivingSpace β</span></span></div></blockquote></div></small></div>map</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>squareFeetToMeters</var><b>: </b><span>SquareFeet → SquareMeters</span></span></div></blockquote></div></small></div>squareFeetToMeters</span><span class="alectryon-token">
<span class="c">/-</span>
<span class="cm">{ totalSize := 167.225472,</span>
<span class="cm">  numBedrooms := 4,</span>
<span class="cm">  masterBedroomSize := 46.451520,</span>
<span class="cm">  livingRoomSize := 83.612736,</span>
<span class="cm">  kitchenSize := 37.161216 }</span>
<span class="cm">  -/</span></span></span></pre>
<p>Lean also defines custom infix operator <code>&lt;$&gt;</code> for <code>Functor.map</code> which allows you to write this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chke"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">8</span>, <span class="mi">5</span>, <span class="mi">7</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;elephant&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;elephant&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;tiger&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;tiger&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;giraffe&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;giraffe&quot;</span></span><span class="alectryon-token">] <span class="c1">-- [8, 5, 7]</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chkf"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">6</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">) <span class="c1">-- some 6</span></span></span></pre>
<p>Note that the infix operator is left associative which means it binds more tightly to the
function on the left than to the expression on the right, this means you can often drop the
parentheses on the right like this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk10"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">6</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> <span class="c1">-- some 6</span></span></span></pre>
<p>Note that Lean lets you define your own syntax, so <code>&lt;$&gt;</code> is nothing special.
You can define your own infix operator like this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">infixr</span></span><span class="alectryon-token">:<span class="mi">100</span> <span class="s2">&quot; doodle &quot;</span> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor.map</var><b>: </b><span>{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β</span></span></div></blockquote></div></small></div>Functor.map</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="functors-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="functors-lean-chk11"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">5</span>, <span class="mi">10</span>, <span class="mi">15</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· * 5)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">*</span> <span class="mi">5</span>)</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">doodle</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]  <span class="c1">-- [5, 10, 15]</span></span></span></pre>
<p>Wow, this is pretty powerful.  By providing a functor instance on <code>LivingSpace</code> with an
implementation of the <code>map</code> function it is now super easy for anyone to come along and
transform the units of a <code>LivingSpace</code> using very simple functions like <code>squareFeetToMeters</code>. Notice
that squareFeetToMeters knows nothing about <code>LivingSpace</code>.</p>
<h2 id="how-do-functors-help-with-monads-"><a class="header" href="#how-do-functors-help-with-monads-">How do Functors help with Monads ?</a></h2>
<p>Functors are an abstract mathematical structure that is represented in Lean with a type class. The
Lean functor defines both <code>map</code> and a special case for working on constants more efficiently called
<code>mapConst</code>:</p>
<pre><code class="language-lean">class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
  mapConst : {α β : Type u} → α → f β → f α
</code></pre>
<p>Note that <code>mapConst</code> has a default implementation, namely:
<code>mapConst : {α β : Type u} → α → f β → f α := Function.comp map (Function.const _)</code> in the <code>Functor</code>
type class.  So you can use this default implementation and you only need to replace it if
your functor has a more specialized variant than this (usually the custom version is more performant).</p>
<p>In general then, a functor is a function on types <code>F : Type u → Type v</code> equipped with an operator
called <code>map</code> such that if you have a function <code>f</code> of type <code>α → β</code> then <code>map f</code> will convert your
container type from <code>F α → F β</code>. This corresponds to the category-theory notion of
<a href="https://en.wikipedia.org/wiki/Functor">functor</a> in the special case where the category is the
category of types and functions between them.</p>
<p>Understanding abstract mathematical structures is a little tricky for most people. So it helps to
start with a simpler idea like functors before you try to understand monads.  Building on
functors is the next abstraction called <a href="monads/applicatives.lean.html">Applicatives</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applicative-functors-1"><a class="header" href="#applicative-functors-1">Applicative Functors</a></h1>
<p>Building on <a href="monads/functors.lean.html">Functors</a> is the <a href="https://en.wikipedia.org/wiki/Applicative_functor">Applicative
Functor</a>. For simplicity, you can refer to these
simply as &quot;Applicatives&quot;. These are a little tricker than functors, but still simpler than monads.
Let's see how they work!</p>
<h2 id="what-is-an-applicative-functor"><a class="header" href="#what-is-an-applicative-functor">What is an Applicative Functor?</a></h2>
<p>An applicative functor defines a default or &quot;base&quot; construction for an object and allows
function application to be chained across multiple instances of the structure. All applicative
functors are functors, meaning they must also support the &quot;map&quot; operation.</p>
<h2 id="how-are-applicatives-represented-in-lean"><a class="header" href="#how-are-applicatives-represented-in-lean">How are Applicatives represented in Lean?</a></h2>
<p>An <a href="https://en.wikipedia.org/wiki/Applicative_functor">applicative functor</a> is an intermediate
structure between <code>Functor</code> and <code>Monad</code>. It mainly consists of two operations:</p>
<ul>
<li><code>pure : α → F α</code></li>
<li><code>seq : F (α → β) → F α → F β</code> (written as <code>&lt;*&gt;</code>)</li>
</ul>
<p>The <code>pure</code> operator specifies how you can wrap a normal object <code>α</code> into an instance of this structure <code>F α</code>.
This is the &quot;default&quot; mechanism mentioned above.</p>
<p>The <code>seq</code> operator allows you to chain operations by wrapping a function in a structure. The name
&quot;applicative&quot; comes from the fact that you &quot;apply&quot; functions from within the structure, rather than
simply from outside the structure, as was the case with <code>Functor.map</code>.</p>
<p>Applicative in Lean is built on some helper type classes, <code>Functor</code>, <code>Pure</code> and <code>Seq</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">namespace</span></span><span class="alectryon-token"> hidden <span class="c1">-- hidden</span>
</span><span class="alectryon-token"><span class="kd">class</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type v</var><b>: </b><span>Type (v + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> v</span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="kd">extends</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Pure</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>Pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Seq</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>Seq</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>SeqLeft</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>SeqLeft</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>SeqRight</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>SeqRight</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  map      := </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>f α✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Seq.seq</var><b>: </b><span>{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β</span></span></div></blockquote></div></small></div>Seq.seq</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{α : Type u} → α → f α</span></span></div></blockquote></div></small></div><span class="nv">pure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>f α✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">
  seqLeft  := </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>f α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → f β✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Seq.seq</var><b>: </b><span>{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β</span></span></div></blockquote></div></small></div>Seq.seq</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor.map</var><b>: </b><span>{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β</span></span></div></blockquote></div></small></div>Functor.map</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Function.const</var><b>: </b><span>{α : Type u} → (β : Type u) → α → β → α</span></span></div></blockquote></div></small></div>Function.const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>f α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → f β✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">
  seqRight := </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>f α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → f β✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Seq.seq</var><b>: </b><span>{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β</span></span></div></blockquote></div></small></div>Seq.seq</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor.map</var><b>: </b><span>{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β</span></span></div></blockquote></div></small></div>Functor.map</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Function.const</var><b>: </b><span>{α : Type u} → (β : Type u) → α → β → α</span></span></div></blockquote></div></small></div>Function.const</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type u} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>f α✝</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>Unit → f β✝</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">end</span></span><span class="alectryon-token"> hidden <span class="c1">-- hidden</span></span></span></pre>
<p>Notice that as with <code>Functor</code> it is also a type transformer <code>(f : Type u → Type v)</code> and notice the
<code>extends Functor f</code> is ensuring the base <code>Functor</code> also performs that same type transformation.</p>
<p>As stated above, all applicatives are then functors. This means you can assume that <code>map</code> already
exists for all these types.</p>
<p>The <code>Pure</code> base type class is a very simple type class that supplies the <code>pure</code> function.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">namespace</span></span><span class="alectryon-token"> hidden <span class="c1">-- hidden</span>
</span><span class="alectryon-token"><span class="kd">class</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Pure</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>Pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type v</var><b>: </b><span>Type (v + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> v</span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u → Type v} → [self : Pure f] → {α : Type u} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">} : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">end</span></span><span class="alectryon-token"> hidden <span class="c1">-- hidden</span></span></span></pre>
<p>You can think of it as lifting the result of a pure value to some monadic type. The simplest example
of <code>pure</code> is the <code>Option</code> type:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">10</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">)  <span class="c1">-- some 10</span></span></span></pre>
<p>Here we used the <code>Option</code> implementation of <code>pure</code> to wrap the <code>Nat 10</code> value in an <code>Option Nat</code>
type resulting in the value <code>some 10</code>, and in fact if you look at the Monad instance of <code>Option</code> , you
will see that <code>pure</code> is indeed implemented using <code>Option.some</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Monad Option</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
    pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option.some</var><b>: </b><span>{α : Type u_1} → α → Option α</span></span></div></blockquote></div></small></div>Option.some</span><span class="alectryon-token"></span></span></pre>
<p>The <code>Seq</code> type class is also a simple type class that provides the <code>seq</code> operator which can
also be written using the special syntax <code>&lt;*&gt;</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">namespace</span></span><span class="alectryon-token"> hidden <span class="c1">-- hidden</span>
</span><span class="alectryon-token"><span class="kd">class</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Seq</var><b>: </b><span>(Type u → Type v) → Type (max (u + 1) v)</span></span></div></blockquote></div></small></div>Seq</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type v</var><b>: </b><span>Type (v + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> v</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type (max (u+1) v)</var><b>: </b><span>Type ((max (u + 1) v) + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> (max (u<span class="bp">+</span><span class="mi">1</span>) v)</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>seq</var><b>: </b><span>{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β</span></span></div></blockquote></div></small></div>seq</span><span class="alectryon-token"> : {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">} <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) <span class="bp">→</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Type u → Type v</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">end</span></span><span class="alectryon-token"> hidden <span class="c1">-- hidden</span></span></span></pre>
<h2 id="basic-applicative-examples"><a class="header" href="#basic-applicative-examples">Basic Applicative Examples</a></h2>
<p>Many of the basic functors also have instances of <code>Applicative</code>.
For example, <code>Option</code> is also <code>Applicative</code>.</p>
<p>So let's take a look and what the <code>seq</code> operator can do.  Suppose you want to multiply two <code>Option Nat</code>
objects.  Your first attempt might be this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk1"><span class="alectryon-token"><span class="bp">#</span>check_failure</span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">4</span> <span class="bp">*</span> some <span class="mi">5</span> : <span class="bp">?</span>m.637</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk2"><span class="alectryon-token">(</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">) <span class="bp">*</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">4</span> <span class="bp">*</span> some <span class="mi">5</span> : <span class="bp">?</span>m.637</blockquote><blockquote class="alectryon-message">Warning: failed to synthesize <span class="kd">instance</span>
  HMul (Option Nat) (Option Nat) <span class="bp">?</span>m.637</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">      <span class="c1">-- failed to synthesize instance</span></span></span></pre>
<p>You then might wonder how to use the <code>Functor.map</code> to solve this since you could do these before:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk3"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">20</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">)  <span class="c1">-- some 20</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">20</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α β : Type} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div><span class="na">map</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· * 5)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">*</span> <span class="mi">5</span>)</span><span class="alectryon-token">  <span class="c1">-- some 20</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk5"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">20</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· * 5)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">*</span> <span class="mi">5</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">)   <span class="c1">-- some 20</span></span></span></pre>
<p>Remember that <code>&lt;$&gt;</code> is the infix notation for <code>Functor.map</code>.</p>
<p>The functor <code>map</code> operation can apply a multiplication to the value in the <code>Option</code> and then lift the
result back up to become a new <code>Option</code> , but this isn't what you need here.</p>
<p>The <code>Seq.seq</code> operator <code>&lt;*&gt;</code> can help since it can apply a function to the items inside a
container and then lift the result back up to the desired type, namely <code>Option</code> .</p>
<p>There are two ways to do this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">20</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(.*.)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">.*.</span>)</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> <span class="c1">-- some 20</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk7"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">20</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(.*.)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">.*.</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> <span class="c1">-- some 20</span></span></span></pre>
<p>In the first way, we start off by wrapping the function in an applicative using pure. Then we apply
this to the first <code>Option</code> , and again to the second <code>Option</code>  in a chain of operations.  So  you can see
how <code>Seq.seq</code> can be chained in fact, <code>Seq.seq</code> is really all about chaining of operations.</p>
<p>But in this case there is a simpler way.  In the second way, you can see that &quot;applying&quot; a single
function to a container is the same as using <code>Functor.map</code>. So you use <code>&lt;$&gt;</code> to &quot;transform&quot; the first
option into an <code>Option</code> containing a function, and then apply this function over the second value.</p>
<p>Now if either side is <code>none</code>, the result is <code>none</code>, as expected, and in this case the
<code>seq</code> operator was able to eliminate the multiplication:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk8"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">none
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(.*.)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">.*.</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">  <span class="c1">-- none</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk9"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">none
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(.*.)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">.*.</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">  <span class="c1">-- none</span></span></span></pre>
<p>For a more interesting example, let's make <code>List</code> an applicative by adding the following
definition:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Applicative List</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.pure</var><b>: </b><span>{α : Type u_1} → α → List α</span></span></div></blockquote></div></small></div>List.pure</span><span class="alectryon-token">
  seq </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>List (α✝ → β✝)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Unit → List α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.bind</var><b>: </b><span>{α β : Type u_1} → List α → (α → List β) → List β</span></span></div></blockquote></div></small></div>List.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>List (α✝ → β✝)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor.map</var><b>: </b><span>{f : Type u_1 → Type u_1} → [self : Functor f] → {α β : Type u_1} → (α → β) → f α → f β</span></span></div></blockquote></div></small></div>Functor.map</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Unit → List α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)</span></span></pre>
<p>Notice you can now sequence a <em>list</em> of functions and a <em>list</em> of items.
The trivial case of sequencing a singleton list is in fact the same as <code>map</code>, as you saw
earlier with the <code>Option</code>  examples:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chka"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">6</span>, <span class="mi">8</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [ </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+</span><span class="mi">2</span>)</span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">] <span class="c1">-- [6, 8]</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chkb"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">6</span>, <span class="mi">8</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+</span><span class="mi">2</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]    <span class="c1">-- [6, 8]</span></span></span></pre>
<p>But now with list it is easier to show the difference when you do this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chkc"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">6</span>, <span class="mi">8</span>, <span class="mi">12</span>, <span class="mi">18</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+</span><span class="mi">2</span>)</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· *3)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">*</span><span class="mi">3</span>)</span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">] <span class="c1">-- [6, 8, 12, 18]</span></span></span></pre>
<p>Why did this produce 4 values?  The reason is because <code>&lt;*&gt;</code> applies <em>every</em> function to <em>every</em>
value in a pairwise manner.  This makes sequence really convenient for solving certain problems. For
example, how do you get the pairwise combinations of all values from two lists?</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chkd"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[(<span class="mi">1</span>, <span class="mi">4</span>), (<span class="mi">1</span>, <span class="mi">5</span>), (<span class="mi">1</span>, <span class="mi">6</span>), (<span class="mi">2</span>, <span class="mi">4</span>), (<span class="mi">2</span>, <span class="mi">5</span>), (<span class="mi">2</span>, <span class="mi">6</span>), (<span class="mi">3</span>, <span class="mi">4</span>), (<span class="mi">3</span>, <span class="mi">5</span>), (<span class="mi">3</span>, <span class="mi">6</span>)]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prod.mk</var><b>: </b><span>{α β : Type} → α → β → α × β</span></span></div></blockquote></div></small></div>Prod.mk</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]
<span class="c1">-- [(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]</span></span></span></pre>
<p>How do you get the sum of these pairwise values?</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chke"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">5</span>, <span class="mi">6</span>, <span class="mi">7</span>, <span class="mi">6</span>, <span class="mi">7</span>, <span class="mi">8</span>, <span class="mi">7</span>, <span class="mi">8</span>, <span class="mi">9</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]
<span class="c1">-- [5, 6, 7, 6, 7, 8, 7, 8, 9]</span></span></span></pre>
<p>Here you can use <code>&lt;$&gt;</code> to &quot;transform&quot; each element of the first list into a function, and then apply
these functions over the second list.</p>
<p>If you have 3 lists, and want to find all combinations of 3 values across those lists you
would need helper function that can create a tuple out of 3 values, and Lean provides a
very convenient syntax for that <code>(·,·,·)</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chkf"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[(<span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">5</span>), (<span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">6</span>), (<span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">5</span>), (<span class="mi">1</span>, <span class="mi">4</span>, <span class="mi">6</span>), (<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">5</span>), (<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">6</span>), (<span class="mi">2</span>, <span class="mi">4</span>, <span class="mi">5</span>), (<span class="mi">2</span>, <span class="mi">4</span>, <span class="mi">6</span>)]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·,·,·)</var><b>: </b><span>Nat → Nat → Nat → Nat × Nat × Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span>,<span class="bp">·</span>,<span class="bp">·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]
<span class="c1">-- [(1, 3, 5), (1, 3, 6), (1, 4, 5), (1, 4, 6), (2, 3, 5), (2, 3, 6), (2, 4, 5), (2, 4, 6)]</span></span></span></pre>
<p>And you could sum these combinations if you first define a sum function that takes three inputs and
then you could chain apply this over the three lists.  Again lean can create such a function
with the expression <code>(·+·+·)</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk10"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">9</span>, <span class="mi">10</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">11</span>, <span class="mi">12</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·+·)</var><b>: </b><span>Nat → Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">] <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]
<span class="c1">-- [9, 10, 10, 11, 10, 11, 11, 12]</span></span></span></pre>
<p>And indeed each sum here matches the expected values if you manually sum the triples we
show above.</p>
<p><strong>Side note:</strong> there is another way to combine lists with a function that does not do the pairwise
combinatorics, it is called <code>List.zipWith</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk11"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">5</span>, <span class="mi">7</span>, <span class="mi">9</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.zipWith</var><b>: </b><span>{α β γ : Type} → (α → β → γ) → List α → List β → List γ</span></span></div></blockquote></div></small></div>List.zipWith</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·</span>)</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]
<span class="c1">-- [5, 7, 9]</span></span></span></pre>
<p>And there is a helper function named <code>List.zip</code> that calls <code>zipWith</code> using the function <code>Prod.mk</code>
so you get a nice zipped list like this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk12"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[(<span class="mi">1</span>, <span class="mi">4</span>), (<span class="mi">2</span>, <span class="mi">5</span>), (<span class="mi">3</span>, <span class="mi">6</span>)]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.zip</var><b>: </b><span>{α β : Type} → List α → List β → List (α × β)</span></span></div></blockquote></div></small></div>List.zip</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]
<span class="c1">-- [(1, 4), (2, 5), (3, 6)]</span></span></span></pre>
<p>And of course, as you would expect, there is an <code>unzip</code> also:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk13"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">([<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>], [<span class="mi">4</span>, <span class="mi">5</span>, <span class="mi">6</span>])
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.unzip</var><b>: </b><span>{α β : Type} → List (α × β) → List α × List β</span></span></div></blockquote></div></small></div>List.unzip</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.zip</var><b>: </b><span>{α β : Type} → List α → List β → List (α × β)</span></span></div></blockquote></div></small></div>List.zip</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">])
<span class="c1">-- ([1, 2, 3], [4, 5, 6])</span></span></span></pre>
<h2 id="example-a-functor-that-is-not-applicative"><a class="header" href="#example-a-functor-that-is-not-applicative">Example: A Functor that is not Applicative</a></h2>
<p>From the chapter on <a href="monads/functors.lean.html">functors</a> you might remember this example of <code>LivingSpace</code>
that had a <code>Functor</code> instance:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>totalSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>totalSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numBedrooms</var><b>: </b><span>{α : Type} → LivingSpace α → Nat</span></span></div></blockquote></div></small></div>numBedrooms</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>masterBedroomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>masterBedroomSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>livingRoomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>livingRoomSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>kitchenSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>kitchenSize</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BEq</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>BEq</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace.map</var><b>: </b><span>{α β : Type} → (α → β) → LivingSpace α → LivingSpace β</span></span></div></blockquote></div></small></div><span class="nv">LivingSpace.map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  { totalSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>totalSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>totalSize</span><span class="alectryon-token">
    numBedrooms := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>numBedrooms</var><b>: </b><span>{α : Type} → LivingSpace α → Nat</span></span></div></blockquote></div></small></div>numBedrooms</span><span class="alectryon-token">
    masterBedroomSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>masterBedroomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>masterBedroomSize</span><span class="alectryon-token">
    livingRoomSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>livingRoomSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>livingRoomSize</span><span class="alectryon-token">
    kitchenSize := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>LivingSpace α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>kitchenSize</var><b>: </b><span>{α : Type} → LivingSpace α → α</span></span></div></blockquote></div></small></div>kitchenSize</span><span class="alectryon-token"> }

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Functor LivingSpace</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>LivingSpace</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  map := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LivingSpace.map</var><b>: </b><span>{α β : Type} → (α → β) → LivingSpace α → LivingSpace β</span></span></div></blockquote></div></small></div>LivingSpace.map</span><span class="alectryon-token"></span></span></pre>
<p>It wouldn't really make sense to make an <code>Applicative</code> instance here. How would you write <code>pure</code> in
the <code>Applicative</code> instance? By taking a single value and plugging it in for total size <em>and</em> the
master bedroom size <em>and</em> the living room size? That wouldn't really make sense. And what would the
numBedrooms value be for the default? What would it mean to &quot;chain&quot; two of these objects together?</p>
<p>If you can't answer these questions very well, then it suggests this type isn't really an
Applicative functor.</p>
<h2 id="seqleft-and-seqright"><a class="header" href="#seqleft-and-seqright">SeqLeft and SeqRight</a></h2>
<p>You may remember seeing the <code>SeqLeft</code> and <code>SeqRight</code> base types on <code>class Applicative</code> earlier.
These provide the <code>seqLeft</code> and <code>seqRight</code> operations which also have some handy notation
shorthands <code>&lt;*</code> and <code>*&gt;</code> respectively. Where: <code>x &lt;* y</code> evaluates <code>x</code>, then <code>y</code>, and returns the
result of <code>x</code> and <code>x *&gt; y</code> evaluates <code>x</code>, then <code>y</code>,  and returns the result of <code>y</code>.</p>
<p>To make it easier to remember, notice that it returns that value that the <code>&lt;*</code> or <code>*&gt;</code> notation is
pointing at.  For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk14"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">2</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) <span class="bp">*&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">) <span class="c1">-- Some 2</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk15"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">1</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) <span class="bp">&lt;*</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">) <span class="c1">-- Some 1</span></span></span></pre>
<p>So these are a kind of &quot;discard&quot; operation.  Run all the actions, but only return the values that you
care about. It will be easier to see these in action when you get to full Monads, but they are used
heavily in the Lean <code>Parsec</code> parser combinator library where you will find parsing functions like
this one which parses the XML declaration <code>&lt;?xml version=&quot;1.0&quot; encoding='utf-8' standalone=&quot;yes&quot;&gt;</code>:</p>
<pre><code class="language-lean">def XMLdecl : Parsec Unit := do
  skipString &quot;&lt;?xml&quot;
  VersionInfo
  optional EncodingDecl *&gt; optional SDDecl *&gt; optional S *&gt; skipString &quot;?&gt;&quot;
</code></pre>
<p>But you will need to understand full Monads before this will make sense.</p>
<h2 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h2>
<p>Diving a bit deeper, (you can skip this and jump to the <a href="monads/laws.lean.html#what-are-the-applicative-laws">Applicative
Laws</a> if don't want to dive into this implementation detail right
now). But, if you write a simple <code>Option</code> example <code>(.*.) &lt;$&gt; some 4 &lt;*&gt; some 5</code> that produces <code>some 20</code>
using <code>Seq.seq</code> you will see something interesting:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="applicatives-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="applicatives-lean-chk16"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">20</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Seq.seq</var><b>: </b><span>{f : Type → Type} → [self : Seq f] → {α β : Type} → f (α → β) → (Unit → f α) → f β</span></span></div></blockquote></div></small></div>Seq.seq</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(.*.)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">.*.</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">) <span class="c1">-- some 20</span></span></span></pre>
<p>This may look a bit cumbersome, specifically, why did we need to invent this funny looking function
<code>fun (_ : Unit) =&gt; (some 5)</code>?</p>
<p>Well if you take a close look at the type class definition:</p>
<pre><code class="language-lean">class Seq (f : Type u → Type v) where
  seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β
</code></pre>
<p>You will see this function defined here: <code>(Unit → f α)</code>, this is a function that takes <code>Unit</code> as input
and produces the output of type <code>f α</code> where <code>f</code> is the container type <code>Type u -&gt; Type v</code>, in this example <code>Option</code>
and <code>α</code> is the element type <code>Nat</code>, so <code>fun (_ : Unit) =&gt; some 5</code> matches this definition because
it is taking an input of type Unit and producing <code>some 5</code> which is type <code>Option Nat</code>.</p>
<p>The that <code>seq</code> is defined this way is because Lean is an eagerly evaluated language
(call-by-value), you have to use this kind of Unit function whenever you want to explicitly delay
evaluation and <code>seq</code> wants that so it can eliminate unnecessary function evaluations whenever
possible.</p>
<p>Fortunately the <code>&lt;*&gt;</code> infix notation hides this from you by creating this wrapper function for you.
If you look up the notation using F12 in VS Code you will find it contains <code>(fun _ : Unit =&gt; b)</code>.</p>
<p>Now to complete this picture you will find the default implementation of <code>seq</code> on the Lean <code>Monad</code>
type class:</p>
<pre><code class="language-lean">class Monad (m : Type u → Type v) extends Applicative m, Bind m where
  seq      f x := bind f fun y =&gt; Functor.map y (x ())
</code></pre>
<p>Notice here that <code>x</code> is the <code>(Unit → f α)</code> function, and it is calling that function by passing the
Unit value <code>()</code>, which is the Unit value (Unit.unit).  All this just to ensure delayed evaluation.</p>
<h2 id="how-do-applicatives-help-with-monads"><a class="header" href="#how-do-applicatives-help-with-monads">How do Applicatives help with Monads?</a></h2>
<p>Applicatives are helpful for the same reasons as functors. They're a relatively simple abstract
structure that has practical applications in your code. Now that you understand how chaining
operations can fit into a structure definition, you're in a good position to start learning about
<a href="monads/monads.lean.html">Monads</a>!</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="monads-2"><a class="header" href="#monads-2">Monads</a></h1>
<p>Building on <a href="monads/functors.lean.html">Functors</a> and <a href="monads/applicatives.lean.html">Applicatives</a> we can now
introduce <a href="https://en.wikipedia.org/wiki/Monad_%28category_theory%29">monads</a>.</p>
<p>A monad is another type of abstract, functional structure. Let's explore what makes it different
from the first two structures.</p>
<h2 id="what-is-a-monad"><a class="header" href="#what-is-a-monad">What is a Monad?</a></h2>
<p>A monad is a computational context. It provides a structure that allows you to chain together
operations that have some kind of shared state or similar effect. Whereas pure functional code can
only operate on explicit input parameters and affect the program through explicit return values,
operations in a monad can affect other computations in the chain implicitly through side effects,
especially modification of an implicitly shared value.</p>
<h2 id="how-are-monads-represented-in-lean"><a class="header" href="#how-are-monads-represented-in-lean">How are monads represented in Lean?</a></h2>
<p>Like functors and applicatives, monads are represented with a type class in Lean:</p>
<pre><code class="language-lean ignore">class Monad (m : Type u → Type v) extends Applicative m, Bind m where
</code></pre>
<p>Just as every applicative is a functor, every monad is also an applicative and there's one more new
base type class used here that you need to understand, namely, <code>Bind</code>.</p>
<pre><code class="language-lean ignore">class Bind (f : Type u → Type v) where
  bind : {α β : Type u} → f α → (α → f β) → f β
</code></pre>
<p>The <code>bind</code> operator also has infix notation <code>&gt;&gt;=</code> where <code>x &gt;&gt;= g</code> represents the result of executing
<code>x</code> to get a value of type <code>f α</code> then unwrapping the value <code>α</code> from that and passing it to function
<code>g</code> of type <code>α → f β</code> returning the result of type <code>f β</code> where <code>f</code> is the target structure type
(like <code>Option</code> or List)</p>
<p>This <code>bind</code> operation looks similar to the other ones you've seen so far, if you put them all
together <code>Monad</code> has the following operations:</p>
<pre><code class="language-lean ignore">class Monad (f : Type u → Type v) extends Applicative f, Bind f where
  pure {α : Type u} : α → f α
  map : {α β : Type u} → (α → β) → f α → f β
  seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β
  bind : {α β : Type u} → f α → (α → f β) → f β
  ...
</code></pre>
<p>Notice <code>Monad</code> also contains <code>pure</code> it must also have a &quot;default&quot; way to wrap a value in the
structure.</p>
<p>The <code>bind</code> operator is similar to the applicative <code>seq</code> operator in that it chains two operations,
with one of them being function related. Notice that <code>bind</code>, <code>seq</code> and <code>map</code> all take a function of
some kind.  Let's examine those function types:</p>
<ul>
<li>map: <code>(α → β)</code></li>
<li>seq: <code>f (α → β)</code></li>
<li>bind: <code>(α → f β)</code></li>
</ul>
<p>So <code>map</code> is a pure function, <code>seq</code> is a pure function wrapped in the structure, and <code>bind</code> takes a
pure input but produces an output wrapped in the structure.</p>
<p>Note: we are ignoring the <code>(Unit → f α)</code> function used by <code>seq</code> here since that has a special
purpose explained in <a href="monads/applicatives.lean.html#lazy-evaluation">Applicatives Lazy Evaluation</a>.</p>
<h2 id="basic-monad-example"><a class="header" href="#basic-monad-example">Basic Monad Example</a></h2>
<p>Just as <code>Option</code> is a functor and an applicative functor, it is also a monad! Let's start with how
<code>Option</code> implements the Monad type class.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Monad Option</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option.some</var><b>: </b><span>{α : Type u_1} → α → Option α</span></span></div></blockquote></div></small></div>Option.some</span><span class="alectryon-token">
  bind := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option.bind</var><b>: </b><span>{α β : Type u_1} → Option α → (α → Option β) → Option β</span></span></div></blockquote></div></small></div>Option.bind</span><span class="alectryon-token"></span></span></pre>
<p>where:</p>
<pre><code class="language-lean ignore">def Option.bind : Option α → (α → Option β) → Option β
  | none,   _ =&gt; none
  | some a, f =&gt; f a
</code></pre>
<blockquote>
<p><strong>Side note</strong>: this function definition is using a special shorthand syntax in Lean where the <code>:= match a, b with</code> code can be collapsed away. To make this more clear consider the following simpler
example, where <code>Option.bind</code> is using the second form like <code>bar</code>:</p>
</blockquote>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foo</var><b>: </b><span>Option Nat → Nat → Option Nat</span></span></div></blockquote></div></small></div><span class="nv">foo</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type ?u.141} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">, _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type ?u.159} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bar</var><b>: </b><span>Option Nat → Nat → Option Nat</span></span></div></blockquote></div></small></div><span class="nv">bar</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type ?u.304} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">, _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type ?u.322} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="monads-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="monads-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">3</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>foo</var><b>: </b><span>Option Nat → Nat → Option Nat</span></span></div></blockquote></div></small></div>foo</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">  <span class="c1">-- some 3</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="monads-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="monads-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">3</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bar</var><b>: </b><span>Option Nat → Nat → Option Nat</span></span></div></blockquote></div></small></div>bar</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">  <span class="c1">-- some 3</span></span></span></pre>
<p>What is important is that <code>Option.bind</code> is using a <code>match</code> statement to unwrap the input value
<code>Option α</code>, if it is <code>none</code> then it does nothing and returns <code>none</code>, if it has a value of type <code>α</code>
then it applies the function in the second argument <code>(α → Option β)</code> to this value, which is
the expression <code>f a</code> that you see in the line <code>  | some a, f =&gt; f a</code> above.  The function
returns a result of type <code>Option β</code> which then becomes the return value for <code>bind</code>.  So there
is no structure wrapping required on the return value since the input function already did that.</p>
<p>But let's bring in the definition of a monad. What does it mean to describe <code>Option</code> as a
computational context?</p>
<p>The <code>Option</code> monad encapsulates the context of failure. Essentially, the <code>Option</code> monad lets us
abort a series of operations whenever one of them fails. This allows future operations to assume
that all previous operations have succeeded. Here's some code to motivate this idea:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div><span class="nv">optionFunc1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> <span class="bp">-&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div><span class="nv">optionFunc2</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">%</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toFloat</var><b>: </b><span>Nat → Float</span></span></div></blockquote></div></small></div>toFloat</span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3.14159</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">3</span><span class="bp">.</span><span class="mi">14159</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">optionFunc3</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>15.0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">15</span><span class="bp">.</span><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>floor</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div>floor</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div>toUInt32</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div>toNat</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ceil</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div>ceil</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div>toUInt32</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div>toNat</span><span class="alectryon-token">]

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncs</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">runOptionFuncs</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div>optionFunc1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type ?u.904} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type ?u.915} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div>optionFunc2</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type ?u.931} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type ?u.941} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div>optionFunc3</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="monads-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="monads-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some [<span class="mi">9</span>, <span class="mi">10</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncs</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div>runOptionFuncs</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;big&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;big&quot;</span></span><span class="alectryon-token"> <span class="c1">-- some [9, 10]</span></span></span></pre>
<p>Here you see three different functions that could fail. These are then combined in <code>runOptionFuncs</code>.
But then you have to use nested <code>match</code> expressions to check if the previous result succeeded. It
would be very tedious to continue this pattern much longer.</p>
<p>The <code>Option</code> monad helps you fix this. Here's what this function looks like using the <code>bind</code>
operator.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBind</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">runOptionFuncsBind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div>optionFunc1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div>optionFunc2</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div>optionFunc3</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="monads-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="monads-lean-chk3"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some [<span class="mi">9</span>, <span class="mi">10</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBind</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div>runOptionFuncsBind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;big&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;big&quot;</span></span><span class="alectryon-token"> <span class="c1">-- some [9, 10]</span></span></span></pre>
<p>It's much cleaner now! You take the first result and pass it into the second and third functions
using the <code>bind</code> operation. The monad instance handles all the failure cases so you don't have to!</p>
<p>Let's see why the types work out. The result of <code>optionFunc1</code> input is simply <code>Option Nat</code>. Then the
bind operator allows you to take this <code>Option Nat</code> value and combine it with <code>optionFunc2</code>, whose type
is <code>Nat → Option Float</code> The <strong>bind operator resolves</strong> these to an <code>Option Float</code>. Then you pass this
similarly through the bind operator to <code>optionFunc3</code>, resulting in the final type, <code>Option (List Nat)</code>.</p>
<p>Your functions will not always combine so cleanly though. This is where <code>do</code> notation comes into play.
This notation allows you to write monadic operations one after another, line-by-line. It almost makes
your code look like imperative programming. You can rewrite the above as:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsDo</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">runOptionFuncsDo</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div>optionFunc1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div>optionFunc2</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div>optionFunc3</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="monads-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="monads-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some [<span class="mi">9</span>, <span class="mi">10</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsDo</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div>runOptionFuncsDo</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;big&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;big&quot;</span></span><span class="alectryon-token"> <span class="c1">-- some [9, 10]</span></span></span></pre>
<p>The <code>←</code> operator used here is special. It effectively unwraps the value on the right-hand side from
the monad. This means the value <code>i</code> has type <code>Nat</code>, <em>even though</em> the result of <code>optionFunc1</code> is
<code>Option Nat</code>. This is done using a <code>bind</code> operation under the hood.</p>
<blockquote>
<p>Note you can use <code>&lt;-</code> or the nice unicode symbol <code>←</code> which you can type into VS code by typing
these characters <code>\l </code>.  When you type the final space, <code>\l</code> is replaced with <code>←</code>.</p>
</blockquote>
<p>Observe that we do not unwrap the final line of the computation. The function result is <code>Option (List Nat)</code> which matches what <code>optionFunc3</code> returns. At first glance, this may look more complicated
than the <code>bind</code> example. However, it gives you a lot more flexibility, like mixing monadic and
non-monadic statements, using if then/else structures with their own local do blocks and so on. It
is particularly helpful when one monadic function depends on multiple previous functions.</p>
<h2 id="example-using-list"><a class="header" href="#example-using-list">Example using List</a></h2>
<p>You can easily make <code>List</code> into a monad with the following, since List already provides an
implementation of <code>pure</code> and <code>bind</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Monad List</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token">  </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.pure</var><b>: </b><span>{α : Type u_1} → α → List α</span></span></div></blockquote></div></small></div>List.pure</span><span class="alectryon-token">
  bind := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.bind</var><b>: </b><span>{α β : Type u_1} → List α → (α → List β) → List β</span></span></div></blockquote></div></small></div>List.bind</span><span class="alectryon-token"></span></span></pre>
<p>Like you saw with the applicative <code>seq</code> operator, the <code>bind</code> operator applies the given function
to every element of the list.  It is useful to look at the bind implementation for List:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> List
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{α : Type u_1} → {β : Type u_2} → List α → (α → List β) → List β</span></span></div></blockquote></div></small></div><span class="nv">bind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α → List β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_2 → Type u_2</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_2</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_2 → Type u_2</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_2</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>join</var><b>: </b><span>{α : Type u_2} → List (List α) → List α</span></span></div></blockquote></div></small></div>join</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>map</var><b>: </b><span>{α : Type u_1} → {β : Type u_2} → (α → β) → List α → List β</span></span></div></blockquote></div></small></div>map</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>α → List β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token">)</span></span></pre>
<p>So <code>Functor.map</code> is used to apply the function <code>b</code> to every element of <code>a</code> but this would
return a whole bunch of little lists, so <code>join</code> is used to turn those back into a single list.</p>
<p>Here's an example where you use <code>bind</code> to convert a list of strings into a combined list of chars:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="monads-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="monads-lean-chk5"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="sc">&#39;a&#39;</span>, <span class="sc">&#39;p&#39;</span>, <span class="sc">&#39;p&#39;</span>, <span class="sc">&#39;l&#39;</span>, <span class="sc">&#39;e&#39;</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;apple&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;apple&quot;</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>String → List Char</span></span></div></blockquote></div></small></div><span class="na">toList</span></span><span class="alectryon-token">  <span class="c1">-- [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="monads-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="monads-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="sc">&#39;a&#39;</span>, <span class="sc">&#39;p&#39;</span>, <span class="sc">&#39;p&#39;</span>, <span class="sc">&#39;l&#39;</span>, <span class="sc">&#39;e&#39;</span>, <span class="sc">&#39;o&#39;</span>, <span class="sc">&#39;r&#39;</span>, <span class="sc">&#39;a&#39;</span>, <span class="sc">&#39;n&#39;</span>, <span class="sc">&#39;g&#39;</span>, <span class="sc">&#39;e&#39;</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;apple&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;apple&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;orange&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;orange&quot;</span></span><span class="alectryon-token">] <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String.toList</var><b>: </b><span>String → List Char</span></span></div></blockquote></div></small></div>String.toList</span><span class="alectryon-token">
<span class="c1">-- [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;, &#39;o&#39;, &#39;r&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;, &#39;e&#39;]</span></span></span></pre>
<h2 id="the-io-monad"><a class="header" href="#the-io-monad">The IO Monad</a></h2>
<p>The <code>IO Monad</code> is perhaps the most important monad in Lean. It is also one of the hardest monads to
understand starting out. Its actual implementation is too intricate to discuss when first learning
monads. So it is best to learn by example.</p>
<p>What is the <strong>computational context</strong> that describes the IO monad? IO operations can read
information from or write information to the terminal, file system, operating system, and/or
network. They interact with systems outside of your program. If you want to get user input, print a
message to the user, read information from a file, or make a network call, you'll need to do so
within the IO Monad.</p>
<p>The state of the world outside your program can change at virtually any moment, and so this IO
context is particularly special. So these IO operations are &quot;side effects&quot; which means you cannot
perform them from &quot;pure&quot; Lean functions.</p>
<p>Now, the most important job of pretty much any computer program is precisely to perform this
interaction with the outside world. For this reason, the root of all executable Lean code is a
function called main, with the type <code>IO Unit</code>. So every program starts in the IO monad!</p>
<p>When your function is <code>IO</code> monadic, you can get any input you need, call into &quot;pure&quot; code with the
inputs, and then output the result in some way. The reverse does not work. You cannot call into IO
code from pure code like you can call into a function that takes <code>Option</code> as input. Another way to
say this is you cannot invent an <code>IO</code> context out of thin air, it has to be given to you in your
<code>main</code> function.</p>
<p>Let's look at a simple program showing a few of the basic IO functions. It also uses <code>do</code> notation
to make the code read nicely:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;enter a line of text:&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;enter a line of text:&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stdin</var><b>: </b><span>IO.FS.Stream</span></span></div></blockquote></div></small></div><span class="nv">stdin</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.getStdin</var><b>: </b><span>BaseIO IO.FS.Stream</span></span></div></blockquote></div></small></div>IO.getStdin</span><span class="alectryon-token">            <span class="c1">-- IO IO.FS.Stream (monadic)</span>
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>stdin</var><b>: </b><span>IO.FS.Stream</span></span></div></blockquote></div></small></div><span class="nv">stdin</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getLine</var><b>: </b><span>IO.FS.Stream → IO String</span></span></div></blockquote></div></small></div>getLine</span><span class="alectryon-token">          <span class="c1">-- IO.FS.Stream → IO String (monadic)</span>
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>uppercased</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">uppercased</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUpper</var><b>: </b><span>String → String</span></span></div></blockquote></div></small></div>toUpper</span><span class="alectryon-token">    <span class="c1">-- String → String (pure)</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>uppercased</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">uppercased</span></span><span class="alectryon-token">              <span class="c1">-- IO Unit (monadic)</span></span></span></pre>
<p>So, once again you can see that the <code>do</code> notation lets you chain a series of monadic actions.
<code>IO.getStdin</code> is of type <code>IO IO.FS.Stream</code> and <code>stdin.getLine</code> is of type <code>IO String</code>
and <code>IO.println</code> is of type <code>IO Unit</code>.</p>
<p>In between you see a non-monadic expression <code>let uppercased := input.toUpper</code> which is fine too.
A let statement can occur in any monad. Just as you could unwrap <code>i</code> from <code>Option Nat</code> to get the
inner Nat, you can use <code>←</code> to unwrap the result of <code>getLine</code> to get a String. You can then manipulate
this value using normal pure string functions like <code>toUpper</code>, and then you can pass the result to the
<code>IO.println</code> function.</p>
<p>This is a simple echo program. It reads a line from the terminal, and then prints the line back out
capitalized to the terminal. Hopefully it gives you a basic understanding of how IO works.</p>
<p>You can test this program using <code>lean --run</code> as follows:</p>
<pre><code>&gt; lean --run Main.lean
enter a line of text:
the quick brown fox
THE QUICK BROWN FOX
</code></pre>
<p>Here the user entered the string <code>the quick brown fox</code> and got back the uppercase result.</p>
<h2 id="what-separates-monads-from-applicatives"><a class="header" href="#what-separates-monads-from-applicatives">What separates Monads from Applicatives?</a></h2>
<p>The key that separates these is <strong>context</strong>. You cannot really determine the structure of
&quot;future&quot; operations without knowing the results of &quot;past&quot; operations, because the past can alter the
context in which the future operations work. With applicatives, you can't get the final function
result without evaluating everything, but you can determine the structure of how the operation will
take place. This allows some degree of parallelism with applicatives that is not generally possible
with monads.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Hopefully you now have a basic level understanding of what a monad is. But perhaps some more
examples of what a &quot;computational context&quot; means would be useful to you. The Reader, State and
Except monads each provide a concrete and easily understood context that can be compared easily to
function parameters. You can learn more about those in <a href="monads/readers.lean.html">Reader monads</a>,
<a href="monads/states.lean.html">State monads</a>, and the <a href="monads/except.lean.html">Except monad</a>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="readers"><a class="header" href="#readers">Readers</a></h1>
<p>In the <a href="monads/monads.lean.html">previous section</a> you learned about the conceptual idea of monads. You learned
what they are, and saw how some common types like <code>IO</code> and <code>Option</code> work as monads. Now in this
section, you will be looking at some other useful monads. In particular, the <code>ReaderM</code> monad.</p>
<h2 id="how-to-do-global-variables-in-lean"><a class="header" href="#how-to-do-global-variables-in-lean">How to do Global Variables in Lean?</a></h2>
<p>In Lean, your code is generally &quot;pure&quot;, meaning functions can only interact with the arguments
passed to them. This effectively means you cannot have global variables. You can have global
definitions, but these are fixed at compile time. If some user behavior might change them, you would have
to wrap them in the <code>IO</code> monad, which means they can't be used from pure code.</p>
<p>Consider this example. Here, you want to have an <code>Environment</code> containing different parameters as a
global variable. However, you want to load these parameters from the process environment variables,
which requires the <code>IO</code> monad.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>path</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>path</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>home</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>home</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>user</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>user</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getEnvDefault</var><b>: </b><span>String → IO String</span></span></div></blockquote></div></small></div><span class="nv">getEnvDefault</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">): </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val?</var><b>: </b><span>Option String</span></span></div></blockquote></div></small></div>val<span class="bp">?</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.getEnv</var><b>: </b><span>String → BaseIO (Option String)</span></span></div></blockquote></div></small></div>IO.getEnv</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> <span class="bp">&lt;|</span> </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val?</var><b>: </b><span>Option String</span></span></div></blockquote></div></small></div>val<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
          <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type ?u.1763} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token">
          <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type ?u.1772} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loadEnv</var><b>: </b><span>IO Environment</span></span></div></blockquote></div></small></div><span class="nv">loadEnv</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>path</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">path</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getEnvDefault</var><b>: </b><span>String → IO String</span></span></div></blockquote></div></small></div>getEnvDefault</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;PATH&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;PATH&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>home</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">home</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getEnvDefault</var><b>: </b><span>String → IO String</span></span></div></blockquote></div></small></div>getEnvDefault</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;HOME&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;HOME&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>user</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">user</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getEnvDefault</var><b>: </b><span>String → IO String</span></span></div></blockquote></div></small></div>getEnvDefault</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;USER&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;USER&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> { </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>path</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">path</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>home</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">home</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>user</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">user</span></span><span class="alectryon-token"> }

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>func1</var><b>: </b><span>Environment → Float</span></span></div></blockquote></div></small></div><span class="nv">func1</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l1</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>path</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>path</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l2</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>home</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>home</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l3</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>user</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>user</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">
  (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l1</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l2</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l3</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toFloat</var><b>: </b><span>Nat → Float</span></span></div></blockquote></div></small></div><span class="na">toFloat</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2.1</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>func2</var><b>: </b><span>Environment → Nat</span></span></div></blockquote></div></small></div><span class="nv">func2</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">+</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>func1</var><b>: </b><span>Environment → Float</span></span></div></blockquote></div></small></div>func1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>floor</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div><span class="na">floor</span></span><span class="alectryon-token"><span class="na">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div><span class="na">toUInt32</span></span><span class="alectryon-token"><span class="na">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div><span class="na">toNat</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>func3</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div><span class="nv">func3</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;Result: &quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;Result: &quot;</span></span><span class="alectryon-token"> <span class="bp">++</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>func2</var><b>: </b><span>Environment → Nat</span></span></div></blockquote></div></small></div>func2</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">))

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loadEnv</var><b>: </b><span>IO Environment</span></span></div></blockquote></div></small></div>loadEnv</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>func3</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>func3</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="readers-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="readers-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Result: <span class="mi">1306</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div>main</span><span class="alectryon-token"> <span class="c1">-- Result: 7538</span></span></span></pre>
<p>The only function actually using the environment is func1. However func1 is a pure function. This
means it cannot directly call loadEnv, an impure function in the IO monad. This means the
environment has to be passed through as a variable to the other functions, just so they can
ultimately pass it to func1. In a language with global variables, you could save env as a global
value in main. Then func1 could access it directly. There would be no need to have it as a parameter
to func1, func2 and func3. In larger programs, these &quot;pass-through&quot; variables can cause a lot of
headaches.</p>
<h2 id="the-reader-solution"><a class="header" href="#the-reader-solution">The Reader Solution</a></h2>
<p>The <code>ReaderM</code> monad solves this problem. It effectively creates a global read-only value of a
specified type. All functions within the monad can &quot;read&quot; the type. Let's look at how the <code>ReaderM</code>
monad changes the shape of this code. Now the functions <strong>no longer need</strong> to be given the
<code>Environment</code> as an explicit parameter, as they can access it through the monad.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc1</var><b>: </b><span>ReaderM Environment Float</span></span></div></blockquote></div></small></div><span class="nv">readerFunc1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>ReaderM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>read</var><b>: </b><span>{ρ : outParam Type} → {m : Type → Type} → [self : MonadReader ρ m] → m ρ</span></span></div></blockquote></div></small></div>read</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l1</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>path</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>path</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l2</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>home</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>home</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l3</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>user</var><b>: </b><span>Environment → String</span></span></div></blockquote></div></small></div>user</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l1</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l2</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">l3</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toFloat</var><b>: </b><span>Nat → Float</span></span></div></blockquote></div></small></div><span class="na">toFloat</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2.1</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">2</span><span class="bp">.</span><span class="mi">1</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc2</var><b>: </b><span>ReaderM Environment Nat</span></span></div></blockquote></div></small></div><span class="nv">readerFunc2</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>ReaderM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc1</var><b>: </b><span>ReaderM Environment Float</span></span></div></blockquote></div></small></div>readerFunc1</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">+</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>floor</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div>floor</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div>toUInt32</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div>toNat</span><span class="alectryon-token">))

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc3</var><b>: </b><span>ReaderM Environment String</span></span></div></blockquote></div></small></div><span class="nv">readerFunc3</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>ReaderM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc2</var><b>: </b><span>ReaderM Environment Nat</span></span></div></blockquote></div></small></div>readerFunc2</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;Result: &quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;Result: &quot;</span></span><span class="alectryon-token"> <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main2</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main2</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loadEnv</var><b>: </b><span>IO Environment</span></span></div></blockquote></div></small></div>loadEnv</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>Id String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc3</var><b>: </b><span>ReaderM Environment String</span></span></div></blockquote></div></small></div>readerFunc3</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{ρ : Type} → {m : Type → Type} → {α : Type} → ReaderT ρ m α → ρ → m α</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>Id String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="readers-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="readers-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Result: <span class="mi">1306</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main2</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div>main2</span><span class="alectryon-token"> <span class="c1">-- Result: 7538</span></span></span></pre>
<p>The <code>ReaderM</code> monad provides a <code>run</code> method and it is the <code>ReaderM</code> run method that takes the initial
<code>Environment</code> context.  So here you see <code>main2</code> loads the environment as before, and establishes
the <code>ReaderM</code> context by passing <code>env</code> to the <code>run</code> method.</p>
<blockquote>
<p><strong>Side note 1</strong>: The <code>return</code> statement used above also needs some explanation.  The <code>return</code>
statement in Lean is closely related to <code>pure</code>, but a little different. First the similarity is that
<code>return</code> and <code>pure</code> both lift a pure value up to the Monad type. But <code>return</code> is a keyword so you do
not need to parenthesize the expression like you do when using <code>pure</code>.  (Note: you can avoid
parentheses when using <code>pure</code> by using the <code>&lt;|</code> operator like we did above in the initial
<code>getEnvDefault</code> function).  Furthermore, <code>return</code> can also cause an early <code>return</code> in a monadic
function similar to how it can in an imperative language while <code>pure</code> cannot.</p>
</blockquote>
<blockquote>
<p>So technically if <code>return</code> is the last statement in a function it could be replaced with <code>pure &lt;|</code>,
but one could argue that <code>return</code> is still a little easier for most folks to read, just so long as
you understand that <code>return</code> is doing more than other languages, it is also wrapping pure values in
the monadic container type.</p>
</blockquote>
<blockquote>
<p><strong>Side note 2</strong>: If the function <code>readerFunc3</code> also took some explicit arguments then you would have
to write <code>(readerFunc3 args).run env</code> and this is a bit ugly, so Lean provides an infix operator
<code>|&gt;</code> that eliminates those parentheses so you can write <code>readerFunc3 args |&gt;.run env</code> and then you can
chain multiple monadic actions like this <code>m1 args1 |&gt;.run args2 |&gt;.run args3</code> and this is the
recommended style.  You will see this pattern used heavily in Lean code.</p>
</blockquote>
<p>The <code>let env ← read</code> expression in <code>readerFunc1</code> unwraps the environment from the <code>ReaderM</code> so we
can use it. Each type of monad might provide one or more extra functions like this, functions that
become available only when you are in the context of that monad.</p>
<p>Here the <code>readerFunc2</code> function uses the <code>bind</code> operator <code>&gt;&gt;=</code> just to show you that there are bind
operations happening here.  The <code>readerFunc3</code> function uses the <code>do</code> notation you learned about in
<a href="monads/monads.lean.html">Monads</a> which hides that bind operation and can make the code look cleaner.
So the expression <code>let x ← readerFunc2</code> is also calling the <code>bind</code> function under the covers,
so that you can access the unwrapped value <code>x</code> needed for the <code>toString x</code> conversion.</p>
<p>The important difference here to the earlier code is that <code>readerFunc3</code> and <code>readerFunc2</code> no longer
have an <strong>explicit</strong> Environment input parameter that needs to be passed along all the way to
<code>readerFunc1</code>.  Instead, the <code>ReaderM</code> monad is taking care of that for you, which gives you the
illusion of something like global context where the context is now available to all functions that use
the <code>ReaderM</code> monad.</p>
<p>The above code also introduces an important idea. Whenever you learn about a monad &quot;X&quot;, there's
often (but not always) a <code>run</code> function to execute that monad, and sometimes some additional
functions like <code>read</code> that interact with the monad context.</p>
<p>You might be wondering, how does the context actually move through the <code>ReaderM</code> monad? How can you
add an input argument to a function by modifying its return type?  There is a special command in
Lean that will show you the reduced types:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="readers-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="readers-lean-chk2"><span class="alectryon-token"><span class="k">#reduce</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Environment <span class="bp">→</span> String</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>ReaderM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">   <span class="c1">-- Environment → String</span></span></span></pre>
<p>And you can see here that this type is actually a function!  It's a function that takes an
<code>Environment</code> as input and returns a <code>String</code>.</p>
<p>Now, remember in Lean that a function that takes an argument of type <code>Nat</code> and returns a <code>String</code>
like <code>def f (a : Nat) : String</code> is the same as this function <code>def f : Nat → String</code>.  These are
exactly equal as types.  Well this is being used by the <code>ReaderM</code> Monad to add an input argument to
all the functions that use the <code>ReaderM</code> monad and this is why <code>main</code> is able to start things off by
simply passing that new input argument in <code>readerFunc3.run env</code>. So now that you know the implementation
details of the <code>ReaderM</code> monad you can see that what it is doing looks very much like the original
code we wrote at the beginning of this section, only it's taking a lot of the tedious work off your
plate and it is creating a nice clean separation between what your pure functions are doing, and the
global context idea that the <code>ReaderM</code> adds.</p>
<h2 id="withreader"><a class="header" href="#withreader">withReader</a></h2>
<p>One <code>ReaderM</code> function can call another with a modified version of the <code>ReaderM</code> context. You can
use the <code>withReader</code> function from the <code>MonadWithReader</code> type class to do this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc3WithReader</var><b>: </b><span>ReaderM Environment String</span></span></div></blockquote></div></small></div><span class="nv">readerFunc3WithReader</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>ReaderM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Environment</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Environment</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>withReader</var><b>: </b><span>{ρ : outParam Type} → {m : Type → Type} → [self : MonadWithReader ρ m] → {α : Type} → (ρ → ρ) → m α → m α</span></span></div></blockquote></div></small></div>withReader</span><span class="alectryon-token"> (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> { </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>env</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div><span class="nv">env</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> user := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;new user&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;new user&quot;</span></span><span class="alectryon-token"> }) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc2</var><b>: </b><span>ReaderM Environment Nat</span></span></div></blockquote></div></small></div>readerFunc2</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;Result: &quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;Result: &quot;</span></span><span class="alectryon-token"> <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"></span></span></pre>
<p>Here we changed the <code>user</code> in the <code>Environment</code> context to &quot;new user&quot; and then we passed that
modified context to <code>readerFunc2</code>.</p>
<p>So <code>withReader f m</code> executes monad <code>m</code> in the <code>ReaderM</code> context modified by <code>f</code>.</p>
<h2 id="handy-shortcut-with--e"><a class="header" href="#handy-shortcut-with--e">Handy shortcut with (← e)</a></h2>
<p>If you use the operator <code>←</code> in a let expression and the variable is only used once you can
eliminate the let expression and place the <code>←</code> operator in parentheses like this
call to loadEnv:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main3</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main3</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>Id String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>readerFunc3</var><b>: </b><span>ReaderM Environment String</span></span></div></blockquote></div></small></div>readerFunc3</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← loadEnv)</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>loadEnv</var><b>: </b><span>IO Environment</span></span></div></blockquote></div></small></div><span class="nv">loadEnv</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← loadEnv)</var><b>: </b><span>Environment</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>Id String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"></span></span></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>It might not seem like much has been accomplished with this <code>ReaderM Environment</code> monad, but you will
find that in larger code bases, with many different types of monads all composed together this
greatly cleans up the code. Monads provide a beautiful functional way of managing cross-cutting
concerns that would otherwise make your code very messy.</p>
<p>Having this control over the inherited <code>ReaderM</code> context via <code>withReader</code> is actually very useful
and something that is quite messy if you try and do this sort of thing with global variables, saving
the old value, setting the new one, calling the function, then restoring the old value, making sure
you do that in a try/finally block and so on. The <code>ReaderM</code> design pattern avoids that mess
entirely.</p>
<p>Now it's time to move on to <a href="monads/states.lean.html">StateM Monad</a> which is like a <code>ReaderM</code> that is
also updatable.</p>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Lean.Data.HashMap</span></span></pre>
<h1 id="state"><a class="header" href="#state">State</a></h1>
<p>In the <a href="monads/readers.lean.html">previous section</a>, you learned about the <code>ReaderM</code> monad. Hopefully this gave you
a new perspective on Lean. It showed that, in fact, you <em>can</em> have global variables of some sort;
you just need to encode them in the type signature somehow, and this is what monads are for! In this
part, you will explore the <code>StateM</code> monad, which is like a <code>ReaderM</code> only the state can also be updated.</p>
<h2 id="motivating-example-tic-tac-toe"><a class="header" href="#motivating-example-tic-tac-toe">Motivating example: Tic Tac Toe</a></h2>
<p>For this section, let's build a simple model for a Tic Tace Toe game. The main object is the <code>GameState</code>
data type containing several important pieces of information. First and foremost, it has the
&quot;board&quot;, a map from 2D tile indices to the &quot;Tile State&quot; (X, O or empty). Then it also knows the
current player, and it has a random generator.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Std (</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk0"><span class="alectryon-token">HashMap</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unknown <span class="kd">constant</span> <span class="bp">&#39;</span>Std.HashMap&#39;</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileIndex</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">TileIndex</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="c1">-- a 2D index</span>

</span><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileState</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">TileState</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileEmpty</var><b>: </b><span>TileState</span></span></div></blockquote></div></small></div>TileEmpty</span><span class="alectryon-token"> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileX</var><b>: </b><span>TileState</span></span></div></blockquote></div></small></div>TileX</span><span class="alectryon-token"> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileO</var><b>: </b><span>TileState</span></span></div></blockquote></div></small></div>TileO</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BEq</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>BEq</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Player</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Player</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>XPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>XPlayer</span><span class="alectryon-token"> <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>OPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>OPlayer</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BEq</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>BEq</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Board</var><b>: </b><span>?m.657</span></span></div></blockquote></div></small></div><span class="nv">Board</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk1"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HashMap</var><b>: </b><span>?m.657</span></span></div></blockquote></div></small></div>HashMap</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unknown identifier <span class="bp">&#39;</span>HashMap&#39;</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var> TileIndex TileState</var><b>: </b><span>?m.657</span></span></div></blockquote></div></small></div> TileIndex TileState</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GameState</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div>GameState</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>GameState → {Board : Sort u_1} → Board</span></span></div></blockquote></div></small></div>board</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Board</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">Board</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>currentPlayer</var><b>: </b><span>GameState → Player</span></span></div></blockquote></div></small></div>currentPlayer</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Player</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Player</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>generator</var><b>: </b><span>GameState → StdGen</span></span></div></blockquote></div></small></div>generator</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StdGen</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>StdGen</span><span class="alectryon-token"></span></span></pre>
<p>Let's think at a high level about how some of the game functions would work. You could, for
instance, have a function for selecting a random move. This would output a <code>TileIndex</code> to play and
alter the game's number generator. You would then make a move based on the selected move and the
current player. This would change the board state as well as swap the current player. In other
words, you have operations that depend on the current state of the game, but also need to <strong>update
that state</strong>.</p>
<h2 id="the-statem-monad-to-the-rescue"><a class="header" href="#the-statem-monad-to-the-rescue">The StateM Monad to the Rescue</a></h2>
<p>This is exactly the situation the <code>StateM</code> monad deals with. The <code>StateM</code> monad wraps computations in
the context of reading and modifying a global state object.</p>
<p>It is parameterized by a single type parameter <code>s</code>, the state type in use. So just like the <code>ReaderM</code>
has a single type you read from, the <code>StateM</code> has a single type you can both <strong>read from and write
to</strong>. There are three primary actions you can take within the <code>StateM</code>monad:</p>
<ul>
<li><strong>get</strong> - retrieves the state, like Reader.read</li>
<li><strong>set</strong> - updates the state</li>
<li><strong>modifyGet</strong> - retrieves the state, then updates it</li>
</ul>
<p>There is also a <code>run</code> function, similar to <code>run</code> on <code>ReaderM</code>. Like the <code>ReaderM</code> monad, you must
provide an initial state, in addition to the computation to run. <code>StateM</code> then produces two outputs:
the result of the computation combined with the final updated state.</p>
<p>If you wish to discard the final state and just get the computation's result, you can use
<code>run'</code> method instead.  Yes in Lean, the apostrophe can be part of a name, you read this &quot;run
prime&quot;, and the general naming convention is that the prime method discards something.</p>
<p>So for your Tic Tac Toe game, many of your functions will have a signature like <code>State GameState a</code>.</p>
<h2 id="stateful-functions"><a class="header" href="#stateful-functions">Stateful Functions</a></h2>
<p>Now you can examine some of the different functions mentioned above and determine their types.
You can, for instance, pick a random move:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> TileState

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>findOpen</var><b>: </b><span>StateM GameState (List TileIndex)</span></span></div></blockquote></div></small></div><span class="nv">findOpen</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>StateM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GameState</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>GameState</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileIndex</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>TileIndex</span><span class="alectryon-token">) := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{σ : outParam Type} → {m : Type → Type} → [self : MonadState σ m] → m σ</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk2"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>GameState → ∀ {Board : Prop}, Board</span></span></div></blockquote></div></small></div>board</span><span class="alectryon-token"><span class="bp">.</span>toList.filterMap </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> (i, x) <span class="bp">=&gt;</span> guard (x <span class="bp">==</span> TileEmpty) <span class="bp">*&gt;</span> pure i</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: invalid field <span class="kd">notation</span>, type is not of the form (C <span class="bp">...</span>) where C is a <span class="kd">constant</span>
  game.board
has type
  <span class="bp">?</span>m.1336</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>chooseRandomMove</var><b>: </b><span>StateM GameState TileIndex</span></span></div></blockquote></div></small></div><span class="nv">chooseRandomMove</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>StateM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GameState</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>GameState</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileIndex</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>TileIndex</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{σ : outParam Type} → {m : Type → Type} → [self : MonadState σ m] → m σ</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>openSpots</var><b>: </b><span>List TileIndex</span></span></div></blockquote></div></small></div><span class="nv">openSpots</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>findOpen</var><b>: </b><span>StateM GameState (List TileIndex)</span></span></div></blockquote></div></small></div>findOpen</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>generator</var><b>: </b><span>GameState → StdGen</span></span></div></blockquote></div></small></div>generator</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen'</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen&#39;</span></span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>randNat</var><b>: </b><span>{gen : Type} → [inst : RandomGen gen] → gen → Nat → Nat → Nat × gen</span></span></div></blockquote></div></small></div>randNat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>openSpots</var><b>: </b><span>List TileIndex</span></span></div></blockquote></div></small></div><span class="nv">openSpots</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"> <span class="bp">-</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{σ : semiOutParam Type} → {m : Type → Type} → [self : MonadStateOf σ m] → σ → m PUnit</span></span></div></blockquote></div></small></div>set</span><span class="alectryon-token"> { </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> generator := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen'</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen&#39;</span></span><span class="alectryon-token"> }
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>openSpots</var><b>: </b><span>List TileIndex</span></span></div></blockquote></div></small></div><span class="nv">openSpots</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">]<span class="bp">!</span></span></span></pre>
<p>This returns a <code>TileIndex</code> and modifies the random number generator stored in the <code>GameState</code>!
Notice you have a fun little use of the <code>Applicative.seqRight</code> operator <code>*&gt;</code> in <code>findOpen</code>
as described in <a href="monads/applicatives.lean.html">Applicatives</a>.</p>
<p>Now you can create the function that can make a move:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Player

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tileStateForPlayer</var><b>: </b><span>Player → TileState</span></span></div></blockquote></div></small></div><span class="nv">tileStateForPlayer</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Player</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Player</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileState</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>TileState</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>XPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>XPlayer</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileX</var><b>: </b><span>TileState</span></span></div></blockquote></div></small></div>TileX</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>OPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>OPlayer</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileO</var><b>: </b><span>TileState</span></span></div></blockquote></div></small></div>TileO</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nextPlayer</var><b>: </b><span>Player → Player</span></span></div></blockquote></div></small></div><span class="nv">nextPlayer</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Player</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Player</span><span class="alectryon-token"> <span class="bp">→</span>  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Player</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Player</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>XPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>XPlayer</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>OPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>OPlayer</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>OPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>OPlayer</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>XPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>XPlayer</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>applyMove</var><b>: </b><span>TileIndex → StateM GameState Unit</span></span></div></blockquote></div></small></div><span class="nv">applyMove</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>TileIndex</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileIndex</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>TileIndex</span><span class="alectryon-token">): </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>StateM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GameState</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>GameState</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{σ : outParam Type} → {m : Type → Type} → [self : MonadState σ m] → m σ</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>currentPlayer</var><b>: </b><span>GameState → Player</span></span></div></blockquote></div></small></div>currentPlayer</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>newBoard</var><b>: </b><span>∀ {Board : Prop}, Board</span></span></div></blockquote></div></small></div><span class="nv">newBoard</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk3"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>GameState → ∀ {Board : Prop}, Board</span></span></div></blockquote></div></small></div>board</span><span class="alectryon-token"><span class="bp">.</span>insert i (tileStateForPlayer p)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: invalid field <span class="kd">notation</span>, type is not of the form (C <span class="bp">...</span>) where C is a <span class="kd">constant</span>
  game.board
has type
  <span class="bp">?</span>m.2455</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{σ : semiOutParam Type} → {m : Type → Type} → [self : MonadStateOf σ m] → σ → m PUnit</span></span></div></blockquote></div></small></div>set</span><span class="alectryon-token"> { </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>game</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">game</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> currentPlayer := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nextPlayer</var><b>: </b><span>Player → Player</span></span></div></blockquote></div></small></div>nextPlayer</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token">, board := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>newBoard</var><b>: </b><span>∀ {Board : Prop}, Board</span></span></div></blockquote></div></small></div><span class="nv">newBoard</span></span><span class="alectryon-token"> }</span></span></pre>
<p>This updates the board in the <code>GameState</code> with the new tile, and then changes the current player,
providing no output (<code>Unit</code> return type).</p>
<p>So finally, you can combine these functions together with <code>do</code> notation, and it actually looks quite
clean! You don't need to worry about the side effects. The different monadic functions handle them.
Here's a sample of what your function might look like to play one turn of the game. At the end, it
returns a boolean determining if all the spaces have been filled.</p>
<p>Notice in <code>isGameDone</code> and <code>nextTurn</code> we have stopped providing the full return type
<code>StateM GameState Unit</code>.  This is because Lean is able to infer the correct monadic return type
from the context and as a result the code is now looking really clean.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isGameDone</var><b>: </b><span>StateM GameState Bool</span></span></div></blockquote></div></small></div><span class="nv">isGameDone</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← findOpen)</var><b>: </b><span>List TileIndex</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>findOpen</var><b>: </b><span>StateM GameState (List TileIndex)</span></span></div></blockquote></div></small></div><span class="nv">findOpen</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← findOpen)</var><b>: </b><span>List TileIndex</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isEmpty</var><b>: </b><span>{α : Type} → List α → Bool</span></span></div></blockquote></div></small></div><span class="na">isEmpty</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nextTurn</var><b>: </b><span>StateM GameState Bool</span></span></div></blockquote></div></small></div><span class="nv">nextTurn</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>TileIndex</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>chooseRandomMove</var><b>: </b><span>StateM GameState TileIndex</span></span></div></blockquote></div></small></div>chooseRandomMove</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>applyMove</var><b>: </b><span>TileIndex → StateM GameState Unit</span></span></div></blockquote></div></small></div>applyMove</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>TileIndex</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isGameDone</var><b>: </b><span>StateM GameState Bool</span></span></div></blockquote></div></small></div>isGameDone</span><span class="alectryon-token"></span></span></pre>
<p>To give you a quick test harness that runs all moves for both players you can run this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>initBoard</var><b>: </b><span>{Board : Type u_1} → Board</span></span></div></blockquote></div></small></div><span class="nv">initBoard</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Board</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">Board</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id.run</var><b>: </b><span>{α : Type u_1} → Id α → α</span></span></div></blockquote></div></small></div>Id.run</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>Id Board</span></span></div></blockquote></div></small></div><span class="nv">board</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk4"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HashMap.empty</var><b>: </b><span>Id Board</span></span></div></blockquote></div></small></div>HashMap.empty</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unknown identifier <span class="bp">&#39;</span>HashMap.empty&#39;</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>j</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">j</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>TileIndex</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>TileIndex</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>TileIndex</span><span class="alectryon-token"> := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>j</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">j</span></span><span class="alectryon-token">)
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>Id Board</span></span></div></blockquote></div></small></div><span class="nv">board</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk5"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>Id Board</span></span></div></blockquote></div></small></div><span class="nv">board</span></span><span class="alectryon-token"><span class="bp">.</span>insert t TileEmpty</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: invalid field <span class="kd">notation</span>, type is not of the form (C <span class="bp">...</span>) where C is a <span class="kd">constant</span>
  board
has type
  Board</blockquote><blockquote class="alectryon-message">Error: invalid field <span class="bp">&#39;</span>insert&#39;, the environment does not contain <span class="bp">&#39;</span>Id.insert&#39;
  board
has type
  Id Board</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>Id Board</span></span></div></blockquote></div></small></div><span class="nv">board</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>printBoard</var><b>: </b><span>{Board : Sort u_1} → Board → IO Unit</span></span></div></blockquote></div></small></div><span class="nv">printBoard</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>Board</span></span></div></blockquote></div></small></div><span class="nv">board</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Board</var><b>: </b><span>Sort u_1</span></span></div></blockquote></div></small></div><span class="nv">Board</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>row</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div><span class="nv">row</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk6"><span class="alectryon-token"><span class="k">for</span></span><span class="alectryon-token"> i </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: failed to construct <span class="bp">&#39;</span>ForIn&#39; <span class="kd">instance</span> for collection
  <span class="bp">?</span>m.3568 board
and monad
  EIO IO.Error</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk7"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>Board</span></span></div></blockquote></div></small></div><span class="nv">board</span></span><span class="alectryon-token"><span class="bp">.</span>toList</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: failed to construct <span class="bp">&#39;</span>ForIn&#39; <span class="kd">instance</span> for collection
  <span class="bp">?</span>m.3568 board
and monad
  EIO IO.Error</blockquote><blockquote class="alectryon-message">Error: invalid field <span class="kd">notation</span>, type is not of the form (C <span class="bp">...</span>) where C is a <span class="kd">constant</span>
  board
has type
  Board</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"></span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk8"><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> s := </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> i.2 </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
      <span class="bp">|</span> TileEmpty <span class="bp">=&gt;</span> <span class="s2">&quot; &quot;</span>
      <span class="bp">|</span> TileX <span class="bp">=&gt;</span> <span class="s2">&quot;X&quot;</span>
      <span class="bp">|</span> TileO <span class="bp">=&gt;</span> <span class="s2">&quot;O&quot;</span>
    row := row.append [s]
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> row.length <span class="bp">==</span> <span class="mi">3</span> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      IO.println row
      row := []</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: failed to construct <span class="bp">&#39;</span>ForIn&#39; <span class="kd">instance</span> for collection
  <span class="bp">?</span>m.3568 board
and monad
  EIO IO.Error</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>playGame</var><b>: </b><span>StateM GameState PUnit</span></span></div></blockquote></div></small></div><span class="nv">playGame</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">while</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>finished</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">finished</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nextTurn</var><b>: </b><span>StateM GameState Bool</span></span></div></blockquote></div></small></div>nextTurn</span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>finished</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">finished</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>return</var><b>: </b><span>StateM GameState (ForInStep (MProd (Option PUnit) PUnit))</span></span></div></blockquote></div></small></div><span class="k">return</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.stdGenRef</var><b>: </b><span>IO.Ref StdGen</span></span></div></blockquote></div></small></div>IO.stdGenRef</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{σ : Type} → {m : Type → Type} → [inst : MonadLiftT (ST σ) m] → {α : Type} → ST.Ref σ α → m α</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen'</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen&#39;</span></span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>randNat</var><b>: </b><span>{gen : Type} → [inst : RandomGen gen] → gen → Nat → Nat → Nat × gen</span></span></div></blockquote></div></small></div>randNat</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs</span></span><span class="alectryon-token"> := {
    board := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chk9"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>initBoard</var><b>: </b><span>{Board : Type ?u.4695} → Board</span></span></div></blockquote></div></small></div>initBoard</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: type mismatch
  initBoard
has type
  <span class="bp">?</span>m.4696 : <span class="kt">Type</span> <span class="bp">?</span>u.4695
but is expected to <span class="k">have</span> type
  Board<span class="bp">✝</span> : <span class="kt">Prop</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">,
    currentPlayer := </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>XPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>XPlayer</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>OPlayer</var><b>: </b><span>Player</span></span></div></blockquote></div></small></div>OPlayer</span><span class="alectryon-token">,
    generator := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gen'</var><b>: </b><span>StdGen</span></span></div></blockquote></div></small></div><span class="nv">gen&#39;</span></span><span class="alectryon-token"> }
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> (_, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>playGame</var><b>: </b><span>StateM GameState PUnit</span></span></div></blockquote></div></small></div>playGame</span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>printBoard</var><b>: </b><span>{Board : Prop} → Board → IO Unit</span></span></div></blockquote></div></small></div>printBoard</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>board</var><b>: </b><span>GameState → ∀ {Board : Prop}, Board</span></span></div></blockquote></div></small></div>board</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chka"><span class="alectryon-token"><span class="k">#eval</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div>main</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: cannot evaluate code because <span class="bp">&#39;</span>_eval._lambda_1&#39; uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span> and<span class="bp">/</span>or contains errors</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
<span class="c1">-- [X, X, O]</span>
<span class="c1">-- [X, O, O]</span>
<span class="c1">-- [O, O, X]</span></span></span></pre>
<p>Note that when you run the above code interactively the random number generator always starts in the
same place.  But if you run <code>lean --run states.lean</code> then you will see randomness in the result.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>It may be helpful to see how the <code>StateM</code> monad adds the input state and output state.  If you look
at the reduced Type for <code>nextTurn</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="states-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="states-lean-chkb"><span class="alectryon-token"><span class="k">#reduce</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">GameState <span class="bp">→</span> Bool <span class="bp">×</span> GameState</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>StateM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GameState</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>GameState</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">
<span class="c1">-- GameState → Bool × GameState</span></span></span></pre>
<p>So a function like <code>nextTurn</code> that might have just returned a <code>Bool</code> has been modified by the
<code>StateM</code> monad such that the initial <code>GameState</code> is passed in as a new input argument, and the output
value has been changed to the pair <code>Bool × GameState</code> so that it can return the pure <code>Bool</code> and the
updated <code>GameState</code>.  So <code>playGame</code> then is automatically saving that updated game state so that each
time around the <code>while</code> loop it is acting on the new state, otherwise that would be an infinite loop!</p>
<p>It is also interesting to see how much work the <code>do</code> and <code>←</code> notation are doing for you.  To
implement the <code>nextTurn</code> function without these you would have to write this, manually plumbing
the state all the way through:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>nextTurnManually</var><b>: </b><span>StateM GameState Bool</span></span></div></blockquote></div></small></div><span class="nv">nextTurnManually</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateM</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>StateM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GameState</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>GameState</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token">
<span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>state</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">state</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>TileIndex</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs</span></span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>chooseRandomMove</var><b>: </b><span>StateM GameState TileIndex</span></span></div></blockquote></div></small></div>chooseRandomMove</span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>state</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">state</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> (_, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs'</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs&#39;</span></span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>applyMove</var><b>: </b><span>TileIndex → StateM GameState Unit</span></span></div></blockquote></div></small></div>applyMove</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>TileIndex</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token">  <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>result</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">result</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs''</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs&#39;&#39;</span></span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>isGameDone</var><b>: </b><span>StateM GameState Bool</span></span></div></blockquote></div></small></div>isGameDone</span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs'</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs&#39;</span></span><span class="alectryon-token">
  (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>result</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div><span class="nv">result</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>gs''</var><b>: </b><span>GameState</span></span></div></blockquote></div></small></div><span class="nv">gs&#39;&#39;</span></span><span class="alectryon-token">)</span></span></pre>
<p>This expression <code>let (i, gs)</code> conveniently breaks a returned pair up into 2 variables.
In the expression <code>let (_, gs')</code> we didn't care what the first value was so we used underscore.
Notice that nextTurn is capturing the updated game state from <code>chooseRandomMove</code> in the variable
<code>gs</code>, which it is then passing to <code>applyMove</code> which returns <code>gs'</code> which is passed to <code>isGameDone</code>
and that function returns <code>gs''</code> which we then return from <code>nextTurnManually</code>.  Phew, what a lot
of work you don't have to do when you use <code>do</code> notation!</p>
<h2 id="statem-vs-readerm"><a class="header" href="#statem-vs-readerm">StateM vs ReaderM</a></h2>
<p>While <code>ReaderM</code> functions can use <code>withReader</code> to modify the context before calling another function,
<code>StateM</code> functions are a little more powerful, let's look at this function again:</p>
<pre><code>def nextTurn : StateM GameState Bool := do
  let i ← chooseRandomMove
  applyMove i
  isGameDone
</code></pre>
<p>In this function <code>chooseRandomMove</code> is modifying the state that <code>applyMove</code> is getting
and <code>chooseRandomMove</code> knows nothing about <code>applyMove</code>.  So <code>StateM</code> functions can have this
kind of downstream effect outside their own scope, whereas, <code>withReader</code> cannot do that.</p>
<p>So there is no equivalent to <code>withReader</code> for <code>StateM</code>, besides you can always use the <code>StateM</code>
<code>set</code> function to modify the state before calling the next function anyway.  You could however,
manually call a <code>StateM</code> function like you see in <code>nextTurnManually</code> and completely override
the state at any point that way.</p>
<h2 id="state-io-and-other-languages"><a class="header" href="#state-io-and-other-languages">State, IO and other languages</a></h2>
<p>When thinking about Lean, it is often seen as a restriction that you can't have global variables or
<code>static</code> variables like you can with other languages like Python or C++. However, hopefully you see
now this isn't true. You can have a data type with exactly the same functionality as a Python class.
You would simply have many functions that can modify some global state using the <code>StateM</code> monad.</p>
<p>The difference is in Lean you simply put a label on these types of functions. You don't allow it to
happen for free anywhere in an uncontrolled fashion because that results in too many sleepless
nights debugging nasty code. You want to know when side effects can potentially happen, because
knowing when they can happen makes your code easier to reason about. In a Python class, many of the
methods won't actually need to modify the global state. But they could, which makes it harder to
debug them. In Lean you can simply make these pure functions, and the compiler will ensure they stay
pure and cannot modify any global state.</p>
<p>IO is the same way. It's not like you can't perform IO in Lean. Instead, you want to label the areas
where you can, to increase your certainty about the areas where you don't need to. When you know part of
your code cannot communicate with the outside world, you can be far more certain of its behavior.</p>
<p>The <code>StateM</code> monad is also a more disciplined way of managing side effects. Top level code could
call a <code>StateM</code> function multiple times with different independent initial states, even doing that
across multiple tasks in parallel and each of these cannot clobber the state belonging to other
tasks. Monadic code is more predictable and reusable than code that uses global variables.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>That wraps it up for the <code>StateM</code> monad! There is one more very useful monad that can be used to do
exception handling which will be covered in the <a href="monads/except.lean.html">next section</a>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="except"><a class="header" href="#except">Except</a></h1>
<p>The <code>Except</code> Monad adds exception handling behavior to your functions.  Exception handling
in other languages like Python or Java is done with a built in <code>throw</code> method that you
can use anywhere.  In <code>Lean</code> you can only <code>throw</code> an exception when your function is
executing in the context of an <code>Except</code> monad.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div><span class="nv">divide</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">): </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : outParam Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;can't divide by zero&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;can&#39;t divide by zero&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">/</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok <span class="mi">2</span><span class="bp">.</span><span class="mi">500000</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">  <span class="c1">-- Except.ok 2.500000</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">  <span class="c1">-- Except.error &quot;can&#39;t divide by zero&quot;</span></span></span></pre>
<p>Just as the <code>read</code> operation was available from the <code>ReaderM</code> monad and the <code>get</code> and <code>set</code>
operations came with the <code>StateM</code> monad, here you can see a <code>throw</code> operation is provided by the
<code>Except</code> monad.</p>
<p>So in Lean, <code>throw</code> is not available everywhere like it is in most imperative programming languages.
You have to declare your function can throw by changing the type signature to <code>Except String Float</code>.
This creates a function that might return an error of type <code>String</code> or it might return a value of
type <code>Float</code> in the non-error case.</p>
<p>Once your function is monadic you also need to use the <code>pure</code> constructor of the <code>Except</code> monad to
convert the pure non-monadic value <code>x / y</code> into the required <code>Except</code> object.  See
<a href="monads/applicatives.lean.html">Applicatives</a> for details on <code>pure</code>.</p>
<p>Now this return typing would get tedious if you had to include it everywhere that you call this
function, however, Lean type inference can clean this up. For example, you can define a test
function can calls the <code>divide</code> function and you don't need to say anything here about the fact that
it might throw an error, because that is inferred:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>test</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">test</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk2"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">test : Except String Float</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>test</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div>test</span><span class="alectryon-token">     <span class="c1">-- Except String Float</span></span></span></pre>
<p>Notice the Lean compiler infers the required <code>Except String Float</code> type information for you.
And now you can run this test and get the expected exception:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk3"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>test</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div>test</span><span class="alectryon-token">      <span class="c1">-- Except.error &quot;can&#39;t divide by zero&quot;</span></span></span></pre>
<h2 id="chaining"><a class="header" href="#chaining">Chaining</a></h2>
<p>Now as before you can build a chain of monadic actions that can be composed together using <code>bind (&gt;&gt;=)</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Float → Except String Float</span></span></div></blockquote></div></small></div><span class="nv">square</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>100</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">100</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : outParam Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;it's absolutely huge&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;it&#39;s absolutely huge&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok <span class="mi">9</span><span class="bp">.</span><span class="mi">000000</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Float → Except String Float</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">  <span class="c1">-- Except.ok 9.000000</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk5"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Float → Except String Float</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">  <span class="c1">-- Except.error &quot;can&#39;t divide by zero&quot;</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;it&#39;s absolutely huge&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>100</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">100</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Float → Except String Float</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">  <span class="c1">-- Except.error &quot;it&#39;s absolutely huge&quot;</span>

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>chainUsingDoNotation</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">chainUsingDoNotation</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Float → Except String Float</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk7"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>chainUsingDoNotation</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div>chainUsingDoNotation</span><span class="alectryon-token">  <span class="c1">-- Except.error &quot;can&#39;t divide by zero&quot;</span></span></span></pre>
<p>Notice in the second <code>divide 6 0</code> the exception from that division was nicely propagated along
to the final result and the square function was ignored in that case.  You can see why the
<code>square</code> function was ignored if you look at the implementation of <code>Except.bind</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bind</var><b>: </b><span>{ε : Type u_1} → {α : Type u_2} → {β : Type u_3} → Except ε α → (α → Except ε β) → Except ε β</span></span></div></blockquote></div></small></div><span class="nv">bind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>Except ε α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type u_1 → Type u_2 → Type (max u_1 u_2)</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ε</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">ε</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_2</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → Except ε β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_2</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type u_1 → Type u_3 → Type (max u_1 u_3)</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ε</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">ε</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_3</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type u_1 → Type u_3 → Type (max u_1 u_3)</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ε</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">ε</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_3</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ma</var><b>: </b><span>Except ε α</span></span></div></blockquote></div></small></div><span class="nv">ma</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except.error</var><b>: </b><span>{ε : Type ?u.923} → {α : Type ?u.922} → ε → Except ε α</span></span></div></blockquote></div></small></div>Except.error</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>err</var><b>: </b><span>ε</span></span></div></blockquote></div></small></div><span class="nv">err</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except.error</var><b>: </b><span>{ε : Type u_1} → {α : Type u_3} → ε → Except ε α</span></span></div></blockquote></div></small></div>Except.error</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>err</var><b>: </b><span>ε</span></span></div></blockquote></div></small></div><span class="nv">err</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except.ok</var><b>: </b><span>{ε : Type ?u.949} → {α : Type ?u.948} → α → Except ε α</span></span></div></blockquote></div></small></div>Except.ok</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">      <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → Except ε β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"></span></span></pre>
<p>Specifically notice that it only calls the next function <code>f v</code> in the <code>Except.ok</code>, and
in the error case it simply passes the same error along.</p>
<p>Remember also that you can chain the actions with implicit binding by using the <code>do</code> notation
as you see in the <code>chainUsingDoNotation</code> function above.</p>
<h2 id="trycatch"><a class="header" href="#trycatch">Try/Catch</a></h2>
<p>Now with all good exception handling you also want to be able to catch exceptions so your program
can continue on or do some error recovery task, which you can do like this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>testCatch</var><b>: </b><span>Except String String</span></span></div></blockquote></div></small></div><span class="nv">testCatch</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>8</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">8</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">  <span class="c1">-- &#39;r&#39; is type Float</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token">)
  </span><span class="alectryon-token"><span class="k">catch</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;Caught exception: {</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">}<span class="s2">&quot;</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk8"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">testCatch : Except String String</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>testCatch</var><b>: </b><span>Except String String</span></span></div></blockquote></div></small></div>testCatch</span><span class="alectryon-token"> <span class="c1">-- Except String String</span></span></span></pre>
<p>Note that the type inferred by Lean for this function is <code>Except String String</code> so unlike the
<code>test</code> function earlier, this time Lean type inference has figured out that since the pure
value <code>(toString r)</code> is of type <code>String</code>, then this function must have type <code>Except String String</code>
so you don't have to explicitly state this. You can always hover your mouse over <code>testCatch</code>
or use <code>#check testCatch</code> to query Lean interactively to figure out what type inference
has decided.  Lean type inference makes life easy for you, so it's good to use it
when you can.</p>
<p>You can now see the try/catch working in this eval:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chk9"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok <span class="s2">&quot;Caught exception: can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>testCatch</var><b>: </b><span>Except String String</span></span></div></blockquote></div></small></div>testCatch</span><span class="alectryon-token"> <span class="c1">-- Except.ok &quot;Caught exception: can&#39;t divide by zero&quot;</span></span></span></pre>
<p>Notice the <code>Caught exception:</code> wrapped message is returned, and that it is returned as an
<code>Except.ok</code> value, meaning <code>testCatch</code> eliminated the error result as expected.</p>
<p>So you've interleaved a new concept into your functions (exception handling) and the compiler is still
able to type check everything just as well as it does for pure functions and it's been able to infer
some things along the way to make it even easier to manage.</p>
<p>Now you might be wondering why <code>testCatch</code> doesn't infer the return type <code>String</code>? Lean does this as a
convenience since you could have a rethrow in or after the catch block. If you really want to stop
the <code>Except</code> type from bubbling up you can unwrap it like this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>testUnwrap</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">testUnwrap</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id.run</var><b>: </b><span>{α : Type} → Id α → α</span></span></div></blockquote></div></small></div>Id.run</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → Except String Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>8</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">8</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> <span class="c1">-- r is type Except String Float</span>
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.ok</var><b>: </b><span>{ε α : Type} → α → Except ε α</span></span></div></blockquote></div></small></div><span class="bp">.</span>ok</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="c1">-- &#39;a&#39; is type Float</span>
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.error</var><b>: </b><span>{ε α : Type} → ε → Except ε α</span></span></div></blockquote></div></small></div><span class="bp">.</span>error</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;Caught exception: {</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">}<span class="s2">&quot;</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chka"><span class="alectryon-token"><span class="k">#check</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">testUnwrap : String</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>testUnwrap</var><b>: </b><span>String</span></span></div></blockquote></div></small></div>testUnwrap</span><span class="alectryon-token"> <span class="c1">-- String</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chkb"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="s2">&quot;Caught exception: can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>testUnwrap</var><b>: </b><span>String</span></span></div></blockquote></div></small></div>testUnwrap</span><span class="alectryon-token"> <span class="c1">-- &quot;Caught exception: can&#39;t divide by zero&quot;</span></span></span></pre>
<p>The <code>Id.run</code> function is a helper function that executes the <code>do</code> block and returns the result where
<code>Id</code> is the <em>identity monad</em>.  So <code>Id.run do</code> is a pattern you can use to execute monads in a
function that is not itself monadic.  This works for all monads except <code>IO</code> which, as stated earlier,
you cannot invent out of thin air, you must use the <code>IO</code> monad given to your <code>main</code> function.</p>
<h2 id="monadic-functions"><a class="header" href="#monadic-functions">Monadic functions</a></h2>
<p>You can also write functions that are designed to operate in the context of a monad.
These functions typically end in upper case M like <code>List.forM</code> used below:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>validateList</var><b>: </b><span>List Nat → Nat → Except String Unit</span></span></div></blockquote></div></small></div><span class="nv">validateList</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>max</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">max</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">): </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forM</var><b>: </b><span>{m : Type → Type} → [inst : Monad m] → {α : Type} → List α → (α → m PUnit) → m PUnit</span></span></div></blockquote></div></small></div>forM</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>max</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">max</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : outParam Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;illegal value found in list&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;illegal value found in list&quot;</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chkc"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok ()
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>validateList</var><b>: </b><span>List Nat → Nat → Except String Unit</span></span></div></blockquote></div></small></div>validateList</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>8</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">8</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token"> <span class="c1">-- Except.ok ()</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="except-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="except-lean-chkd"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;illegal value found in list&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>validateList</var><b>: </b><span>List Nat → Nat → Except String Unit</span></span></div></blockquote></div></small></div>validateList</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>8</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">8</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> <span class="c1">-- Except.error &quot;illegal value found in list&quot;</span></span></span></pre>
<p>Notice here that the <code>List.forM</code> function passes the monadic context through to the inner function
so it can use the <code>throw</code> function from the <code>Except</code> monad.</p>
<p>The <code>List.forM</code> function is defined like this where <code>[Monad m]</code> means &quot;in the context of a monad <code>m</code>&quot;:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forM</var><b>: </b><span>{m : Type u_1 → Type u_2} → {α : Type u_3} → [inst : Monad m] → List α → (α → m PUnit) → m PUnit</span></span></div></blockquote></div></small></div><span class="nv">forM</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type ?u.2099 → Type ?u.2098) → Type (max (?u.2099 + 1) ?u.2098)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_3 → Type u_3</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_3</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → m PUnit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_3</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>PUnit</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div>PUnit</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>PUnit</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div>PUnit</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> []      <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>⟨⟩</var><b>: </b><span>PUnit</span></span></div></blockquote></div></small></div>⟨⟩</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → m PUnit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"><span class="bp">;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.forM</var><b>: </b><span>{m : Type u_1 → Type u_2} → [inst : Monad m] → {α : Type u_3} → List α → (α → m PUnit) → m PUnit</span></span></div></blockquote></div></small></div>List.forM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>as</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">as</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → m PUnit</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"></span></span></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Now that you know all these different monad constructs, you might be wondering how you can combine
them. What if there was some part of your state that you wanted to be able to modify (using the
State monad), but you also needed exception handling. How can you get multiple monadic capabilities
in the same function. To learn the answer, head to <a href="monads/transformers.lean.html">Monad Transformers</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monad-transformers-1"><a class="header" href="#monad-transformers-1">Monad Transformers</a></h1>
<p>In the previous sections you learned about some handy monads <a href="monads/monads.lean.html">Option</a>,
<a href="monads/monads.lean.html">IO</a>, <a href="monads/readers.lean.html">Reader</a>, <a href="monads/states.lean.html">State</a> and
<a href="monads/except.lean.html">Except</a>, and you now know how to make your function use one of these, but what you
do not yet know is how to make your function use multiple monads at once.</p>
<p>For example, suppose you need a function that wants to access some Reader context and optionally throw
an exception?  This would require composition of two monads <code>ReaderM</code> and <code>Except</code> and this is what
monad transformers are for.</p>
<p>A monad transformer is fundamentally a wrapper type. It is generally parameterized by another
monadic type. You can then run actions from the inner monad, while adding your own customized
behavior for combining actions in this new monad. The common transformers add <code>T</code> to the end of an
existing monad name. You will find <code>OptionT</code>, <code>ExceptT</code>, <code>ReaderT</code>, <code>StateT</code> but there is no transformer
for <code>IO</code>.  So generally if you need <code>IO</code> it becomes the innermost wrapped monad.</p>
<p>In the following example we use <code>ReaderT</code> to provide some read only context to a function
and this <code>ReaderT</code> transformer will wrap an <code>Except</code> monad.  If all goes well the
<code>requiredArgument</code> returns the value of a required argument and <code>optionalSwitch</code>
returns true if the optional argument is present.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Arguments</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">Arguments</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>indexOf?</var><b>: </b><span>{α : Type u_1} → [inst : BEq α] → List α → α → optParam Nat 0 → Option Nat</span></span></div></blockquote></div></small></div>indexOf<span class="bp">?</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BEq</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BEq</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>start</var><b>: </b><span>optParam Nat 0</span></span></div></blockquote></div></small></div><span class="nv">start</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">): </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>xs</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">xs</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> [] <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tail</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">tail</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>start</var><b>: </b><span>optParam Nat 0</span></span></div></blockquote></div></small></div><span class="nv">start</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>indexOf?</var><b>: </b><span>{α : Type u_1} → [inst : BEq α] → List α → α → optParam Nat 0 → Option Nat</span></span></div></blockquote></div></small></div>indexOf<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tail</var><b>: </b><span>List α</span></span></div></blockquote></div></small></div><span class="nv">tail</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>start</var><b>: </b><span>optParam Nat 0</span></span></div></blockquote></div></small></div><span class="nv">start</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>requiredArgument</var><b>: </b><span>String → ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div><span class="nv">requiredArgument</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ReaderT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Arguments</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Arguments</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>Arguments</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>read</var><b>: </b><span>{ρ : outParam Type} → {m : Type → Type} → [self : MonadReader ρ m] → m ρ</span></span></div></blockquote></div></small></div>read</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>indexOf?</var><b>: </b><span>{α : Type} → [inst : BEq α] → List α → α → optParam Nat 0 → Option Nat</span></span></div></blockquote></div></small></div>indexOf<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>Arguments</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type ?u.828} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>Arguments</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>{α : Type} → List α → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>Arguments</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token">[</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">+</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">]<span class="bp">!</span> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type ?u.1017} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : outParam Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw s!&quot;Command line argument {name} missing&quot;</var><b>: </b><span>ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw s!&quot;Command line argument {name} missing&quot;</var><b>: </b><span>ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div>s<span class="bp">!</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw s!&quot;Command line argument {name} missing&quot;</var><b>: </b><span>ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div><span class="s2">&quot;Command line argument {</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw s!&quot;Command line argument {name} missing&quot;</var><b>: </b><span>ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div>} missing<span class="s2">&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionalSwitch</var><b>: </b><span>String → ReaderT Arguments (Except String) Bool</span></span></div></blockquote></div></small></div><span class="nv">optionalSwitch</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ReaderT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Arguments</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Arguments</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>Arguments</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>read</var><b>: </b><span>{ρ : outParam Type} → {m : Type → Type} → [self : MonadReader ρ m] → m ρ</span></span></div></blockquote></div></small></div>read</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>indexOf?</var><b>: </b><span>{α : Type} → [inst : BEq α] → List α → α → optParam Nat 0 → Option Nat</span></span></div></blockquote></div></small></div>indexOf<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>Arguments</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type ?u.1570} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type ?u.1586} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok <span class="s2">&quot;foo&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>requiredArgument</var><b>: </b><span>String → ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div>requiredArgument</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--input&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--input&quot;</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{ρ : Type} → {m : Type → Type} → {α : Type} → ReaderT ρ m α → ρ → m α</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--input&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--input&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;foo&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;foo&quot;</span></span><span class="alectryon-token">]
<span class="c1">-- Except.ok &quot;foo&quot;</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;Command line argument --input missing&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>requiredArgument</var><b>: </b><span>String → ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div>requiredArgument</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--input&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--input&quot;</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{ρ : Type} → {m : Type → Type} → {α : Type} → ReaderT ρ m α → ρ → m α</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;foo&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;foo&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;bar&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;bar&quot;</span></span><span class="alectryon-token">]
<span class="c1">-- Except.error &quot;Command line argument --input missing&quot;</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionalSwitch</var><b>: </b><span>String → ReaderT Arguments (Except String) Bool</span></span></div></blockquote></div></small></div>optionalSwitch</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--help&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--help&quot;</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{ρ : Type} → {m : Type → Type} → {α : Type} → ReaderT ρ m α → ρ → m α</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--help&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--help&quot;</span></span><span class="alectryon-token">]
<span class="c1">-- Except.ok true</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk3"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionalSwitch</var><b>: </b><span>String → ReaderT Arguments (Except String) Bool</span></span></div></blockquote></div></small></div>optionalSwitch</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--help&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--help&quot;</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{ρ : Type} → {m : Type → Type} → {α : Type} → ReaderT ρ m α → ρ → m α</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
<span class="c1">-- Except.ok false</span></span></span></pre>
<p>Notice that <code>throw</code> was available from the inner <code>Except</code> monad. The cool thing is you can switch
this around and get the exact same result using <code>ExceptT</code> as the outer monad transformer and
<code>ReaderM</code> as the wrapped monad. Try changing requiredArgument to <code>ExceptT String (ReaderM Arguments) Bool</code>.</p>
<p>Note: the <code>|&gt;.</code> notation is described in <a href="monads/readers.lean.html#the-reader-solution">Readers</a>.</p>
<h2 id="adding-more-layers"><a class="header" href="#adding-more-layers">Adding more layers</a></h2>
<p>Here's the best part about monad transformers. Since the result of a monad transformer is itself a
monad, you can wrap it inside another transformer! Suppose you need to pass in some read only context
like the command line arguments, update some read-write state (like program Config) and optionally
throw an exception, then you could write this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Config</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Config</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>help</var><b>: </b><span>Config → Bool</span></span></div></blockquote></div></small></div>help</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>verbose</var><b>: </b><span>Config → Bool</span></span></div></blockquote></div></small></div>verbose</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>Config → String</span></span></div></blockquote></div></small></div>input</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="k">abbrev</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>CliConfigM</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div><span class="nv">CliConfigM</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>StateT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Config</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Config</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ReaderT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Arguments</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Arguments</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">))

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>parseArguments</var><b>: </b><span>CliConfigM Bool</span></span></div></blockquote></div></small></div><span class="nv">parseArguments</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>CliConfigM</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>CliConfigM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">mut</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>config</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">config</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>get</var><b>: </b><span>{σ : outParam Type} → {m : Type → Type} → [self : MonadState σ m] → m σ</span></span></div></blockquote></div></small></div>get</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← optionalSwitch &quot;--help&quot;)</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionalSwitch</var><b>: </b><span>String → ReaderT Arguments (Except String) Bool</span></span></div></blockquote></div></small></div><span class="nv">optionalSwitch</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← optionalSwitch &quot;--help&quot;)</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--help&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--help&quot;</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← optionalSwitch &quot;--help&quot;)</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : outParam Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;Usage: example [--help] [--verbose] [--input &lt;input file&gt;]&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;Usage: example [--help] [--verbose] [--input &lt;input file&gt;]&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>config</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">config</span></span><span class="alectryon-token"> := { </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>config</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">config</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    verbose := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← optionalSwitch &quot;--verbose&quot;)</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionalSwitch</var><b>: </b><span>String → ReaderT Arguments (Except String) Bool</span></span></div></blockquote></div></small></div><span class="nv">optionalSwitch</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← optionalSwitch &quot;--verbose&quot;)</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--verbose&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--verbose&quot;</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← optionalSwitch &quot;--verbose&quot;)</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token">,
    input := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← requiredArgument &quot;--input&quot;)</var><b>: </b><span>String</span></span></div></blockquote></div></small></div>(<span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>requiredArgument</var><b>: </b><span>String → ReaderT Arguments (Except String) String</span></span></div></blockquote></div></small></div><span class="nv">requiredArgument</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← requiredArgument &quot;--input&quot;)</var><b>: </b><span>String</span></span></div></blockquote></div></small></div> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--input&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--input&quot;</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(← requiredArgument &quot;--input&quot;)</var><b>: </b><span>String</span></span></div></blockquote></div></small></div>)</span><span class="alectryon-token"> }
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>set</var><b>: </b><span>{σ : semiOutParam Type} → {m : Type → Type} → [self : MonadStateOf σ m] → σ → m PUnit</span></span></div></blockquote></div></small></div>set</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>config</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">config</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">return</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>List String → IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>config</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">config</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Config</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Config</span><span class="alectryon-token"> := { input := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;default&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;default&quot;</span></span><span class="alectryon-token">}
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>parseArguments</var><b>: </b><span>CliConfigM Bool</span></span></div></blockquote></div></small></div>parseArguments</span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>config</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">config</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{ρ : Type} → {m : Type → Type} → {α : Type} → ReaderT ρ m α → ρ → m α</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>args</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div><span class="nv">args</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except.ok</var><b>: </b><span>{ε : Type ?u.4483} → {α : Type ?u.4482} → α → Except ε α</span></span></div></blockquote></div></small></div>Except.ok</span><span class="alectryon-token"> (_, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token">) <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;Processing input &#39;{</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>Config → String</span></span></div></blockquote></div></small></div>input</span><span class="alectryon-token">}<span class="bp">&#39;</span> <span class="k">with</span> verbose<span class="bp">=</span>{</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>Config</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>verbose</var><b>: </b><span>Config → Bool</span></span></div></blockquote></div></small></div>verbose</span><span class="alectryon-token">}<span class="s2">&quot;</span>
<span class="s2">  |</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except.error</var><b>: </b><span>{ε : Type ?u.4667} → {α : Type ?u.4666} → ε → Except ε α</span></span></div></blockquote></div></small></div>Except.error</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">


</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Usage: <span class="kd">example</span> [<span class="c1">--help] [--verbose] [--input &lt;input file&gt;]</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>List String → IO Unit</span></span></div></blockquote></div></small></div>main</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--help&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--help&quot;</span></span><span class="alectryon-token">]
<span class="c1">-- Usage: example [--help] [--verbose] [--input &lt;input file&gt;]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk5"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Processing input <span class="bp">&#39;</span>foo&#39; <span class="k">with</span> verbose<span class="bp">=</span>false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>List String → IO Unit</span></span></div></blockquote></div></small></div>main</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--input&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--input&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;foo&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;foo&quot;</span></span><span class="alectryon-token">]
<span class="c1">-- Processing input file &#39;foo&#39; with verbose=false</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Processing input <span class="bp">&#39;</span>bar&#39; <span class="k">with</span> verbose<span class="bp">=</span>true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main</var><b>: </b><span>List String → IO Unit</span></span></div></blockquote></div></small></div>main</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--verbose&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--verbose&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;--input&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;--input&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;bar&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;bar&quot;</span></span><span class="alectryon-token">]
<span class="c1">-- Processing input &#39;bar&#39; with verbose=true</span></span></span></pre>
<p>In this example <code>parseArguments</code> is actually three stacked monads, <code>StateM</code>, <code>ReaderM</code>, <code>Except</code>. Notice
the convention of abbreviating long monadic types with an alias like <code>CliConfigM</code>.</p>
<h2 id="monad-lifting"><a class="header" href="#monad-lifting">Monad Lifting</a></h2>
<p>Lean makes it easy to compose functions that use different monads using a concept of automatic monad
lifting.  You already used lifting in the above code, because you were able to compose
<code>optionalSwitch</code> which has type <code>ReaderT Arguments (Except String) Bool</code> and call it from
<code>parseArguments</code> which has a bigger type <code>StateT Config (ReaderT Arguments (Except String))</code>.
This &quot;just worked&quot; because Lean did some magic with monad lifting.</p>
<p>To give you a simpler example of this, suppose you have the following function:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → ExceptT String Id Float</span></span></div></blockquote></div></small></div><span class="nv">divide</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> ) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">): </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throw</var><b>: </b><span>{ε : outParam Type} → {m : Type → Type} → [self : MonadExcept ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throw</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;can't divide by zero&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;can&#39;t divide by zero&quot;</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">/</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk7"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok <span class="mi">2</span><span class="bp">.</span><span class="mi">000000</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → ExceptT String Id Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> <span class="c1">-- Except.ok 2.000000</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk8"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → ExceptT String Id Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> <span class="c1">-- Except.error &quot;can&#39;t divide by zero&quot;</span></span></span></pre>
<p>Notice here we used the <code>ExceptT</code> transformer, but we composed it with the <code>Id</code> identity monad.
This is then the same as writing <code>Except String Float</code> since the identity monad does nothing.</p>
<p>Now suppose you want to count the number of times divide is called and store the result in some
global state:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divideCounter</var><b>: </b><span>Float → Float → StateT Nat (ExceptT String Id) Float</span></span></div></blockquote></div></small></div><span class="nv">divideCounter</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>StateT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>modify</var><b>: </b><span>{σ : Type} → {m : Type → Type} → [inst : MonadState σ m] → (σ → σ) → m PUnit</span></span></div></blockquote></div></small></div>modify</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → ExceptT String Id Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chk9"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok (<span class="mi">2</span><span class="bp">.</span><span class="mi">000000</span>, <span class="mi">1</span>)
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divideCounter</var><b>: </b><span>Float → Float → StateT Nat (ExceptT String Id) Float</span></span></div></blockquote></div></small></div>divideCounter</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">    <span class="c1">-- Except.ok (2.000000, 1)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chka"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.error <span class="s2">&quot;can&#39;t divide by zero&quot;</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divideCounter</var><b>: </b><span>Float → Float → StateT Nat (ExceptT String Id) Float</span></span></div></blockquote></div></small></div>divideCounter</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">    <span class="c1">-- Except.error &quot;can&#39;t divide by zero&quot;</span></span></span></pre>
<p>The <code>modify</code> function is a helper which makes it easier to use <code>modifyGet</code> from the <code>StateM</code> monad.
But something interesting is happening here, <code>divideCounter</code> is returning the value of
<code>divide</code>, but the types don't match, yet it works?  This is monad lifting in action.</p>
<p>You can see this more clearly with the following test:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>liftTest</var><b>: </b><span>Except String Float → StateT Nat (Except String) Float</span></span></div></blockquote></div></small></div><span class="nv">liftTest</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>StateT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chkb"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok (<span class="mi">5</span><span class="bp">.</span><span class="mi">000000</span>, <span class="mi">3</span>)
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>liftTest</var><b>: </b><span>Except String Float → StateT Nat (Except String) Float</span></span></div></blockquote></div></small></div>liftTest</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → ExceptT String Id Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> <span class="c1">-- Except.ok (5.000000, 3)</span></span></span></pre>
<p>Notice that <code>liftTest</code> returned <code>x</code> without doing anything to it, yet that matched the return type
<code>StateT Nat (Except String) Float</code>.  Monad lifting is provided by monad transformers.  if you
<code>#print liftTest</code> you will see that Lean is implementing this using a call to a function named
<code>monadLift</code> from the <code>MonadLift</code> type class:</p>
<pre><code class="language-lean ignore">class MonadLift (m : Type u → Type v) (n : Type u → Type w) where
  monadLift : {α : Type u} → m α → n α
</code></pre>
<p>So <code>monadLift</code> is a function for lifting a computation from an inner <code>Monad m α </code> to an outer <code>Monad n α</code>.
You could replace <code>x</code> in <code>liftTest</code> with <code>monadLift x</code> if you want to be explicit about it.</p>
<p>The StateT monad transformer defines an instance of <code>MonadLift</code> like this:</p>
<pre><code class="language-lean">@[inline] protected def lift {α : Type u} (t : m α) : StateT σ m α :=
  fun s =&gt; do let a ← t; pure (a, s)

instance : MonadLift m (StateT σ m) := ⟨StateT.lift⟩
</code></pre>
<p>This means that any monad <code>m</code> can be wrapped in a <code>StateT</code> monad by using the function
<code>fun s =&gt; do let a ← t; pure (a, s)</code> that takes state <code>s</code>, runs the inner monad action <code>t</code>, and
returns the result and the new state in a pair <code>(a, s)</code> without making any changes to <code>s</code>.</p>
<p>Because <code>MonadLift</code> is a type class, Lean can automatically find the required <code>monadLift</code>
instances in order to make your code compile and in this way it was able to find the <code>StateT.lift</code>
function and use it to wrap the result of <code>divide</code> so that the correct type is returned from
<code>divideCounter</code>.</p>
<p>If you have an instance <code>MonadLift m n</code> that means there is a way to turn a computation that happens
inside of <code>m</code> into one that happens inside of <code>n</code> and (this is the key part) usually <em>without</em> the
instance itself creating any additional data that feeds into the computation. This means you can in
principle declare lifting instances from any monad to any other monad, it does not, however, mean
that you should do this in all cases.  You can get a very nice report on how all this was done by
adding the line <code>set_option trace.Meta.synthInstance true in</code> before <code>divideCounter</code> and moving you
cursor to the end of the first line after <code>do</code>.</p>
<p>This was a lot of detail, but it is very important to understand how monad lifting works because it
is used heavily in Lean programs.</p>
<h2 id="transitive-lifting"><a class="header" href="#transitive-lifting">Transitive lifting</a></h2>
<p>There is also a transitive version of <code>MonadLift</code> called <code>MonadLiftT</code> which can lift multiple
monad layers at once.  In the following example we added another monad layer with
<code>ReaderT String ...</code> and notice that <code>x</code> is also automatically lifted to match.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>liftTest2</var><b>: </b><span>Except String Float → ReaderT String (StateT Nat (Except String)) Float</span></span></div></blockquote></div></small></div><span class="nv">liftTest2</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ReaderT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ReaderT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>StateT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>StateT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Except</var><b>: </b><span>Type → Type → Type</span></span></div></blockquote></div></small></div>Except</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">)) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Except String Float</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chkc"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Except.ok (<span class="mi">5</span><span class="bp">.</span><span class="mi">000000</span>, <span class="mi">3</span>)
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>liftTest2</var><b>: </b><span>Except String Float → ReaderT String (StateT Nat (Except String)) Float</span></span></div></blockquote></div></small></div>liftTest2</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → ExceptT String Id Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">) <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{ρ : Type} → {m : Type → Type} → {α : Type} → ReaderT ρ m α → ρ → m α</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">
<span class="c1">-- Except.ok (5.000000, 3)</span></span></span></pre>
<p>The ReaderT monadLift is even simpler than the one for StateT:</p>
<pre><code class="language-lean ignore">instance  : MonadLift m (ReaderT ρ m) where
  monadLift x := fun _ =&gt; x
</code></pre>
<p>This lift operation creates a function that defines the required <code>ReaderT</code> input
argument, but the inner monad doesn't know or care about <code>ReaderT</code> so the
monadLift function throws it away with the <code>_</code> then calls the inner monad action <code>x</code>.
This is a perfectly legal implementation of the <code>ReaderM</code> monad.</p>
<h2 id="add-your-own-custom-monadlift"><a class="header" href="#add-your-own-custom-monadlift">Add your own Custom MonadLift</a></h2>
<p>This does not compile:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main2</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main2</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>?m.6175</span></span></div></blockquote></div></small></div><span class="nv">ret</span></span><span class="alectryon-token"> <span class="bp">←</span> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chkd"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divideCounter</var><b>: </b><span>Float → Float → StateT Nat (ExceptT String Id) Float</span></span></div></blockquote></div></small></div>divideCounter</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: type mismatch
  StateT.run (divideCounter <span class="mi">5</span> <span class="mi">2</span>) <span class="mi">0</span>
has type
  ExceptT String Id (Float <span class="bp">×</span> Nat) : <span class="kt">Type</span>
but is expected to <span class="k">have</span> type
  IO <span class="bp">?</span>m.6206 : <span class="kt">Type</span></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>?m.6175</span></span></div></blockquote></div></small></div><span class="nv">ret</span></span><span class="alectryon-token">)
  </span><span class="alectryon-token"><span class="k">catch</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>IO.Error</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>IO.Error</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"></span></span></pre>
<p>saying:</p>
<pre><code>typeclass instance problem is stuck, it is often due to metavariables
  ToString ?m.4786
</code></pre>
<p>The reason is <code>divideCounter</code> returns the big <code>StateT Nat (ExceptT String Id) Float</code> and that type
cannot be automatically lifted into the <code>main</code> return type of <code>IO Unit</code> unless you give it some
help.</p>
<p>The following custom <code>MonadLift</code> solves this problem:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>liftIO</var><b>: </b><span>{α : Type} → ExceptT String Id α → IO α</span></span></div></blockquote></div></small></div><span class="nv">liftIO</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>ExceptT String Id α</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>ExceptT String Id α</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.ok</var><b>: </b><span>{ε α : Type} → α → Except ε α</span></span></div></blockquote></div></small></div><span class="bp">.</span>ok</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>EStateM.Result.ok</var><b>: </b><span>{ε σ α : Type} → α → σ → EStateM.Result ε σ α</span></span></div></blockquote></div></small></div>EStateM.Result.ok</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.error</var><b>: </b><span>{ε α : Type} → ε → Except ε α</span></span></div></blockquote></div></small></div><span class="bp">.</span>error</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>EStateM.Result.error</var><b>: </b><span>{ε σ α : Type} → ε → σ → EStateM.Result ε σ α</span></span></div></blockquote></div></small></div>EStateM.Result.error</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>MonadLift (ExceptT String Id) IO</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>MonadLift</var><b>: </b><span>semiOutParam (Type → Type) → (Type → Type) → Type 1</span></span></div></blockquote></div></small></div>MonadLift</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ExceptT</var><b>: </b><span>Type → (Type → Type) → Type → Type</span></span></div></blockquote></div></small></div>ExceptT</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Id</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Id</span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  monadLift := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>liftIO</var><b>: </b><span>{α : Type} → ExceptT String Id α → IO α</span></span></div></blockquote></div></small></div>liftIO</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main3</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main3</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>Float × Nat</span></span></div></blockquote></div></small></div><span class="nv">ret</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divideCounter</var><b>: </b><span>Float → Float → StateT Nat (ExceptT String Id) Float</span></span></div></blockquote></div></small></div>divideCounter</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>run</var><b>: </b><span>{σ : Type} → {m : Type → Type} → {α : Type} → StateT σ m α → σ → m (α × σ)</span></span></div></blockquote></div></small></div>run</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>Float × Nat</span></span></div></blockquote></div></small></div><span class="nv">ret</span></span><span class="alectryon-token">)
  </span><span class="alectryon-token"><span class="k">catch</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>IO.Error</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>IO.Error</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chke"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(<span class="mi">2</span><span class="bp">.</span><span class="mi">500000</span>, <span class="mi">1</span>)
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main3</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div>main3</span><span class="alectryon-token"> <span class="c1">-- (2.500000, 1)</span></span></span></pre>
<p>It turns out that the <code>IO</code> monad you see in your <code>main</code> function is based on the <code>EStateM.Result</code> type
which is similar to the <code>Except</code> type but it has an additional return value. The <code>liftIO</code> function
converts any <code>Except String α</code> into <code>IO α</code> by simply mapping the ok case of the <code>Except</code> to the
<code>Result.ok</code> and the error case to the <code>Result.error</code>.</p>
<h2 id="lifting-exceptt"><a class="header" href="#lifting-exceptt">Lifting ExceptT</a></h2>
<p>In the previous <a href="monads/except.lean.html">Except</a> section you saw functions that <code>throw</code> Except
values. When you get all the way back up to your <code>main</code> function which has type <code>IO Unit</code> you have
the same problem you had above, because <code>Except String Float</code> doesn't match even if you use a
<code>try/catch</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main4</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div><span class="nv">main4</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>IO</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Unit</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Unit</span><span class="alectryon-token"> := </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">ret</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>divide</var><b>: </b><span>Float → Float → ExceptT String Id Float</span></span></div></blockquote></div></small></div>divide</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toString</var><b>: </b><span>{α : Type} → [self : ToString α] → α → String</span></span></div></blockquote></div></small></div>toString</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ret</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">ret</span></span><span class="alectryon-token">)  <span class="c1">-- lifting happens here.</span>
  </span><span class="alectryon-token"><span class="k">catch</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>IO.Error</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>IO.println</var><b>: </b><span>{α : Type} → [inst : ToString α] → α → IO Unit</span></span></div></blockquote></div></small></div>IO.println</span><span class="alectryon-token"> </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;Unhandled exception: {</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>IO.Error</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">}<span class="s2">&quot;</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="transformers-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="transformers-lean-chkf"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Unhandled exception: can&#39;t divide <span class="kd">by</span> zero
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>main4</var><b>: </b><span>IO Unit</span></span></div></blockquote></div></small></div>main4</span><span class="alectryon-token"> <span class="c1">-- Unhandled exception: can&#39;t divide by zero</span></span></span></pre>
<p>Without the <code>liftIO</code> the <code>(toString ret)</code> expression would not compile with a similar error:</p>
<pre><code>typeclass instance problem is stuck, it is often due to metavariables
  ToString ?m.6007
</code></pre>
<p>So the general lesson is that if you see an error like this when using monads, check for
a missing <code>MonadLift</code>.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Now that you know how to combine your monads together, you're almost done with understanding the key
concepts of monads! You could probably go out now and start writing some pretty nice code! But to
truly master monads, you should know how to make your own, and there's one final concept that you
should understand for that. This is the idea of type &quot;laws&quot;. Each of the structures you've learned
so far has a series of laws associated with it. And for your instances of these classes to make
sense, they should follow the laws! Check out <a href="monads/laws.lean.html">Monad Laws</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monad-laws-1"><a class="header" href="#monad-laws-1">Monad Laws</a></h1>
<p>In the previous sections you learned how to use <a href="monads/functors.lean.html">Functors</a>,
<a href="monads/applicatives.lean.html">Applicatives</a>, and <a href="monads/monads.lean.html">Monads</a>, and you played with some useful
instances including <a href="monads/monads.lean.html">Option</a>, <a href="monads/monads.lean.html">IO</a>, <a href="monads/readers.lean.html">Reader</a>,
<a href="monads/states.lean.html">State</a> and <a href="monads/except.lean.html">Except</a> and you learned about composition using <a href="monads/transformers.lean.html">Monad
Transformers</a>.</p>
<p>So far, you've learned the concrete details you need in order to <em>use</em> monads in your Lean programs.
But there's still one more important concept you need if you want to <em>create</em> new functors,
applicatives and monads. Namely, the notion of <em>structural &quot;laws&quot;</em> -- rules that these type
classes should follow in order to meet other programmers' expectations about your code.</p>
<h2 id="life-without-laws"><a class="header" href="#life-without-laws">Life without Laws</a></h2>
<p>Remember Lean represents each of these abstract structures by a type class. Each of these type classes
has one or two main functions. So, as long as you implement those functions and it type checks, you
have a new functor, applicative, or monad, right?</p>
<p>Well not quite. Yes, your program will compile and you'll be able to use the instances. But this
doesn't mean your instances follow the mathematical constructs. If they don't, your instances won't
fulfill other programmers' expectations. Each type class has its own &quot;laws&quot;. For instance, suppose
you have the following Point Functor:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BEq</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>BEq</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.map</var><b>: </b><span>{α β : Type} → (α → β) → Point α → Point β</span></span></div></blockquote></div></small></div><span class="nv">Point.map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Point α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  { x := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Point α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token">,  <span class="c1">-- an example of something weird</span>
    y := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Point α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"> }

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Functor Point</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  map := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.map</var><b>: </b><span>{α β : Type} → (α → β) → Point α → Point β</span></span></div></blockquote></div></small></div>Point.map</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{ x := <span class="mi">4</span>, y := <span class="mi">3</span> }
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+</span><span class="mi">2</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.mk</var><b>: </b><span>{α : Type} → α → α → Point α</span></span></div></blockquote></div></small></div>Point.mk</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">) <span class="c1">-- { x := 4, y := 3 }</span></span></span></pre>
<p>This Point does something weird, when you <code>map</code> it because it transposes the <code>x</code> and <code>y</code> coordinates
which is not what other people would expect from a <code>map</code> function.  In fact, it breaks the rules
as you will see below.</p>
<h2 id="what-are-the-functor-laws"><a class="header" href="#what-are-the-functor-laws">What are the Functor laws?</a></h2>
<p>Functors have two laws: the <em>identity</em> law, and the <em>composition</em> law. These laws express behaviors that
your functor instances should follow. If they don't, other programmers will be very confused at the
effect your instances have on their program.</p>
<p>The identity law says that if you &quot;map&quot; the identity function (<code>id</code>) over your functor, the
resulting functor should be the same. A succinct way of showing this on a <code>List</code> functor is:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">list1</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token"> <span class="c1">-- true</span></span></span></pre>
<p>Now let's try the same test on the <code>Point</code> functor:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div><span class="nv">p1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.mk</var><b>: </b><span>{α : Type} → α → α → Point α</span></span></div></blockquote></div></small></div>Point.mk</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token"> <span class="c1">-- false</span></span></span></pre>
<p>Oh, and look while the <code>List</code> is behaving well, the <code>Point</code> functor fails this identity test.</p>
<p>The <em>composition</em> law says that if you &quot;map&quot; two functions in succession over a functor, this
should be the same as &quot;composing&quot; the functions and simply mapping that one super-function over the
functor.  In Lean you can compose two functions using <code>Function.comp f g</code> (or the syntax <code>f ∘ g</code>,
which you can type in VS code using <code>\o </code>) and you will get the same results from both of these
showing that the composition law holds for <code>List Nat</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">double</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">square</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk3"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">2</span>, <span class="mi">8</span>, <span class="mi">18</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token">) <span class="c1">-- [2, 8, 18]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token">)) <span class="bp">==</span> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token">) <span class="c1">-- true</span>

<span class="c1">-- ok, what about the Point class?</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk5"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{ x := <span class="mi">2</span>, y := <span class="mi">8</span> }
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">) <span class="c1">-- { x := 2, y := 8 }</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{ x := <span class="mi">8</span>, y := <span class="mi">2</span> }
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">   <span class="c1">-- { x := 8, y := 2 }</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk7"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">) <span class="bp">==</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">  <span class="c1">-- false</span></span></span></pre>
<p>Note that composition also fails on the bad <code>Point</code> because the x/y transpose.</p>
<p>As you can see this bad <code>Point</code> implementation violates both of the functor laws. In this case it
would not be a true functor. Its behavior would confuse any other programmers trying to use it. You
should take care to make sure that your instances make sense. Once you get a feel for these type
classes, the likelihood is that the instances you'll create will follow the laws.</p>
<p>You can also write a bad functor that passes one law but not the other like this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bad_option_map</var><b>: </b><span>{α β : Type u} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div><span class="nv">bad_option_map</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">} : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
  <span class="bp">|</span> _, _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type u} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Functor Option</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
    map := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bad_option_map</var><b>: </b><span>{α β : Type u_1} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div>bad_option_map</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div><span class="nv">t1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk8"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token"> <span class="c1">-- false</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk9"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token">) <span class="bp">==</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token">  <span class="c1">-- true</span></span></span></pre>
<p>This fails the id law but obeys the composition law. Hopefully this explains the value of these
laws, and you don't need to see any more bad examples!</p>
<h2 id="what-are-the-applicative-laws"><a class="header" href="#what-are-the-applicative-laws">What are the Applicative Laws?</a></h2>
<p>While functors have two laws, applicatives have four laws:</p>
<ul>
<li>Identity</li>
<li>Homomorphism</li>
<li>Interchange</li>
<li>Composition</li>
</ul>
<h3 id="identity"><a class="header" href="#identity">Identity</a></h3>
<p><code>pure id &lt;*&gt; v = v</code></p>
<p>Applying the identity function through an applicative structure should not change the underlying
values or structure.  For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Applicative List</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.pure</var><b>: </b><span>{α : Type u_1} → α → List α</span></span></div></blockquote></div></small></div>List.pure</span><span class="alectryon-token">
  seq </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>List (α✝ → β✝)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Unit → List α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.bind</var><b>: </b><span>{α β : Type u_1} → List α → (α → List β) → List β</span></span></div></blockquote></div></small></div>List.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>List (α✝ → β✝)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor.map</var><b>: </b><span>{f : Type u_1 → Type u_1} → [self : Functor f] → {α β : Type u_1} → (α → β) → f α → f β</span></span></div></blockquote></div></small></div>Functor.map</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Unit → List α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chka"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]  <span class="c1">-- [1, 2, 3]</span></span></span></pre>
<p>The <code>pure id</code> statement here is wrapping the identity function in an applicative structure
so that you can apply that over the container <code>[1, 2, 3]</code> using the Applicative <code>seq</code> operation
which has the notation <code>&lt;*&gt;</code>.</p>
<p>To prove this for all values <code>v</code> and any applicative <code>m</code> you can write this theorem:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Applicative m] [inst_1 : LawfulApplicative m] (v : m α),
  (Seq.seq (pure id) fun x =&gt; v) = v</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type u_1 → Type u_2) → Type (max (u_1 + 1) u_2)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulApplicative</var><b>: </b><span>(f : Type u_1 → Type u_2) → [inst : Applicative f] → Prop</span></span></div></blockquote></div></small></div>LawfulApplicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type u_1} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> :=
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkb"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkc"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="c1">-- Goals accomplished 🎉</span></span></span></pre>
<h3 id="homomorphism"><a class="header" href="#homomorphism">Homomorphism</a></h3>
<p><code>pure f &lt;*&gt; pure x = pure (f x)</code></p>
<p>Suppose you wrap a function and an object in <code>pure</code>. You can then apply the wrapped function over the
wrapped object. Of course, you could also apply the normal function over the normal object, and then
wrap it in <code>pure</code>. The homomorphism law states these results should be the same.</p>
<p>For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· + 2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">+</span> <span class="mi">2</span>)</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkd"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>f</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>f</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) <span class="c1">-- true</span></span></span></pre>
<p>You should see a distinct pattern here. The overriding theme of almost all these laws is that these
<code>Applicative</code> types should behave like normal containers. The <code>Applicative</code> functions should not
have any side effects. All they should do is facilitate the wrapping, unwrapping, and transformation
of data contained in the container resulting in a new container that has the same structure.</p>
<h3 id="interchange"><a class="header" href="#interchange">Interchange</a></h3>
<p><code>u &lt;*&gt; pure y = pure (. y) &lt;*&gt; u</code>.</p>
<p>This law is is a little more complicated, so don't sweat it too much. It states that the order that
you wrap things shouldn't matter. One the left, you apply any applicative <code>u</code> over a pure wrapped
object. On the right, you first wrap a function applying the object as an argument. Note that <code>(· y)</code> is short hand for: <code>fun f =&gt; f y</code>. Then you apply this to the first applicative <code>u</code>. These
should be the same.</p>
<p>For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>List (Nat → Nat)</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· + 2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">+</span> <span class="mi">2</span>)</span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chke"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>List (Nat → Nat)</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token">) <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>List (Nat → Nat)</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token">      <span class="c1">-- true</span></span></span></pre>
<p>You can prove this with the following theorem:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Applicative m] [inst_1 : LawfulApplicative m] (u : m (α → β))
  (y : α), (Seq.seq u fun x =&gt; pure y) = Seq.seq (pure fun x =&gt; x y) fun x =&gt; u</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type ?u.4140 → Type ?u.4139) → Type (max (?u.4140 + 1) ?u.4139)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulApplicative</var><b>: </b><span>(f : Type u_1 → Type u_2) → [inst : Applicative f] → Prop</span></span></div></blockquote></div></small></div>LawfulApplicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>m (α → β)</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>m (α → β)</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">) <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>m (α → β)</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> :=
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkf"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk10"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure_seq</var><b>: </b><span>∀ {f : Type ?u.4369 → Type ?u.4368} [inst : Applicative f] [self : LawfulApplicative f] {α β : Type ?u.4369} (g : α → β)
  (x : f α), (Seq.seq (pure g) fun x_1 =&gt; x) = g &lt;$&gt; x</span></span></div></blockquote></div></small></div>pure_seq</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="c1">-- Goals accomplished 🎉</span></span></span></pre>
<h3 id="composition"><a class="header" href="#composition">Composition:</a></h3>
<p><code>u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></p>
<p>This final applicative law mimics the second functor law. It is a composition law. It states that
function composition holds across applications within the applicative:</p>
<p>For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">]
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">]
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>w</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">w</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk11"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">9</span>, <span class="mi">10</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">11</span>, <span class="mi">12</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·+·)</var><b>: </b><span>Nat → Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>u</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>v</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>w</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>w</span><span class="alectryon-token">
<span class="c1">-- [9, 10, 10, 11, 10, 11, 11, 12]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk12"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">9</span>, <span class="mi">10</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">11</span>, <span class="mi">12</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>grouping</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">grouping</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>v</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>w</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>w</span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>u</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>grouping</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">grouping</span></span><span class="alectryon-token">
<span class="c1">-- [9, 10, 10, 11, 10, 11, 11, 12]</span></span></span></pre>
<p>To test composition you see the separate grouping <code>(v &lt;*&gt; w)</code> then that can be used in the outer
sequence <code>u &lt;*&gt; grouping</code> to get the same final result <code>[9, 10, 10, 11, 10, 11, 11, 12]</code>.</p>
<h2 id="what-are-the-monad-laws"><a class="header" href="#what-are-the-monad-laws">What are the Monad Laws?</a></h2>
<p>Monads have three laws:</p>
<ul>
<li>Left Identity</li>
<li>Right Identity</li>
<li>Associativity</li>
</ul>
<h3 id="left-identity"><a class="header" href="#left-identity">Left Identity</a></h3>
<p>Identity laws for monads specify that <code>pure</code> by itself shouldn't really change anything about the
structure or its values.</p>
<p>Left identity is <code>x &gt;&gt;= pure = x</code> and is demonstrated by the following examples on a monadic <code>List</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Monad List</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token">  </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.pure</var><b>: </b><span>{α : Type u_1} → α → List α</span></span></div></blockquote></div></small></div>List.pure</span><span class="alectryon-token">
  bind := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.bind</var><b>: </b><span>{α β : Type u_1} → List α → (α → List β) → List β</span></span></div></blockquote></div></small></div>List.bind</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;apple&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;apple&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;orange&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;orange&quot;</span></span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk13"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="s2">&quot;apple&quot;</span>, <span class="s2">&quot;orange&quot;</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token">      <span class="c1">-- [&quot;apple&quot;, &quot;orange&quot;]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk14"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token">  <span class="c1">-- true</span></span></span></pre>
<h3 id="right-identity"><a class="header" href="#right-identity">Right Identity</a></h3>
<p>Right identity is <code>pure x &gt;&gt;= f = f x</code> and is demonstrated by the following example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk15"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">6</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token">                  <span class="c1">-- some 6</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk16"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">6</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token">                           <span class="c1">-- some 6</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk17"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token">            <span class="c1">-- true</span></span></span></pre>
<p>So in this example, with this specific <code>z</code> and <code>h</code>, you see that the rule holds true.</p>
<h3 id="associativity"><a class="header" href="#associativity">Associativity</a></h3>
<p>The associativity law is written as:</p>
<pre><code class="language-lean ignore">  x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= (λ x =&gt; f x &gt;&gt;= g)
</code></pre>
<p>where <code>(x : m α)</code> and <code>(f : α → m β)</code> and <code>(g : β → m γ)</code>.</p>
<p>The associativity law is difficult to parse like some of the applicative laws, but what it is saying
is that if you change the grouping of <code>bind</code> operations, you should still get the same result.
This law has a parallel structure to the other composition laws.</p>
<p>You can see this in action in the following rewrite of <code>runOptionFuncsBind</code> from <a href="monads/monads.lean.html">monads</a>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div><span class="nv">optionFunc1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> <span class="bp">-&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div><span class="nv">optionFunc2</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">%</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toFloat</var><b>: </b><span>Nat → Float</span></span></div></blockquote></div></small></div>toFloat</span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3.14159</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">3</span><span class="bp">.</span><span class="mi">14159</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">optionFunc3</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>15.0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">15</span><span class="bp">.</span><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>floor</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div>floor</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div>toUInt32</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div>toNat</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ceil</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div>ceil</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div>toUInt32</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div>toNat</span><span class="alectryon-token">]


</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBind</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">runOptionFuncsBind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div>optionFunc1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div>optionFunc2</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div>optionFunc3</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBindGrouped</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">runOptionFuncsBindGrouped</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div>optionFunc1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div>optionFunc2</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div>optionFunc3</span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk18"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some [<span class="mi">9</span>, <span class="mi">10</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBind</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div>runOptionFuncsBind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;big&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;big&quot;</span></span><span class="alectryon-token">        <span class="c1">-- some [9, 10]</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk19"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some [<span class="mi">9</span>, <span class="mi">10</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBindGrouped</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div>runOptionFuncsBindGrouped</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;big&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;big&quot;</span></span><span class="alectryon-token"> <span class="c1">-- some [9, 10]</span></span></span></pre>
<p>Notice here we had to insert a <code>λ</code> function just like the definition says: <code>(λ x =&gt; f x &gt;&gt;= g)</code>.
This is because unlike applicatives, you can't resolve the structure of later operations without the
results of earlier operations quite as well because of the extra context monads provide. But you can
still group their later operations into composite functions taking their inputs from earlier on, and
the result should be the same.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>While these laws may be a bit difficult to understand just by looking at them, the good news is that
most of the instances you'll make will naturally follow the laws so long as you keep it simple, so
you shouldn't have to worry about them too much.</p>
<p>There are two main ideas from all the laws:</p>
<ol>
<li>Applying the identity or pure function should not change the underlying values or structure.</li>
<li>It should not matter what order you group operations in.  Another way to state this is function
composition should hold across your structures.</li>
</ol>
<p>Following these laws will ensure other programmers are not confused by the behavior of your
new functors, applicatives and monads.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre><div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h3 id="what-is-lean-1"><a class="header" href="#what-is-lean-1">What is Lean?</a></h3>
<p>Lean is a new open source theorem prover being developed at Microsoft Research.
It is a research project that aims to bridge the gap between interactive and automated theorem proving.
Lean can be also used as a programming language. Actually, some Lean features are implemented in Lean itself.</p>
<h3 id="should-i-use-lean"><a class="header" href="#should-i-use-lean">Should I use Lean?</a></h3>
<p>Lean is under heavy development, and we are constantly trying new
ideas and tweaking the system.  It is a research project and not a product.
Things change rapidly, and we constantly break backward compatibility.
Lean comes &quot;as is&quot;, you should not expect we will fix bugs and/or add new features for your project.
We have our own priorities, and will not change them to accommodate your needs.
Even if you implement a new feature or fix a bug, we may not want to merge it because
it may conflict with our plans for Lean, it may not be performant, we may not want to maintain it,
we may be busy, etc. If you really need this new feature or bug fix, we suggest you create your own fork and maintain it yourself.</p>
<h3 id="where-is-the-documentation"><a class="header" href="#where-is-the-documentation">Where is the documentation?</a></h3>
<p>This is the Lean 4 manual. It is a work in progress, but it will eventually cover the whole language.
A public and very active chat room dedicated to Lean is open on <a href="https://leanprover.zulipchat.com">Zulip</a>.
It is a good place to interact with other Lean users.</p>
<h3 id="should-i-use-lean-to-teach-a-course"><a class="header" href="#should-i-use-lean-to-teach-a-course">Should I use Lean to teach a course?</a></h3>
<p>Lean has been used to teach courses on logic, type theory and programming languages at CMU and the University of Washington.
The lecture notes for the CMU course <a href="https://lean-lang.org/logic_and_proof">Logic and Proof</a> are available online,
but they are for Lean 3.
If you decide to teach a course using Lean, we suggest you prepare all material before the beginning of the course, and
make sure that Lean attends all your needs. You should not expect we will fix bugs and/or add features needed for your course.</p>
<h3 id="are-there-ides-for-lean"><a class="header" href="#are-there-ides-for-lean">Are there IDEs for Lean?</a></h3>
<p>Yes, see <a href="./setup.html">Setting Up Lean</a>.</p>
<h3 id="is-lean-sound-how-big-is-the-kernel-should-i-trust-it"><a class="header" href="#is-lean-sound-how-big-is-the-kernel-should-i-trust-it">Is Lean sound? How big is the kernel? Should I trust it?</a></h3>
<p>Lean has a relatively small kernel.
Several independent checkers have been implemented for Lean 3. Two of them are
<a href="https://github.com/leanprover/tc">tc</a> and <a href="https://github.com/gebner/trepplein">trepplein</a>.
We expect similar independent checkers will be built for Lean 4.</p>
<h3 id="should-i-open-a-new-issue"><a class="header" href="#should-i-open-a-new-issue">Should I open a new issue?</a></h3>
<p>We use <a href="https://github.com/leanprover/lean4/issues">GitHub</a> to track bugs and new features.
Bug reports are always welcome, but nitpicking issues are not (e.g., the error message is confusing).
See also our <a href="https://github.com/leanprover/lean4/blob/master/CONTRIBUTING.md">contribution guidelines</a>.</p>
<h3 id="is-it-lean-lean-or-ln"><a class="header" href="#is-it-lean-lean-or-ln">Is it Lean, LEAN, or L∃∀N?</a></h3>
<p>We always use &quot;Lean&quot; in writing.
When specifying a major version number, we append it together with a single space: Lean 4.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="significant-changes-from-lean-3"><a class="header" href="#significant-changes-from-lean-3">Significant changes from Lean 3</a></h1>
<p>Lean 4 is not backward compatible with Lean 3.
We have rewritten most of the system, and took the opportunity to cleanup the syntax,
metaprogramming framework, and elaborator. In this section, we go over the most significant
changes.</p>
<h2 id="lambda-expressions-1"><a class="header" href="#lambda-expressions-1">Lambda expressions</a></h2>
<p>We do not use <code>,</code> anymore to separate the binders from the lambda expression body.
The Lean 3 syntax for lambda expressions was unconventional, and <code>,</code> has been overused in Lean 3.
For example, we believe a list of lambda expressions is quite confusing in Lean 3, since <code>,</code> is used
to separate the elements of a list, and in the lambda expression itself. We now use <code>=&gt;</code> as the separator,
as an example, <code>fun x =&gt; x</code> is the identity function. One may still use the symbol <code>λ</code> as a shorthand for <code>fun</code>.
The lambda expression notation has many new features that are not supported in Lean 3.</p>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern matching</a></h2>
<p>In Lean 4, one can easily create new notation that abbreviates commonly used idioms. One of them is a
<code>fun</code> followed by a <code>match</code>. In the following examples, we define a few functions using <code>fun</code>+<code>match</code> notation.</p>
<pre><code class="language-lean"><span class="boring">namespace ex1
</span>def Prod.str : Nat × Nat → String :=
  fun (a, b) =&gt; &quot;(&quot; ++ toString a ++ &quot;, &quot; ++ toString b ++ &quot;)&quot;

structure Point where
  x : Nat
  y : Nat
  z : Nat

def Point.addX : Point → Point → Nat :=
  fun { x := a, .. } { x := b, .. } =&gt;  a+b

def Sum.str : Option Nat → String :=
  fun
    | some a =&gt; &quot;some &quot; ++ toString a
    | none   =&gt; &quot;none&quot;
<span class="boring">end ex1
</span></code></pre>
<h2 id="implicit-lambdas"><a class="header" href="#implicit-lambdas">Implicit lambdas</a></h2>
<p>In Lean 3 stdlib, we find many <a href="https://github.com/leanprover/lean/blob/master/library/init/category/reader.lean#L39">instances</a> of the dreadful <code>@</code>+<code>_</code> idiom.
It is often used when the expected type is a function type with implicit arguments,
and we have a constant (<code>reader_t.pure</code> in the example) which also takes implicit arguments. In Lean 4, the elaborator automatically introduces lambdas
for consuming implicit arguments. We are still exploring this feature and analyzing its impact, but the experience so far has been very positive. As an example,
here is the example in the link above using Lean 4 implicit lambdas.</p>
<pre><code class="language-lean"><span class="boring">variable (ρ : Type) (m : Type → Type) [Monad m]
</span>instance : Monad (ReaderT ρ m) where
  pure := ReaderT.pure
  bind := ReaderT.bind
</code></pre>
<p>Users can disable the implicit lambda feature by using <code>@</code> or writing a lambda expression with <code>{}</code> or <code>[]</code> binder annotations.
Here are few examples</p>
<pre><code class="language-lean"><span class="boring">namespace ex2
</span>def id1 : {α : Type} → α → α :=
  fun x =&gt; x

def listId : List ({α : Type} → α → α) :=
  (fun x =&gt; x) :: []

-- In this example, implicit lambda introduction has been disabled because
-- we use `@` before `fun`
def id2 : {α : Type} → α → α :=
  @fun α (x : α) =&gt; id1 x

def id3 : {α : Type} → α → α :=
  @fun α x =&gt; id1 x

def id4 : {α : Type} → α → α :=
  fun x =&gt; id1 x

-- In this example, implicit lambda introduction has been disabled
-- because we used the binder annotation `{...}`
def id5 : {α : Type} → α → α :=
  fun {α} x =&gt; id1 x
<span class="boring">end ex2
</span></code></pre>
<h2 id="sugar-for-simple-functions"><a class="header" href="#sugar-for-simple-functions">Sugar for simple functions</a></h2>
<p>In Lean 3, we can create simple functions from infix operators by using parentheses. For example, <code>(+1)</code> is sugar for <code>fun x, x + 1</code>. In Lean 4, we generalize this notation using <code>·</code> as a placeholder. Here are a few examples:</p>
<pre><code class="language-lean"><span class="boring">namespace ex3
</span>#check (· + 1)
-- fun a =&gt; a + 1
#check (2 - ·)
-- fun a =&gt; 2 - a
#eval [1, 2, 3, 4, 5].foldl (·*·) 1
-- 120

def f (x y z : Nat) :=
  x + y + z

#check (f · 1 ·)
-- fun a b =&gt; f a 1 b

#eval [(1, 2), (3, 4), (5, 6)].map (·.1)
-- [1, 3, 5]
<span class="boring">end ex3
</span></code></pre>
<p>As in Lean 3, the notation is activated using parentheses, and the lambda abstraction is created by collecting the nested <code>·</code>s.
The collection is interrupted by nested parentheses. In the following example, two different lambda expressions are created.</p>
<pre><code class="language-lean">#check (Prod.mk · (· + 1))
-- fun a =&gt; (a, fun b =&gt; b + 1)
</code></pre>
<h2 id="function-applications"><a class="header" href="#function-applications">Function applications</a></h2>
<p>In Lean 4, we have support for named arguments.
Named arguments enable you to specify an argument for a parameter by matching the argument with
its name rather than with its position in the parameter list.
If you don't remember the order of the parameters but know their names,
you can send the arguments in any order. You may also provide the value for an implicit parameter when
Lean failed to infer it. Named arguments also improve the readability of your code by identifying what
each argument represents.</p>
<pre><code class="language-lean">def sum (xs : List Nat) :=
  xs.foldl (init := 0) (·+·)

#eval sum [1, 2, 3, 4]
-- 10

example {a b : Nat} {p : Nat → Nat → Nat → Prop} (h₁ : p a b b) (h₂ : b = a)
    : p a a b :=
  Eq.subst (motive := fun x =&gt; p a x b) h₂ h₁
</code></pre>
<p>In the following examples, we illustrate the interaction between named and default arguments.</p>
<pre><code class="language-lean">def f (x : Nat) (y : Nat := 1) (w : Nat := 2) (z : Nat) :=
  x + y + w - z

example (x z : Nat) : f (z := z) x = x + 1 + 2 - z := rfl

example (x z : Nat) : f x (z := z) = x + 1 + 2 - z := rfl

example (x y : Nat) : f x y = fun z =&gt; x + y + 2 - z := rfl

example : f = (fun x z =&gt; x + 1 + 2 - z) := rfl

example (x : Nat) : f x = fun z =&gt; x + 1 + 2 - z := rfl

example (y : Nat) : f (y := 5) = fun x z =&gt; x + 5 + 2 - z := rfl

def g {α} [Add α] (a : α) (b? : Option α := none) (c : α) : α :=
  match b? with
  | none   =&gt; a + c
  | some b =&gt; a + b + c

variable {α} [Add α]

example : g = fun (a c : α) =&gt; a + c := rfl

example (x : α) : g (c := x) = fun (a : α) =&gt; a + x := rfl

example (x : α) : g (b? := some x) = fun (a c : α) =&gt; a + x + c := rfl

example (x : α) : g x = fun (c : α) =&gt; x + c := rfl

example (x y : α) : g x y = fun (c : α) =&gt; x + y + c := rfl
</code></pre>
<p>In Lean 4, we can use <code>..</code> to provide missing explicit arguments as <code>_</code>.
This feature combined with named arguments is useful for writing patterns. Here is an example:</p>
<pre><code class="language-lean">inductive Term where
  | var    (name : String)
  | num    (val : Nat)
  | add    (fn : Term) (arg : Term)
  | lambda (name : String) (type : Term) (body : Term)

def getBinderName : Term → Option String
  | Term.lambda (name := n) .. =&gt; some n
  | _ =&gt; none

def getBinderType : Term → Option Term
  | Term.lambda (type := t) .. =&gt; some t
  | _ =&gt; none
</code></pre>
<p>Ellipsis are also useful when explicit argument can be automatically inferred by Lean, and we want
to avoid a sequence of <code>_</code>s.</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b c : Nat) : f (a + b + c) = f (a + (b + c)) :=
  congrArg f (Nat.add_assoc ..)
</code></pre>
<p>In Lean 4, writing <code>f(x)</code> in place of <code>f x</code> is no longer allowed, you must use whitespace between the function and its arguments (e.g., <code>f (x)</code>).</p>
<h2 id="dependent-function-types"><a class="header" href="#dependent-function-types">Dependent function types</a></h2>
<p>Given <code>α : Type</code> and <code>β : α → Type</code>, <code>(x : α) → β x</code> denotes the type of functions <code>f</code> with the property that,
for each <code>a : α</code>, <code>f a</code> is an element of <code>β a</code>. In other words, the type of the value returned by <code>f</code> depends on its input.
We say <code>(x : α) → β x</code> is a dependent function type. In Lean 3, we write the dependent function type <code>(x : α) → β x</code> using
one of the following three equivalent notations:
<code>forall x : α, β x</code> or <code>∀ x : α, β x</code> or <code>Π x : α, β x</code>.
The first two were intended to be used for writing propositions, and the latter for writing code.
Although the notation <code>Π x : α, β x</code> has historical significance, we have removed it from Lean 4 because
it is awkward to use and often confuses new users. We can still write <code>forall x : α, β x</code> and <code>∀ x : α, β x</code>.</p>
<pre><code class="language-lean">#check forall (α : Type), α → α
#check ∀ (α : Type), α → α
#check ∀ α : Type, α → α
#check ∀ α, α → α
#check (α : Type) → α → α
#check {α : Type} → (a : Array α) → (i : Nat) → i &lt; a.size → α
#check {α : Type} → [ToString α] → α → String
#check forall {α : Type} (a : Array α) (i : Nat), i &lt; a.size → α
#check {α β : Type} → α → β → α × β
</code></pre>
<h2 id="the-meta-keyword"><a class="header" href="#the-meta-keyword">The <code>meta</code> keyword</a></h2>
<p>In Lean 3, the keyword <code>meta</code> is used to mark definitions that can use primitives implemented in C/C++.
These metadefinitions can also call themselves recursively, relaxing the termination
restriction imposed by ordinary type theory. Metadefinitions may also use unsafe primitives such as
<code>eval_expr (α : Type u) [reflected α] : expr → tactic α</code>, or primitives that break referential transparency
<code>tactic.unsafe_run_io</code>.</p>
<p>The keyword <code>meta</code> has been currently removed from Lean 4. However, we may re-introduce it in the future,
but with a much more limited purpose: marking meta code that should not be included in the executables produced by Lean.</p>
<p>The keyword <code>constant</code> has been deleted in Lean 4, and <code>axiom</code> should be used instead. In Lean 4, the new command <code>opaque</code> is used to define an opaque definition. Here are two simple examples:</p>
<pre><code class="language-lean"><span class="boring">namespace meta1
</span>opaque x : Nat := 1
-- The following example will not type check since `x` is opaque
-- example : x = 1 := rfl

-- We can evaluate `x`
#eval x
-- 1

-- When no value is provided, the elaborator tries to build one automatically for us
-- using the `Inhabited` type class
opaque y : Nat
<span class="boring">end meta1
</span></code></pre>
<p>We can instruct Lean to use a foreign function as the implementation for any definition
using the attribute <code>@[extern &quot;foreign_function&quot;]</code>. It is the user's responsibility to ensure the
foreign implementation is correct.
However, a user mistake here will only impact the code generated by Lean, and
it will <strong>not</strong> compromise the logical soundness of the system.
That is, you cannot prove <code>False</code> using the <code>@[extern]</code> attribute.
We use <code>@[extern]</code> with definitions when we want to provide a reference implementation in Lean
that can be used for reasoning. When we write a definition such as</p>
<pre><code class="language-lean">@[extern &quot;lean_nat_add&quot;]
def add : Nat → Nat → Nat
  | a, Nat.zero   =&gt; a
  | a, Nat.succ b =&gt; Nat.succ (add a b)
</code></pre>
<p>Lean assumes that the foreign function <code>lean_nat_add</code> implements the reference implementation above.</p>
<p>The <code>unsafe</code> keyword allows us to define functions using unsafe features such as general recursion,
and arbitrary type casting. Regular (safe) functions cannot directly use <code>unsafe</code> ones since it would
compromise the logical soundness of the system. As in regular programming languages, programs written
using unsafe features may crash at runtime. Here are a few unsafe examples:</p>
<pre><code class="language-lean">unsafe def unsound : False :=
  unsound

#check @unsafeCast
-- {α : Type _} → {β : Type _} → α → β

unsafe def nat2String (x : Nat) : String :=
  unsafeCast x

-- The following definition doesn't type check because it is not marked as `unsafe`
-- def nat2StringSafe (x : Nat) : String :=
--   unsafeCast x
</code></pre>
<p>The <code>unsafe</code> keyword is particularly useful when we want to take advantage of an implementation detail of the
Lean execution runtime. For example, we cannot prove in Lean that arrays have a maximum size, but
the runtime used to execute Lean programs guarantees that an array cannot have more than 2^64 (2^32) elements
in a 64-bit (32-bit) machine. We can take advantage of this fact to provide a more efficient implementation for
array functions. However, the efficient version would not be very useful if it can only be used in
unsafe code. Thus, Lean 4 provides the attribute <code>@[implemented_by functionName]</code>. The idea is to provide
an unsafe (and potentially more efficient) version of a safe definition or constant. The function <code>f</code>
at the attribute <code>@[implemented_by f]</code> is very similar to an extern/foreign function,
the key difference is that it is implemented in Lean itself. Again, the logical soundness of the system
cannot be compromised by using the attribute <code>implemented_by</code>, but if the implementation is incorrect your
program may crash at runtime. In the following example, we define <code>withPtrUnsafe a k h</code> which
executes <code>k</code> using the memory address where <code>a</code> is stored in memory. The argument <code>h</code> is proof
that <code>k</code> is a constant function. Then, we &quot;seal&quot; this unsafe implementation at <code>withPtr</code>. The proof <code>h</code>
ensures the reference implementation <code>k 0</code> is correct. For more information, see the article
&quot;Sealing Pointer-Based Optimizations Behind Pure Functions&quot;.</p>
<pre><code class="language-lean">unsafe
def withPtrUnsafe {α β : Type} (a : α) (k : USize → β) (h : ∀ u, k u = k 0) : β :=
  k (ptrAddrUnsafe a)

@[implemented_by withPtrUnsafe]
def withPtr {α β : Type} (a : α) (k : USize → β) (h : ∀ u, k u = k 0) : β :=
  k 0
</code></pre>
<p>General recursion is very useful in practice, and it would be impossible to implement Lean 4 without it.
The keyword <code>partial</code> implements a very simple and efficient approach for supporting general recursion.
Simplicity was key here because of the bootstrapping problem. That is, we had to implement Lean in Lean before
many of its features were implemented (e.g., the tactic framework or support for wellfounded recursion).
Another requirement for us was performance. Functions tagged with <code>partial</code> should be as efficient as the ones implemented in mainstream functional programming
languages such as OCaml. When the <code>partial</code> keyword is used, Lean generates an auxiliary <code>unsafe</code> definition that
uses general recursion, and then defines an opaque constant that is implemented by this auxiliary definition.
This is very simple, efficient, and is sufficient for users that want to use Lean as a regular programming language.
A <code>partial</code> definition cannot use unsafe features such as <code>unsafeCast</code> and <code>ptrAddrUnsafe</code>, and it can only be used to
implement types we already known to be inhabited. Finally, since we &quot;seal&quot; the auxiliary definition using an opaque
constant, we cannot reason about <code>partial</code> definitions.</p>
<p>We are aware that proof assistants such as Isabelle provide a framework for defining partial functions that does not
prevent users from proving properties about them. This kind of framework can be implemented in Lean 4. Actually,
it can be implemented by users since Lean 4 is an extensible system. The developers current have no plans to implement
this kind of support for Lean 4. However, we remark that users can implement it using a function that traverses
the auxiliary unsafe definition generated by Lean, and produces a safe one using an approach similar to the one used in Isabelle.</p>
<pre><code class="language-lean"><span class="boring">namespace partial1
</span>partial def f (x : Nat) : IO Unit := do
  IO.println x
  if x &lt; 100 then
     f (x+1)

#eval f 98
<span class="boring">end partial1
</span></code></pre>
<h2 id="library-changes"><a class="header" href="#library-changes">Library changes</a></h2>
<p>These are changes to the library which may trip up Lean 3 users:</p>
<ul>
<li><code>List</code> is no longer a monad.</li>
</ul>
<h2 id="style-changes"><a class="header" href="#style-changes">Style changes</a></h2>
<p>Coding style changes have also been made:</p>
<ul>
<li>Term constants and variables are now <code>lowerCamelCase</code> rather than <code>snake_case</code></li>
<li>Type constants are now <code>UpperCamelCase</code>, eg <code>Nat</code>, <code>List</code>. Type variables are still lower case greek letters. Functors are still lower case latin <code>(m : Type → Type) [Monad m]</code>.</li>
<li>When defining typeclasses, prefer not to use &quot;has&quot;. Eg <code>ToString</code> or <code>Add</code> instead of <code>HasToString</code> or <code>HasAdd</code>.</li>
<li>Prefer <code>return</code> to <code>pure</code> in monad expressions.</li>
<li>Pipes <code>&lt;|</code> are preferred to dollars <code>$</code> for function application.</li>
<li>Declaration bodies should always be indented:
<pre><code class="language-lean">inductive Hello where
  | foo
  | bar

structure Point where
  x : Nat
  y : Nat

def Point.addX : Point → Point → Nat :=
  fun { x := a, .. } { x := b, .. } =&gt; a + b
</code></pre>
</li>
<li>In structures and typeclass definitions, prefer <code>where</code> to <code>:=</code> and don't surround fields with parentheses. (Shown in <code>Point</code> above)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>You can copy highlighted code <a href="https://code.visualstudio.com/updates/v1_10#_copy-with-syntax-highlighting">straight from VS Code</a> to any rich text editor supporting HTML input. For highlighting code in LaTeX, there are two options:</p>
<ul>
<li><a href="https://ctan.org/pkg/listings">listings</a>, which is a common package and simple to set up, but you may run into some restrictions of it and LaTeX around Unicode</li>
<li><a href="https://ctan.org/pkg/minted"><code>minted</code></a>, a LaTeX package wrapping the <a href="https://pygments.org/">Pygments</a> syntax highlighting library. It needs a few more steps to set up, but provides unrestricted support for Unicode when combined with XeLaTeX or LuaLaTex.</li>
</ul>
<h2 id="example-with-listings"><a class="header" href="#example-with-listings">Example with <code>listings</code></a></h2>
<p>Save <a href="https://raw.githubusercontent.com/leanprover/lean4/master/doc/latex/lstlean.tex"><code>lstlean.tex</code></a> into the same directory, or anywhere in your <code>TEXINPUTS</code> path, as the following test file:</p>
<pre><code class="language-latex">\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amssymb}

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\begin{lstlisting}
theorem funext {f₁ f₂ : ∀ (x : α), β x} (h : ∀ x, f₁ x = f₂ x) : f₁ = f₂ := by
  show extfunApp (Quotient.mk f₁) = extfunApp (Quotient.mk f₂)
  apply congrArg
  apply Quotient.sound
  exact h
\end{lstlisting}
\end{document}
</code></pre>
<p>Compile the file via</p>
<pre><code class="language-bash">$ pdflatex test.tex
</code></pre>
<ul>
<li>for older LaTeX versions, you might need to use <code>[utf8x]</code> instead of <code>[utf8]</code> with <code>inputenc</code></li>
</ul>
<h2 id="example-with-minted"><a class="header" href="#example-with-minted">Example with <code>minted</code></a></h2>
<p>First <a href="https://pygments.org/download/">install Pygments</a>. Then save <a href="https://raw.githubusercontent.com/leanprover/lean4/master/doc/latex/lean4.py"><code>lean4.py</code></a>, which contains an version of the Lean highlighter updated for Lean 4, and the following sample LaTeX file <code>test.tex</code> into the same directory:</p>
<pre><code class="language-latex">\documentclass{article}
\usepackage{fontspec}
% switch to a monospace font supporting more Unicode characters
\setmonofont{FreeMono}
\usepackage{minted}
% instruct minted to use our local theorem.py
\newmintinline[lean]{lean4.py:Lean4Lexer -x}{bgcolor=white}
\newminted[leancode]{lean4.py:Lean4Lexer -x}{fontsize=\footnotesize}
\usemintedstyle{tango}  % a nice, colorful theme

\begin{document}
\begin{leancode}
theorem funext {f₁ f₂ : ∀ (x : α), β x} (h : ∀ x, f₁ x = f₂ x) : f₁ = f₂ := by
  show extfunApp (Quotient.mk' f₁) = extfunApp (Quotient.mk' f₂)
  apply congrArg
  apply Quotient.sound
  exact h
\end{leancode}
\end{document}
</code></pre>
<p>If your version of <code>minted</code> is v2.7 or newer, but before v3.0,
you will additionally need to follow the workaround described in https://github.com/gpoore/minted/issues/360.</p>
<p>You can then compile <code>test.tex</code> by executing the following command:</p>
<pre><code class="language-bash">xelatex --shell-escape test.tex
</code></pre>
<p>Some remarks:</p>
<ul>
<li>either <code>xelatex</code> or <code>lualatex</code> is required to handle Unicode characters in the code.</li>
<li><code>--shell-escape</code> is needed to allow <code>xelatex</code> to execute <code>pygmentize</code> in a shell.</li>
<li>If the chosen monospace font is missing some Unicode symbols, you can direct them to be displayed using a fallback font or other replacement LaTeX code.</li>
</ul>
<pre><code class="language-latex">\usepackage{newunicodechar}
\newfontfamily{\freeserif}{DejaVu Sans}
\newunicodechar{✝}{\freeserif{✝}}
\newunicodechar{𝓞}{\ensuremath{\mathcal{O}}}
</code></pre>
<ul>
<li>minted has a &quot;helpful&quot; feature that draws red boxes around characters the chosen lexer doesn't recognize.
Since the Lean lexer cannot encompass all user-defined syntax, it is advisable to <a href="https://tex.stackexchange.com/a/343506/14563">work around</a> this feature.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">import</span> Lean
</span><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Lean Widget</span></span></pre>
<h1 id="the-user-widgets-system"><a class="header" href="#the-user-widgets-system">The user-widgets system</a></h1>
<p>Proving and programming are inherently interactive tasks. Lots of mathematical objects and data
structures are visual in nature. <em>User widgets</em> let you associate custom interactive UIs with
sections of a Lean document. User widgets are rendered in the Lean infoview.</p>
<p><img src="examples/../images/widgets_rubiks.png" alt="Rubik's cube" /></p>
<h2 id="trying-it-out"><a class="header" href="#trying-it-out">Trying it out</a></h2>
<p>To try it out, simply type in the following code and place your cursor over the <code>#widget</code> command.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[widget_module]</span>
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>helloWidget</var><b>: </b><span>Widget.Module</span></span></div></blockquote></div></small></div><span class="nv">helloWidget</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Widget.Module</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Widget.Module</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  javascript := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;
    import * as React from 'react';
    export default function(props) {
      const name = props.name || 'world'
      return React.createElement('p', {}, name + '!')
    }&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;</span>
<span class="s2">    import * as React from &#39;react&#39;;</span>
<span class="s2">    export default function(props) {</span>
<span class="s2">      const name = props.name || &#39;world&#39;</span>
<span class="s2">      return React.createElement(&#39;p&#39;, {}, name + &#39;!&#39;)</span>
<span class="s2">    }&quot;</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="bp">#</span>widget</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>helloWidget</var><b>: </b><span>Widget.Module</span></span></div></blockquote></div></small></div>helloWidget</span><span class="alectryon-token"></span></span></pre>
<p>If you want to dive into a full sample right away, check out
<a href="https://github.com/leanprover/lean4-samples/blob/main/RubiksCube/"><code>RubiksCube</code></a>.
Below, we'll explain the system piece by piece.</p>
<p>⚠️ WARNING: All of the user widget APIs are <strong>unstable</strong> and subject to breaking changes.</p>
<h2 id="widget-sources-and-instances"><a class="header" href="#widget-sources-and-instances">Widget sources and instances</a></h2>
<p>A <em>widget source</em> is a valid JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">ESModule</a>
which exports a <a href="https://reactjs.org/docs/components-and-props.html">React component</a>. To access
React, the module must use <code>import * as React from 'react'</code>. Our first example of a widget source
is of course the value of <code>helloWidget.javascript</code>.</p>
<p>We can register a widget source with the <code>@[widget]</code> attribute, giving it a friendlier name
in the <code>name</code> field. This is bundled together in a <code>UserWidgetDefinition</code>.</p>
<p>A <em>widget instance</em> is then the identifier of a <code>UserWidgetDefinition</code> (so <code>`helloWidget</code>,
not <code>&quot;Hello&quot;</code>) associated with a range of positions in the Lean source code. Widget instances
are stored in the <em>infotree</em> in the same manner as other information about the source file
such as the type of every expression. In our example, the <code>#widget</code> command stores a widget instance
with the entire line as its range. We can think of a widget instance as an instruction for the
infoview: &quot;when the user places their cursor here, please render the following widget&quot;.</p>
<p>Every widget instance also contains a <code>props : Json</code> value. This value is passed as an argument
to the React component. In our first invocation of <code>#widget</code>, we set it to <code>.null</code>. Try out what
happens when you type in:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HelloWidgetProps</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>HelloWidgetProps</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name?</var><b>: </b><span>HelloWidgetProps → Option String</span></span></div></blockquote></div></small></div>name<span class="bp">?</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Server.RpcEncodable</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Server.RpcEncodable</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="bp">#</span>widget</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>helloWidget</var><b>: </b><span>Widget.Module</span></span></div></blockquote></div></small></div>helloWidget</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"> { name<span class="bp">?</span> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&lt;your name here&gt;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&lt;your name here&gt;&quot;</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>HelloWidgetProps</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>HelloWidgetProps</span><span class="alectryon-token"> }</span></span></pre>
<p>💡 NOTE: The RPC system presented below does not depend on JavaScript. However the primary use case
is the web-based infoview in VSCode.</p>
<h2 id="querying-the-lean-server"><a class="header" href="#querying-the-lean-server">Querying the Lean server</a></h2>
<p>Besides enabling us to create cool client-side visualizations, user widgets come with the ability
to communicate with the Lean server. Thanks to this, they have the same metaprogramming capabilities
as custom elaborators or the tactic framework. To see this in action, let's implement a <code>#check</code>
command as a web input form. This example assumes some familiarity with React.</p>
<p>The first thing we'll need is to create an <em>RPC method</em>. Meaning &quot;Remote Procedure Call&quot;, this
is basically a Lean function callable from widget code (possibly remotely over the internet).
Our method will take in the <code>name : Name</code> of a constant in the environment and return its type.
By convention, we represent the input data as a <code>structure</code>. Since it will be sent over from JavaScript,
we need <code>FromJson</code> and <code>ToJson</code>. We'll see below why the position field is needed.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GetTypeParams</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>GetTypeParams</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="sd">/-- Name of a constant to get the type of. -/</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>GetTypeParams → Name</span></span></div></blockquote></div></small></div>name</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Name</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Name</span><span class="alectryon-token">
  <span class="sd">/-- Position of our widget instance in the Lean file. -/</span>
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pos</var><b>: </b><span>GetTypeParams → Lsp.Position</span></span></div></blockquote></div></small></div>pos</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Lsp.Position</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Lsp.Position</span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>FromJson</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>FromJson</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ToJson</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>ToJson</span><span class="alectryon-token"></span></span></pre>
<p>After its arguments, we define the <code>getType</code> method. Every RPC method executes in the <code>RequestM</code>
monad and must return a <code>RequestTask α</code> where <code>α</code> is its &quot;actual&quot; return type. The <code>Task</code> is so
that requests can be handled concurrently. A first guess for <code>α</code> might be <code>Expr</code>. However,
expressions in general can be large objects which depend on an <code>Environment</code> and <code>LocalContext</code>.
Thus we cannot directly serialize an <code>Expr</code> and send it to the widget. Instead, there are two
options:</p>
<ul>
<li>One is to send a <em>reference</em> which points to an object residing on the server. From JavaScript's
point of view, references are entirely opaque, but they can be sent back to other RPC methods for
further processing.</li>
<li>Two is to pretty-print the expression and send its textual representation called <code>CodeWithInfos</code>.
This representation contains extra data which the infoview uses for interactivity. We take this
strategy here.</li>
</ul>
<p>RPC methods execute in the context of a file, but not any particular <code>Environment</code> so they don't
know about the available <code>def</code>initions and <code>theorem</code>s. Thus, we need to pass in a position at which
we want to use the local <code>Environment</code>. This is why we store it in <code>GetTypeParams</code>. The <code>withWaitFindSnapAtPos</code>
method launches a concurrent computation whose job is to find such an <code>Environment</code> and a bit
more information for us, in the form of a <code>snap : Snapshot</code>. With this in hand, we can call
<code>MetaM</code> procedures to find out the type of <code>name</code> and pretty-print it.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">open</span></span><span class="alectryon-token"> Server RequestM </span><span class="alectryon-token"><span class="k">in</span></span><span class="alectryon-token">
<span class="kd">@[server_rpc_method]</span>
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getType</var><b>: </b><span>GetTypeParams → RequestM (RequestTask CodeWithInfos)</span></span></div></blockquote></div></small></div><span class="nv">getType</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>params</var><b>: </b><span>GetTypeParams</span></span></div></blockquote></div></small></div><span class="nv">params</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>GetTypeParams</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>GetTypeParams</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>RequestM</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>RequestM</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>RequestTask</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>RequestTask</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>CodeWithInfos</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>CodeWithInfos</span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>withWaitFindSnapAtPos</var><b>: </b><span>{α : Type} → Lsp.Position → (Snapshots.Snapshot → RequestM α) → RequestM (RequestTask α)</span></span></div></blockquote></div></small></div>withWaitFindSnapAtPos</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>params</var><b>: </b><span>GetTypeParams</span></span></div></blockquote></div></small></div><span class="nv">params</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pos</var><b>: </b><span>GetTypeParams → Lsp.Position</span></span></div></blockquote></div></small></div>pos</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>snap</var><b>: </b><span>Snapshots.Snapshot</span></span></div></blockquote></div></small></div><span class="nv">snap</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runTermElabM</var><b>: </b><span>{α : Type} → Snapshots.Snapshot → RequestT Elab.TermElabM α → RequestM α</span></span></div></blockquote></div></small></div>runTermElabM</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>snap</var><b>: </b><span>Snapshots.Snapshot</span></span></div></blockquote></div></small></div><span class="nv">snap</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">do</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>Name</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>resolveGlobalConstNoOverloadCore</var><b>: </b><span>{m : Type → Type} →
  [inst : Monad m] → [inst : MonadResolveName m] → [inst : MonadEnv m] → [inst : MonadError m] → Name → m Name</span></span></div></blockquote></div></small></div>resolveGlobalConstNoOverloadCore</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>params</var><b>: </b><span>GetTypeParams</span></span></div></blockquote></div></small></div><span class="nv">params</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>GetTypeParams → Name</span></span></div></blockquote></div></small></div>name</span><span class="alectryon-token">
      </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>ConstantInfo</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"> <span class="bp">←</span> </span><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>getConstInfo</var><b>: </b><span>{m : Type → Type} → [inst : Monad m] → [inst : MonadEnv m] → [inst : MonadError m] → Name → m ConstantInfo</span></span></div></blockquote></div></small></div>getConstInfo</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>Name</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token">
        </span><span class="alectryon-token"><span class="k">catch</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>_</var><b>: </b><span>Exception</span></span></div></blockquote></div></small></div>_</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>throwThe</var><b>: </b><span>(ε : Type) → {m : Type → Type} → [inst : MonadExceptOf ε m] → {α : Type} → ε → m α</span></span></div></blockquote></div></small></div>throwThe</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>RequestError</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>RequestError</span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.invalidParams</var><b>: </b><span>JsonRpc.ErrorCode</span></span></div></blockquote></div></small></div><span class="bp">.</span>invalidParams</span><span class="alectryon-token">, </span><span class="alectryon-token">s<span class="bp">!</span></span><span class="alectryon-token"><span class="s2">&quot;no constant named &#39;{</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>name</var><b>: </b><span>Name</span></span></div></blockquote></div></small></div><span class="nv">name</span></span><span class="alectryon-token">}<span class="bp">&#39;</span><span class="s2">&quot;⟩</span>
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Widget.ppExprTagged</var><b>: </b><span>Expr → optParam Bool false → MetaM CodeWithInfos</span></span></div></blockquote></div></small></div>Widget.ppExprTagged</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>c</var><b>: </b><span>ConstantInfo</span></span></div></blockquote></div></small></div><span class="nv">c</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>type</var><b>: </b><span>ConstantInfo → Expr</span></span></div></blockquote></div></small></div>type</span><span class="alectryon-token"></span></span></pre>
<h2 id="using-infoview-components"><a class="header" href="#using-infoview-components">Using infoview components</a></h2>
<p>Now that we have all we need on the server side, let's write the widget source. By importing
<code>@leanprover/infoview</code>, widgets can render UI components used to implement the infoview itself.
For example, the <code>&lt;InteractiveCode&gt;</code> component displays expressions with <code>term : type</code> tooltips
as seen in the goal view. We will use it to implement our custom <code>#check</code> display.</p>
<p>⚠️ WARNING: Like the other widget APIs, the infoview JS API is <strong>unstable</strong> and subject to breaking changes.</p>
<p>The code below demonstrates useful parts of the API. To make RPC method calls, we use the <code>RpcContext</code>.
The <code>useAsync</code> helper packs the results of a call into an <code>AsyncState</code> structure which indicates
whether the call has resolved successfully, has returned an error, or is still in-flight. Based
on this we either display an <code>InteractiveCode</code> with the type, <code>mapRpcError</code> the error in order
to turn it into a readable message, or show a <code>Loading..</code> message, respectively.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[widget_module]</span>
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>checkWidget</var><b>: </b><span>Widget.Module</span></span></div></blockquote></div></small></div><span class="nv">checkWidget</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Widget.Module</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Widget.Module</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  javascript := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;
import * as React from 'react';
const e = React.createElement;
import { RpcContext, InteractiveCode, useAsync, mapRpcError } from '@leanprover/infoview';

export default function(props) {
  const rs = React.useContext(RpcContext)
  const [name, setName] = React.useState('getType')

  const st = useAsync(() =&gt;
    rs.call('getType', { name, pos: props.pos }), [name, rs, props.pos])

  const type = st.state === 'resolved' ? st.value &amp;&amp; e(InteractiveCode, {fmt: st.value})
    : st.state === 'rejected' ? e('p', null, mapRpcError(st.error).message)
    : e('p', null, 'Loading..')
  const onChange = (event) =&gt; { setName(event.target.value) }
  return e('div', null,
    e('input', { value: name, onChange }), ' : ', type)
}
&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;</span>
<span class="s2">import * as React from &#39;react&#39;;</span>
<span class="s2">const e = React.createElement;</span>
<span class="s2">import { RpcContext, InteractiveCode, useAsync, mapRpcError } from &#39;@leanprover/infoview&#39;;</span>

<span class="s2">export default function(props) {</span>
<span class="s2">  const rs = React.useContext(RpcContext)</span>
<span class="s2">  const [name, setName] = React.useState(&#39;getType&#39;)</span>

<span class="s2">  const st = useAsync(() =&gt;</span>
<span class="s2">    rs.call(&#39;getType&#39;, { name, pos: props.pos }), [name, rs, props.pos])</span>

<span class="s2">  const type = st.state === &#39;resolved&#39; ? st.value &amp;&amp; e(InteractiveCode, {fmt: st.value})</span>
<span class="s2">    : st.state === &#39;rejected&#39; ? e(&#39;p&#39;, null, mapRpcError(st.error).message)</span>
<span class="s2">    : e(&#39;p&#39;, null, &#39;Loading..&#39;)</span>
<span class="s2">  const onChange = (event) =&gt; { setName(event.target.value) }</span>
<span class="s2">  return e(&#39;div&#39;, null,</span>
<span class="s2">    e(&#39;input&#39;, { value: name, onChange }), &#39; : &#39;, type)</span>
<span class="s2">}</span>
<span class="s2">&quot;</span></span><span class="alectryon-token"></span></span></pre>
<p>Finally we can try out the widget.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">#</span>widget</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>checkWidget</var><b>: </b><span>Widget.Module</span></span></div></blockquote></div></small></div>checkWidget</span><span class="alectryon-token"></span></span></pre>
<p><img src="examples/../images/widgets_caas.png" alt="#check as a service" /></p>
<h2 id="building-widget-sources"><a class="header" href="#building-widget-sources">Building widget sources</a></h2>
<p>While typing JavaScript inline is fine for a simple example, for real developments we want to use
packages from NPM, a proper build system, and JSX. Thus, most actual widget sources are built with
Lake and NPM. They consist of multiple files and may import libraries which don't work as ESModules
by default. On the other hand a widget source must be a single, self-contained ESModule in the form
of a string. Readers familiar with web development may already have guessed that to obtain such a
string, we need a <em>bundler</em>. Two popular choices are <a href="https://rollupjs.org/guide/en/"><code>rollup.js</code></a>
and <a href="https://esbuild.github.io/"><code>esbuild</code></a>. If we go with <code>rollup.js</code>, to make a widget work with
the infoview we need to:</p>
<ul>
<li>Set <a href="https://rollupjs.org/guide/en/#outputformat"><code>output.format</code></a> to <code>'es'</code>.</li>
<li><a href="https://rollupjs.org/guide/en/#external">Externalize</a> <code>react</code>, <code>react-dom</code>, <code>@leanprover/infoview</code>.
These libraries are already loaded by the infoview so they should not be bundled.</li>
</ul>
<p>In the RubiksCube sample, we provide a working <code>rollup.js</code> build configuration in
<a href="https://github.com/leanprover/lean4-samples/blob/main/RubiksCube/widget/rollup.config.js">rollup.config.js</a>.</p>
<h2 id="inserting-text"><a class="header" href="#inserting-text">Inserting text</a></h2>
<p>We can also instruct the editor to insert text, copy text to the clipboard, or
reveal a certain location in the document.
To do this, use the <code>React.useContext(EditorContext)</code> React context.
This will return an <code>EditorConnection</code> whose <code>api</code> field contains a number of methods to
interact with the text editor.</p>
<p>You can see the full API for this <a href="https://github.com/leanprover/vscode-lean4/blob/master/lean4-infoview-api/src/infoviewApi.ts#L52">here</a></p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[widget_module]</span>
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insertTextWidget</var><b>: </b><span>Widget.Module</span></span></div></blockquote></div></small></div><span class="nv">insertTextWidget</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Widget.Module</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Widget.Module</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  javascript := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;
import * as React from 'react';
const e = React.createElement;
import { EditorContext } from '@leanprover/infoview';

export default function(props) {
  const editorConnection = React.useContext(EditorContext)
  function onClick() {
    editorConnection.api.insertText('-- hello!!!', 'above')
  }

  return e('div', null, e('button', { value: name, onClick }, 'insert'))
}
&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;</span>
<span class="s2">import * as React from &#39;react&#39;;</span>
<span class="s2">const e = React.createElement;</span>
<span class="s2">import { EditorContext } from &#39;@leanprover/infoview&#39;;</span>

<span class="s2">export default function(props) {</span>
<span class="s2">  const editorConnection = React.useContext(EditorContext)</span>
<span class="s2">  function onClick() {</span>
<span class="s2">    editorConnection.api.insertText(&#39;-- hello!!!&#39;, &#39;above&#39;)</span>
<span class="s2">  }</span>

<span class="s2">  return e(&#39;div&#39;, null, e(&#39;button&#39;, { value: name, onClick }, &#39;insert&#39;))</span>
<span class="s2">}</span>
<span class="s2">&quot;</span></span><span class="alectryon-token"></span></span></pre>
<p>Finally, we can try this out:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">#</span>widget</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insertTextWidget</var><b>: </b><span>Widget.Module</span></span></div></blockquote></div></small></div>insertTextWidget</span><span class="alectryon-token"></span></span></pre><div style="break-before: page; page-break-before: always;"></div><h2 id="semantic-highlighting"><a class="header" href="#semantic-highlighting">Semantic Highlighting</a></h2>
<p>The Lean language server provides semantic highlighting information to editors. In order to benefit from this in VSCode, you may need to activate the &quot;Editor &gt; Semantic Highlighting&quot; option in the preferences (this is translates to <code>&quot;editor.semanticHighlighting.enabled&quot;: true,</code>
in <code>settings.json</code>). The default option here is to let your color theme decides whether it activates semantic highlighting (the default themes Dark+ and Light+ do activate it for instance).</p>
<p>However this may be insufficient if your color theme does not distinguish enough syntax categories or distinguishes them very subtly. For instance the default Light+ theme uses color <code>#001080</code> for variables. This is awfully close to <code>#000000</code> that is used as the default text color. This makes it very easy to miss an accidental use of <a href="https://lean-lang.org/lean4/doc/autobound.html">auto bound implicit arguments</a>. For instance in</p>
<pre><code class="language-lean">def my_id (n : nat) := n
</code></pre>
<p>maybe <code>nat</code> is a typo and <code>Nat</code> was intended. If your color theme is good enough then you should see that <code>n</code> and <code>nat</code> have the same color since they are both marked as variables by semantic highlighting. If you rather write <code>(n : Nat)</code> then <code>n</code> keeps its variable color but <code>Nat</code> gets the default text color.</p>
<p>If you use such a bad theme, you can fix things by modifying the <code>Semantic Token Color Customizations</code> configuration. This cannot be done directly in the preferences dialog but you can click on &quot;Edit in settings.json&quot; to directly edit the settings file. Beware that you must save this file (in the same way you save any file opened in VSCode) before seeing any effect in other tabs or VSCode windows.</p>
<p>In the main config object, you can add something like</p>
<pre><code>&quot;editor.semanticTokenColorCustomizations&quot;: {
        &quot;[Default Light+]&quot;: {&quot;rules&quot;: {&quot;function&quot;: &quot;#ff0000&quot;, &quot;property&quot;: &quot;#00ff00&quot;, &quot;variable&quot;: &quot;#ff00ff&quot;}}
    },
</code></pre>
<p>The colors in this example are not meant to be nice but to be easy to spot in your file when testing. Of course you need to replace <code>Default Light+</code> with the name of your theme, and you can customize several themes if you use several themes. VSCode will display small colored boxes next to the HTML color specifications. Hovering on top of a color specification opens a convenient color picker dialog.</p>
<p>In order to understand what <code>function</code>, <code>property</code> and <code>variable</code> mean in the above example, the easiest path is to open a Lean file and ask VSCode about its classification of various bits of your file. Open the command palette with Ctrl-shift-p (or ⌘-shift-p on a Mac) and search for &quot;Inspect Editor Tokens and Scopes&quot; (typing the word &quot;tokens&quot; should be enough to see it). You can then click on any word in your file and look if there is a &quot;semantic token type&quot; line in the displayed information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h1>
<p>If you want to make changes to Lean itself, start by <a href="dev/../make/index.html">building Lean</a> from a clean checkout to make sure that everything is set up correctly.
After that, read on below to find out how to set up your editor for changing the Lean source code, followed by further sections of the development manual where applicable such as on the <a href="dev/testing.html">test suite</a> and <a href="dev/commit_convention.html">commit convention</a>.</p>
<p>If you are planning to make any changes that may affect the compilation of Lean itself, e.g. changes to the parser, elaborator, or compiler, you should first read about the <a href="dev/bootstrap.html">bootstrapping pipeline</a>.
You should not edit the <code>stage0</code> directory except using the commands described in that section when necessary.</p>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<p>You can use any of the <a href="dev/../setup.html">supported editors</a> for editing the Lean source code.
If you set up <code>elan</code> as below, opening <code>src/</code> as a <em>workspace folder</em> should ensure that stage 0 (i.e. the stage that first compiles <code>src/</code>) will be used for files in that directory.</p>
<h3 id="dev-setup-using-elan"><a class="header" href="#dev-setup-using-elan">Dev setup using elan</a></h3>
<p>You can use <a href="https://github.com/leanprover/elan"><code>elan</code></a> to easily
switch between stages and build configurations based on the current
directory, both for the <code>lean</code>, <code>leanc</code>, and <code>leanmake</code> binaries in your shell's
PATH and inside your editor.</p>
<p>To install elan, you can do so, without installing a default version of Lean, using (Unix)</p>
<pre><code class="language-bash">curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf | sh -s -- --default-toolchain none
</code></pre>
<p>or (Windows)</p>
<pre><code>curl -O --location https://raw.githubusercontent.com/leanprover/elan/master/elan-init.ps1
powershell -f elan-init.ps1 --default-toolchain none
del elan-init.ps1
</code></pre>
<p>The <code>lean-toolchain</code> files in the Lean 4 repository are set up to use the <code>lean4-stage0</code>
toolchain for editing files in <code>src</code> and the <code>lean4</code> toolchain for editing files in <code>tests</code>.</p>
<p>Run the following commands to make <code>lean4</code> point at <code>stage1</code> and <code>lean4-stage0</code> point at <code>stage0</code>:</p>
<pre><code class="language-bash"># in the Lean rootdir
elan toolchain link lean4 build/release/stage1
elan toolchain link lean4-stage0 build/release/stage0
</code></pre>
<p>You can also use the <code>+toolchain</code> shorthand (e.g. <code>lean +lean4-debug</code>) to switch
toolchains on the spot. <code>lean4-mode</code> will automatically use the <code>lean</code> executable
associated with the directory of the current file as long as <code>lean4-rootdir</code> is
unset and <code>~/.elan/bin</code> is in your <code>exec-path</code>. Where Emacs sources the
<code>exec-path</code> from can be a bit unclear depending on your configuration, so
alternatively you can also set <code>lean4-rootdir</code> to <code>&quot;~/.elan&quot;</code> explicitly.</p>
<p>You might find that debugging through elan, e.g. via <code>gdb lean</code>, disables some
things like symbol autocompletion because at first only the elan proxy binary
is loaded. You can instead pass the explicit path to <code>bin/lean</code> in your build
folder to gdb, or use <code>gdb $(elan which lean)</code>.</p>
<p>It is also possible to generate releases that others can use,
simply by pushing a tag to your fork of the Lean 4 github repository
(and waiting about an hour; check the <code>Actions</code> tab for completion).
If you push <code>my-tag</code> to a fork in your github account <code>my_name</code>,
you can then put <code>my_name/lean4:my-tag</code> in your <code>lean-toolchain</code> file in a project using <code>lake</code>.
(You must use a tag name that does not start with a numeral, or contain <code>_</code>).</p>
<h3 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h3>
<p>There is a <code>lean.code-workspace</code> file that correctly sets up VS Code with workspace roots for the stage0/stage1 setup described above as well as with other settings.
You should always load it when working on Lean, such as by invoking</p>
<pre><code>code lean.code-workspace
</code></pre>
<p>on the command line.</p>
<h3 id="ccache"><a class="header" href="#ccache"><code>ccache</code></a></h3>
<p>Lean's build process uses <a href="https://ccache.dev/"><code>ccache</code></a> if it is
installed to speed up recompilation of the generated C code. Without
<code>ccache</code>, you'll likely spend more time than necessary waiting on
rebuilds - it's a good idea to make sure it's installed.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>C++14 compatible compiler</li>
<li><a href="http://www.cmake.org">CMake</a></li>
<li><a href="http://gmplib.org/">GMP (GNU multiprecision library)</a></li>
</ul>
<h2 id="platform-specific-setup"><a class="header" href="#platform-specific-setup">Platform-Specific Setup</a></h2>
<ul>
<li><a href="make/ubuntu.html">Linux (Ubuntu)</a></li>
<li><a href="make/msys2.html">Windows (msys2)</a></li>
<li><a href="make/msvc.html">Windows (Visual Studio)</a></li>
<li><a href="make/wsl.html">Windows (WSL)</a></li>
<li><a href="make/osx-10.9.html">macOS (homebrew)</a></li>
<li>Linux/macOS/WSL via <a href="https://nixos.org/nix/">Nix</a>: Call <code>nix-shell</code> in the project root. That's it.</li>
</ul>
<h2 id="generic-build-instructions"><a class="header" href="#generic-build-instructions">Generic Build Instructions</a></h2>
<p>Setting up a basic release build:</p>
<pre><code class="language-bash">git clone https://github.com/leanprover/lean4 --recurse-submodules
cd lean4
mkdir -p build/release
cd build/release
cmake ../..
make
</code></pre>
<p>For regular development, we recommend running</p>
<pre><code class="language-bash">git config submodule.recurse true
</code></pre>
<p>in the checkout so that <code>--recurse-submodules</code> doesn't have to be
specified with <code>git pull/checkout/...</code>.</p>
<p>The above commands will compile the Lean library and binaries into the
<code>stage1</code> subfolder; see below for details. Add <code>-j N</code> for an
appropriate <code>N</code> to <code>make</code> for a parallel build.</p>
<p>For example, on an AMD Ryzen 9 <code>make</code> takes 00:04:55, whereas <code>make -j 10</code>
takes 00:01:38.  Your results may vary depending on the speed of your hard
drive.</p>
<p>You should not usually run <code>make install</code> after a successful build.
See <a href="make/../dev/index.html#dev-setup-using-elan">Dev setup using elan</a> on how to properly set up your editor to use the correct stage depending on the source directory.</p>
<h2 id="useful-cmake-configuration-settings"><a class="header" href="#useful-cmake-configuration-settings">Useful CMake Configuration Settings</a></h2>
<p>Pass these along with the <code>cmake ../..</code> command.</p>
<ul>
<li>
<p><code>-D CMAKE_BUILD_TYPE=</code><br />
Select the build type. Valid values are <code>RELEASE</code> (default), <code>DEBUG</code>,
<code>RELWITHDEBINFO</code>, and <code>MINSIZEREL</code>.</p>
</li>
<li>
<p><code>-D CMAKE_C_COMPILER=</code><br />
<code>-D CMAKE_CXX_COMPILER=</code><br />
Select the C/C++ compilers to use. Official Lean releases currently use Clang;
see also <code>.github/workflows/ci.yml</code> for the CI config.</p>
</li>
</ul>
<p>Lean will automatically use <a href="https://ccache.dev/">CCache</a> if available to avoid
redundant builds, especially after stage 0 has been updated.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<ul>
<li>Call <code>make</code> with an additional <code>VERBOSE=1</code> argument to print executed commands.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-lean-on-ubuntu"><a class="header" href="#installing-lean-on-ubuntu">Installing Lean on Ubuntu</a></h1>
<h2 id="build-dependencies"><a class="header" href="#build-dependencies">Build Dependencies</a></h2>
<p>Please ensure you have the following build tools available and then
follow the <a href="make/index.html">generic build instructions</a>.</p>
<h2 id="basic-packages"><a class="header" href="#basic-packages">Basic packages</a></h2>
<pre><code class="language-bash">sudo apt-get install git libgmp-dev cmake ccache clang
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-packages-on-os-x-109"><a class="header" href="#install-packages-on-os-x-109">Install Packages on OS X 10.9</a></h1>
<p>We assume that you are using <a href="http://brew.sh">homebrew</a> as a package manager.</p>
<h2 id="compilers"><a class="header" href="#compilers">Compilers</a></h2>
<p>You need a C++11-compatible compiler to build Lean. As of November
2014, you have three options:</p>
<ul>
<li>clang++-3.5 (shipped with OSX, Apple LLVM version 6.0)</li>
<li>gcc-4.9.1 (homebrew)</li>
<li>clang++-3.5 (homebrew)</li>
</ul>
<p>We recommend to use Apple's clang++ because it is pre-shipped with OS
X and requires no further installation.</p>
<p>To install gcc-4.9.1 via homebrew, please execute:</p>
<pre><code class="language-bash">brew install gcc
</code></pre>
<p>To install clang++-3.5 via homebrew, please execute:</p>
<pre><code class="language-bash">brew install llvm --with-clang --with-asan
</code></pre>
<p>To use compilers other than the default one (Apple's clang++), you
need to use <code>-DCMAKE_CXX_COMPILER</code> option to specify the compiler
that you want to use when you run <code>cmake</code>. For example, do the
following to use <code>g++</code>.</p>
<pre><code class="language-bash">cmake -DCMAKE_CXX_COMPILER=g++ ...
</code></pre>
<h2 id="required-packages-cmake-gmp"><a class="header" href="#required-packages-cmake-gmp">Required Packages: CMake, GMP</a></h2>
<pre><code class="language-bash">brew install cmake
brew install gmp
</code></pre>
<h2 id="recommended-packages-ccache"><a class="header" href="#recommended-packages-ccache">Recommended Packages: CCache</a></h2>
<pre><code class="language-bash">brew install ccache
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lean-for-windows"><a class="header" href="#lean-for-windows">Lean for Windows</a></h1>
<p>A native Lean binary for Windows can be generated using <a href="http://msys2.github.io">MSYS2</a>.
It is easy to install all dependencies, it produces native
64/32-binaries, and supports a C++14 compiler.</p>
<p>An alternative to MSYS2 is to use <a href="make/wsl.html">Lean in Windows WSL</a>.</p>
<p>While not necessary for pure building, you should first activate <a href="https://docs.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development">Developer
Mode</a>
(Settings &gt; Update &amp; Security &gt; For developers &gt; Developer Mode),
which will allow Lean to create symlinks that e.g. enable go-to-definition in
the stdlib.</p>
<h2 id="installing-dependencies"><a class="header" href="#installing-dependencies">Installing dependencies</a></h2>
<p><a href="http://msys2.github.io">The official webpage of MSYS2</a> provides one-click installers.
Once installed, you should run the &quot;MSYS2 MinGW 64-bit shell&quot; from the start menu (the one that runs <code>mingw64.exe</code>).
Do not run &quot;MSYS2 MSYS&quot; instead!
MSYS2 has a package management system, <a href="https://wiki.archlinux.org/index.php/pacman">pacman</a>, which is used in Arch Linux.</p>
<p>Here are the commands to install all dependencies needed to compile Lean on your machine.</p>
<pre><code class="language-bash">pacman -S make python mingw-w64-x86_64-cmake mingw-w64-x86_64-clang mingw-w64-x86_64-ccache git unzip diffutils binutils
</code></pre>
<p>You should now be able to run these commands:</p>
<pre><code class="language-bash">clang --version
cmake --version
</code></pre>
<p>Then follow the <a href="make/index.html">generic build instructions</a> in the MSYS2
MinGW shell, using:</p>
<pre><code>cmake ../.. -G &quot;Unix Makefiles&quot;  -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++
</code></pre>
<p>instead of <code>cmake ../..</code>. This ensures that cmake will call <code>sh</code> instead of <code>cmd.exe</code>
for script tasks and it will use the clang compiler instead of gcc, which is required.</p>
<h2 id="install-lean"><a class="header" href="#install-lean">Install lean</a></h2>
<p>Follow the steps in <a href="make/../dev/index.html#dev-setup-using-elan">Dev setup using
elan</a> regarding installation of the
bits you just built.  Note that in an msys2 environment <code>elan-init.sh</code>
reports you need to add <code>%USERPROFILE%\.elan\bin</code> to your path, but of
course in msys2 that needs to be a valid linux style path, like this:</p>
<pre><code class="language-bash">export PATH=&quot;$PATH:/c/users/$USERNAME/.elan/bin&quot;
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<p>You can run <code>lean --version</code> to see if your binaries work.</p>
<p>If you want a version that can run independently of your MSYS install
then you need to copy the following dependent DLL's from where ever
they are installed in your MSYS setup:</p>
<ul>
<li>libgcc_s_seh-1.dll</li>
<li>libstdc++-6.dll</li>
<li>libgmp-10.dll</li>
<li>libwinpthread-1.dll</li>
</ul>
<p>The following linux command will do that:</p>
<pre><code class="language-bash">cp $(ldd lean.exe | cut -f3 -d' ' | grep mingw) .
</code></pre>
<p>However, if you plan to use this build to compile lean programs
to executable binaries using <code>lake build</code> in normal Windows command
prompt outside of msys2 environment you will also need to add a windows
version clang to your path.</p>
<h2 id="trouble-shooting"><a class="header" href="#trouble-shooting">Trouble shooting</a></h2>
<p><strong>-bash: gcc: command not found</strong></p>
<p>Make sure <code>/mingw64/bin</code> is in your PATH environment.  If it is not then
check you launched the MSYS2 MinGW 64-bit shell from the start menu.
(The one that runs <code>mingw64.exe</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lean-in-windows-wsl"><a class="header" href="#lean-in-windows-wsl">Lean in Windows WSL</a></h1>
<p>As an alternative to the <a href="make/msys2.html">MSYS2</a> setup you can also use the
<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Windows Subsystem for Linux</a> to build Lean there, but edit and
debug using <a href="https://code.visualstudio.com/Download">Visual Studio Code</a> in Windows.</p>
<p>For the most part setup in WSL is the same as
<a href="make/ubuntu.html">Ubuntu</a>. This document provides additional
information on how to setup Windows Visual Studio Code remote
debugging into your WSL environment using the lean extension running
in WSL.</p>
<p>It is recommended that you setup Ubuntu in <a href="https://docs.microsoft.com/en-us/windows/wsl/compare-versions">WSL
2</a>.
Then follow the <a href="make/../dev/index.html#dev-setup-using-elan">Dev setup using elan</a>.</p>
<h2 id="visual-studio-code-setup-on-windows"><a class="header" href="#visual-studio-code-setup-on-windows">Visual Studio Code setup on Windows</a></h2>
<p>Install <a href="https://code.visualstudio.com/Download">Visual Studio Code</a> on Windows.  Install the VS Code
<code>Remote Development</code> extension from Microsoft.  This extension
includes the <code>Remote - WSL</code> extension. Install the lean4 extension but
into the WSL using: <code>Install in WSL: Ubuntu</code></p>
<p>Type <code>Ctrl+Shift+P</code> and select <code>Remote-WSL: Open Folder in WSL...</code> to
open a folder containing your hello world lean package.</p>
<p>When everything is working you should see something like this with a
functioning infoview, syntax coloring and tooltips:</p>
<p><img src="make/../images/code-wsl.png" alt="screenshot" /></p>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<p><strong>lean4: Could not find Lean version by running 'lean --version'.</strong></p>
<p>Check that the <code>lean</code> program is available in your PATH in your WSL
environment.</p>
<p><strong>Logs are showing up with a windows file path</strong></p>
<p>Check that you have not set a windows path in your
<code>lean4.serverLogging.path</code> Visual Studio Code setting. it is best if
this setting is set as follows:</p>
<pre><code class="language-json">  &quot;lean4.serverLogging.path&quot;: &quot;logs&quot;
</code></pre>
<p>This will result in a logs folder being created inside your lean
package folder in the WSL file system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lean-build-bootstrapping"><a class="header" href="#lean-build-bootstrapping">Lean Build Bootstrapping</a></h1>
<p>Since version 4, Lean is a partially bootstrapped program: most parts of the
frontend and compiler are written in Lean itself and thus need to be built before
building Lean itself - which is needed to again build those parts. This cycle is
broken by using pre-built C files checked into the repository (which ultimately
go back to a point where the Lean compiler was not written in Lean) in place of
these Lean inputs and then compiling everything in multiple stages up to a fixed
point. The build directory is organized in these stages:</p>
<pre><code class="language-bash">stage0/
  # Bootstrap binary built from stage0/src/.
  # We do not use any other files from this directory in further stages.
  bin/lean
stage1/
  include/
    config.h  # config variables used to build `lean` such as used allocator
    runtime/lean.h  # runtime header, used by extracted C code, uses `config.h`
  share/lean/
    lean.mk  # used by `leanmake`
  lib/
    lean/**/*.olean  # the Lean library (incl. the compiler) compiled by the previous stage's `lean`
    temp/**/*.{c,o}  # the library extracted to C and compiled by `leanc`
    libInit.a libLean.a  # static libraries of the Lean library
    libleancpp.a  # a static library of the C++ sources of Lean
    libleanshared.so  # a dynamic library including the static libraries above
  bin/
    lean  # the Lean compiler &amp; server, a small executable that calls directly into libleanshared.so
    leanc  # a wrapper around a C compiler supplying search paths etc
    leanmake  # a wrapper around `make` supplying the Makefile above
stage2/...
stage3/...
</code></pre>
<p>Stage 0 can be viewed as a blackbox since it does not depend on any local
changes and is equivalent to downloading a bootstrapping binary as done in other
compilers. The build for any other stage starts by building the runtime and
standard library from <code>src/</code>, using the <code>lean</code> binary from the previous stage in
the latter case, which are then assembled into a new <code>bin/lean</code> binary.</p>
<p>Each stage can be built by calling <code>make stageN</code> in the root build folder.
Running just <code>make</code> will default to stage 1, which is usually sufficient for
testing changes on the test suite or other files outside of the stdlib. However,
it might happen that the stage 1 compiler is not able to load its own stdlib,
e.g. when changing the .olean format: the stage 1 stdlib will use the format
generated by the stage 0 compiler, but the stage 1 compiler will expect the new
format. In this case, we should continue with building and testing stage 2
instead, which will both build and expect the new format. Note that this is only
possible because when building a stage's stdlib, we use the previous compiler
but never load the previous stdlib (since everything is <code>prelude</code>). We can also
use stage 2 to test changes in the compiler or other &quot;meta&quot; parts, i.e. changes
that affect the produced (.olean or .c) code, on the stdlib and compiler itself.
We are not aware of any &quot;meta-meta&quot; parts that influence more than two stages of
compilation, so stage 3 should always be identical to stage 2 and only exists as
a sanity check.</p>
<p>In summary, doing a standard build via <code>make</code> internally involves these steps:</p>
<ol>
<li>compile the <code>stage0/src</code> archived sources into <code>stage0/bin/lean</code></li>
<li>use it to compile the current library (<em>including</em> your changes) into <code>stage1/lib</code></li>
<li>link that and the current C++ code from <code>src/</code> into <code>stage1/bin/lean</code></li>
</ol>
<p>You now have a Lean binary and library that include your changes, though their
own compilation was not influenced by them, that you can use to test your
changes on test programs whose compilation <em>will</em> be influenced by the changes.</p>
<h2 id="updating-stage0"><a class="header" href="#updating-stage0">Updating stage0</a></h2>
<p>Finally, when we want to use new language features in the library, we need to
update the archived C source code of the stage 0 compiler in <code>stage0/src</code>.</p>
<p>The github repository will automatically update stage0 on <code>master</code> once
<code>src/stdlib_flags.h</code> and <code>stage0/src/stdlib_flags.h</code> are out of sync.</p>
<p>If you have write access to the lean4 repository, you can also also manually
trigger that process, for example to be able to use new features in the compiler itself.
You can do that on <a href="https://github.com/nomeata/lean4/actions/workflows/update-stage0.yml">https://github.com/nomeata/lean4/actions/workflows/update-stage0.yml</a>
or using Github CLI with</p>
<pre><code>gh workflow run update-stage0.yml
</code></pre>
<p>Leaving stage0 updates to the CI automation is preferrable, but should you need
to do it locally, you can use <code>make update-stage0</code> in <code>build/release</code>, to
update <code>stage0</code> from <code>stage1</code>, <code>make -C stageN update-stage0</code> to update from
another stage, or <code>nix run .#update-stage0-commit</code> to update using nix.</p>
<p>Updates to <code>stage0</code> should be their own commits in the Git history. So should
you have to include the stage0 update in your PR (rather than using above
automation after merging changes), commit your work before running <code>make update-stage0</code>, commit the updated <code>stage0</code> compiler code with the commit
message:</p>
<pre><code>chore: update stage0
</code></pre>
<p>and coordinate with the admins to not squash your PR.</p>
<h2 id="further-bootstrapping-complications"><a class="header" href="#further-bootstrapping-complications">Further Bootstrapping Complications</a></h2>
<p>As written above, changes in meta code in the current stage usually will only
affect later stages. This is an issue in two specific cases.</p>
<ul>
<li>
<p>For <em>non-builtin</em> meta code such as <code>notation</code>s or <code>macro</code>s in
<code>Notation.lean</code>, we expect changes to affect the current file and all later
files of the same stage immediately, just like outside the stdlib. To ensure
this, we need to build the stage using <code>-Dinterpreter.prefer_native=false</code> -
otherwise, when executing a macro, the interpreter would notice that there is
already a native symbol available for this function and run it instead of the
new IR, but the symbol is from the previous stage!</p>
<p>To make matters more complicated, while <code>false</code> is a reasonable default
incurring only minor overhead (<code>ParserDescr</code>s and simple macros are cheap to
interpret), there are situations where we <em>need</em> to set the option to <code>true</code>:
when the interpreter is executed from the native code of the previous stage,
the type of the value it computes must be identical to/ABI-compatible with the
type in the previous stage. For example, if we add a new parameter to <code>Macro</code>
or reorder constructors in <code>ParserDescr</code>, building the stage with the
interpreter will likely fail. Thus we need to set <code>interpreter.prefer_native</code>
to <code>true</code> in such cases to &quot;freeze&quot; meta code at their versions in the
previous stage; no new meta code should be introduced in this stage. Any
further stages (e.g. after an <code>update-stage0</code>) will then need to be compiled
with the flag set to <code>false</code> again since they will expect the new signature.</p>
<p>For an example, see https://github.com/leanprover/lean4/commit/da4c46370d85add64ef7ca5e7cc4638b62823fbb.</p>
</li>
<li>
<p>For the special case of <em>quotations</em>, it is desirable to have changes in
built-in parsers affect them immediately: when the changes in the parser
become active in the next stage, macros implemented via quotations should
generate syntax trees compatible with the new parser, and quotation patterns
in macro and elaborators should be able to match syntax created by the new
parser and macros. Since quotations capture the syntax tree structure during
execution of the current stage and turn it into code for the next stage, we
need to run the current stage's built-in parsers in quotation via the
interpreter for this to work. Caveats:</p>
<ul>
<li>Since interpreting full parsers is not nearly as cheap and we rarely change
built-in syntax, this needs to be opted in using <code>-Dinternal.parseQuotWithCurrentStage=true</code>.</li>
<li>The parser needs to be reachable via an <code>import</code> statement, otherwise the
version of the previous stage will silently be used.</li>
<li>Only the parser code (<code>Parser.fn</code>) is affected; all metadata such as leading
tokens is taken from the previous stage.</li>
</ul>
<p>For an example, see https://github.com/leanprover/lean4/commit/f9dcbbddc48ccab22c7674ba20c5f409823b4cc1#diff-371387aed38bb02bf7761084fd9460e4168ae16d1ffe5de041b47d3ad2d22422
(from before the flag defaulted to <code>false</code>).</p>
</li>
</ul>
<p>To modify either of these flags both for building and editing the stdlib, adjust
the code in <code>stage0/src/stdlib_flags.h</code>. The flags will automatically be reset
on the next <code>update-stage0</code> when the file is overwritten with the original
version in <code>src/</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-suite"><a class="header" href="#test-suite">Test Suite</a></h1>
<p>After <a href="dev/../make/index.html">building Lean</a> you can run all the tests using</p>
<pre><code>cd build/release
make test ARGS=-j4
</code></pre>
<p>Change the 4 to the maximum number of parallel tests you want to
allow. The best choice is the number of CPU cores on your machine as
the tests are mostly CPU bound.  You can find the number of processors
on linux using <code>nproc</code> and on Windows it is the <code>NUMBER_OF_PROCESSORS</code>
environment variable.</p>
<p>You can run tests after <a href="dev/bootstrap.html">building a specific stage</a> by
adding the <code>-C stageN</code> argument. The default when run as above is stage 1.  The
Lean tests will automatically use that stage's corresponding Lean
executables</p>
<p>Running <code>make test</code> will not pick up new test files; run</p>
<pre><code class="language-bash">cmake build/release/stage1
</code></pre>
<p>to update the list of tests.</p>
<p>You can also use <code>ctest</code> directly if you are in the right folder.  So
to run stage1 tests with a 300 second timeout run this:</p>
<pre><code class="language-bash">cd build/release/stage1
ctest -j 4 --output-on-failure --timeout 300
</code></pre>
<p>Useful <code>ctest</code> flags are <code>-R &lt;name of test&gt;</code> to run a single test, and
<code>--rerun-failed</code> to run all tests that failed during the last run.
You can also pass <code>ctest</code> flags via <code>make test ARGS=&quot;--rerun-failed&quot;</code>.</p>
<p>To get verbose output from ctest pass the <code>--verbose</code> command line
option. Test output is normally suppressed and only summary
information is displayed. This option will show all test output.</p>
<h2 id="test-suite-organization"><a class="header" href="#test-suite-organization">Test Suite Organization</a></h2>
<p>All these tests are included by <a href="https://github.com/leanprover/lean4/blob/master/src/shell/CMakeLists.txt">src/shell/CMakeLists.txt</a>:</p>
<ul>
<li>
<p><code>tests/lean</code>: contains tests that come equipped with a
.lean.expected.out file. The driver script <code>test_single.sh</code> runs
each test and checks the actual output (*.produced.out) with the
checked in expected output.</p>
</li>
<li>
<p><code>tests/lean/run</code>: contains tests that are run through the lean
command line one file at a time. These tests only look for error
codes and do not check the expected output even though output is
produced, it is ignored.</p>
</li>
<li>
<p><code>tests/lean/interactive</code>: are designed to test server requests at a
given position in the input file. Each .lean file contains comments
that indicate how to simulate a client request at that position.
using a <code>--^</code> point to the line position. Example:</p>
<pre><code class="language-lean ignore">open Foo in
theorem tst2 (h : a ≤ b) : a + 2 ≤ b + 2 :=
Bla.
  --^ textDocument/completion
</code></pre>
<p>In this example, the test driver <code>test_single.sh</code> will simulate an
auto-completion request at <code>Bla.</code>. The expected output is stored in
a .lean.expected.out in the json format that is part of the
<a href="https://microsoft.github.io/language-server-protocol/">Language Server
Protocol</a>.</p>
<p>This can also be used to test the following additional requests:</p>
<pre><code>--^ textDocument/hover
--^ textDocument/typeDefinition
--^ textDocument/definition
--^ $/lean/plainGoal
--^ $/lean/plainTermGoal
--^ insert: ...
--^ collectDiagnostics
</code></pre>
</li>
<li>
<p><code>tests/lean/server</code>: Tests more of the Lean <code>--server</code> protocol.
There are just a few of them, and it uses .log files containing
JSON.</p>
</li>
<li>
<p><code>tests/compiler</code>: contains tests that will run the Lean compiler and
build an executable that is executed and the output is compared to
the .lean.expected.out file. This test also contains a subfolder
<code>foreign</code> which shows how to extend Lean using C++.</p>
</li>
<li>
<p><code>tests/lean/trust0</code>: tests that run Lean in a mode that Lean doesn't
even trust the .olean files (i.e., trust 0).</p>
</li>
<li>
<p><code>tests/bench</code>: contains performance tests.</p>
</li>
<li>
<p><code>tests/plugin</code>: tests that compiled Lean code can be loaded into
<code>lean</code> via the <code>--plugin</code> command line option.</p>
</li>
</ul>
<h2 id="writing-good-tests"><a class="header" href="#writing-good-tests">Writing Good Tests</a></h2>
<p>Every test file should contain:</p>
<ul>
<li>an initial <code>/-! -/</code> module docstring summarizing the test's purpose</li>
<li>a module docstring for each test section that describes what is tested
and, if not 100% clear, why that is the desirable behavior</li>
</ul>
<p>At the time of writing, most tests do not follow these new guidelines yet.
For an example of a conforming test, see <code>tests/lean/1971.lean</code>.</p>
<h2 id="fixing-tests"><a class="header" href="#fixing-tests">Fixing Tests</a></h2>
<p>When the Lean source code or the standard library are modified, some of the
tests break because the produced output is slightly different, and we have
to reflect the changes in the <code>.lean.expected.out</code> files.
We should not blindly copy the new produced output since we may accidentally
miss a bug introduced by recent changes.
The test suite contains commands that allow us to see what changed in a convenient way.
First, we must install <a href="http://meldmerge.org/">meld</a>. On Ubuntu, we can do it by simply executing</p>
<pre><code>sudo apt-get install meld
</code></pre>
<p>Now, suppose <code>bad_class.lean</code> test is broken. We can see the problem by going to <code>tests/lean</code> directory and
executing</p>
<pre><code>./test_single.sh -i bad_class.lean
</code></pre>
<p>When the <code>-i</code> option is provided, <code>meld</code> is automatically invoked
whenever there is discrepancy between the produced and expected
outputs. <code>meld</code> can also be used to repair the problems.</p>
<p>In Emacs, we can also execute <code>M-x lean4-diff-test-file</code> to check/diff the file of the current buffer.
To mass-copy all <code>.produced.out</code> files to the respective <code>.expected.out</code> file, use <code>tests/lean/copy-produced</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Some notes on how to debug Lean, which may also be applicable to debugging Lean programs in general.</p>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p>In <code>CoreM</code> and derived monads, we use <code>trace![traceCls] &quot;msg with {interpolations}&quot;</code> to fill the structured trace viewable with <code>set_option trace.traceCls true</code>.
New trace classes have to be registered using <code>registerTraceClass</code> first.</p>
<p>Notable trace classes:</p>
<ul>
<li>
<p><code>Elab.command</code>/<code>Elab.step</code>: command/term macro expansion/elaboration steps</p>
<p>Useful options modifying these traces for debugging syntax trees:</p>
<pre><code>set_option pp.raw true
set_option pp.raw.maxDepth 10
</code></pre>
</li>
<li>
<p><code>Meta.synthInstance</code>: typeclass resolution</p>
</li>
<li>
<p><code>Meta.isDefEq</code>: unification</p>
</li>
<li>
<p><code>interpreter</code>: full execution trace of the interpreter. Only available in debug builds.</p>
</li>
</ul>
<p>In pure contexts or when execution is aborted before the messages are finally printed, one can instead use the term <code>dbg_trace &quot;msg with {interpolations}&quot;; val</code> (<code>;</code> can also be replaced by a newline), which will print the message to stderr before evaluating <code>val</code>. <code>dbgTraceVal val</code> can be used as a shorthand for <code>dbg_trace &quot;{val}&quot;; val</code>.
Note that if the return value is not actually used, the trace code is silently dropped as well.
In the language server, stderr output is buffered and shown as messages after a command has been elaborated, unless the option <code>server.stderrAsMessages</code> is deactivated.</p>
<h2 id="debuggers"><a class="header" href="#debuggers">Debuggers</a></h2>
<p><code>gdb</code>/<code>lldb</code> can be used to inspect stack traces of compiled Lean code, though they cannot print values of Lean variables and terms in any legible way yet.
For example, <code>b lean_panic_fn</code> can be used to look at the stack trace of a panic.</p>
<p>The <a href="https://github.com/rr-debugger/rr"><code>rr</code> reverse debugger</a> is an amazing tool for investigating e.g. segfaults from reference counting errors, though better hope you will never need it...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-commit-convention"><a class="header" href="#git-commit-convention">Git Commit Convention</a></h1>
<p>We are using the following convention for writing git commit messages. For pull
requests, make sure the pull request title and description follow this
convention, as the squash-merge commit will inherit title and body from the
pull request.</p>
<p>This convention is based on the one from the AngularJS project (<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#">doc</a>,
<a href="https://github.com/angular/angular.js/commits/master">commits</a>).</p>
<h2 id="format-of-the-commit-message"><a class="header" href="#format-of-the-commit-message">Format of the commit message</a></h2>
<pre><code>&lt;type&gt;: &lt;subject&gt;
&lt;NEWLINE&gt;
&lt;body&gt;
&lt;NEWLINE&gt;
&lt;footer&gt;
</code></pre>
<p><code>&lt;type&gt;</code> is:</p>
<ul>
<li>feat (feature)</li>
<li>fix (bug fix)</li>
<li>doc (documentation)</li>
<li>style (formatting, missing semicolons, ...)</li>
<li>refactor</li>
<li>test (when adding missing tests)</li>
<li>chore (maintain, ex: travis-ci)</li>
<li>perf (performance improvement, optimization, ...)</li>
</ul>
<p><code>&lt;subject&gt;</code> has the following constraints:</p>
<ul>
<li>use imperative, present tense: &quot;change&quot; not &quot;changed&quot; nor &quot;changes&quot;</li>
<li>do not capitalize the first letter</li>
<li>no dot(.) at the end</li>
</ul>
<p><code>&lt;body&gt;</code> has the following constraints:</p>
<ul>
<li>just as in <code>&lt;subject&gt;</code>, use imperative, present tense</li>
<li>includes motivation for the change and contrasts with previous
behavior</li>
</ul>
<p><code>&lt;footer&gt;</code> is optional and may contain two items:</p>
<ul>
<li>
<p>Breaking changes: All breaking changes have to be mentioned in
footer with the description of the change, justification and
migration notes</p>
</li>
<li>
<p>Referencing issues: Closed bugs should be listed on a separate line
in the footer prefixed with &quot;Closes&quot; keyword like this:</p>
<p>Closes #123, #456</p>
</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>fix: add declarations for operator&lt;&lt;(std::ostream&amp;, expr const&amp;) and operator&lt;&lt;(std::ostream&amp;, context const&amp;) in the kernel</p>
<p>The actual implementation of these two operators is outside of the
kernel. They are implemented in the file 'library/printer.cpp'. We
declare them in the kernel to prevent the following problem. Suppose
there is a file 'foo.cpp' that does not include 'library/printer.h',
but contains</p>
<pre><code>expr a;
...
std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;
...
</code></pre>
<p>The compiler does not generate an error message. It silently uses the
operator bool() to coerce the expression into a Boolean. This produces
counter-intuitive behavior, and may confuse developers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>The Lean <code>doc</code> folder contains the <a href="https://lean-lang.org/lean4/doc/">Lean Manual</a> and is
authored in a combination of markdown (<code>*.md</code>) files and literate Lean files.  The .lean files are
preprocessed using a tool called <a href="https://github.com/leanprover/leanink">LeanInk</a> and
<a href="https://github.com/Kha/alectryon">Alectryon</a> which produces a generated markdown file.  We then run
<code>mdbook</code> on the result to generate the html pages.</p>
<h2 id="settings"><a class="header" href="#settings">Settings</a></h2>
<p>We are using the following settings while editing the markdown docs.</p>
<pre><code class="language-json">{
    &quot;files.insertFinalNewline&quot;: true,
    &quot;files.trimTrailingWhitespace&quot;: true,
    &quot;[markdown]&quot;: {
        &quot;rewrap.wrappingColumn&quot;: 70
    }
}
</code></pre>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<h3 id="using-nix"><a class="header" href="#using-nix">Using Nix</a></h3>
<p>Building the manual using Nix (which is what the CI does) is as easy as</p>
<pre><code class="language-bash">$ nix build --update-input lean ./doc
</code></pre>
<p>You can also open a shell with <code>mdbook</code> for running the commands mentioned below with
<code>nix develop ./doc#book</code>. Otherwise, read on.</p>
<h3 id="manually"><a class="header" href="#manually">Manually</a></h3>
<p>To build and test the book you have to preprocess the .lean files with Alectryon then use our own
fork of the Rust tool named <a href="https://github.com/leanprover/mdbook">mdbook</a>. We have our own fork of
mdBook with the following additional features:</p>
<ul>
<li>Add support for hiding lines in other languages
<a href="https://github.com/rust-lang/mdBook/pull/1339">#1339</a></li>
<li>Make <code>mdbook test</code> call the <code>lean</code> compiler to test the snippets.</li>
<li>Ability to test a single chapter at a time which is handy when you
are working on that chapter.  See the <code>--chapter</code> option.</li>
</ul>
<p>So you need to setup these tools before you can run <code>mdBook</code>.</p>
<ol>
<li>
<p>install <a href="https://www.rust-lang.org/tools/install">Rust</a>
which provides you with the <code>cargo</code> tool for building rust packages.
Then run the following:</p>
<pre><code class="language-bash">cargo install --git https://github.com/leanprover/mdBook mdbook
</code></pre>
</li>
<li>
<p>Clone https://github.com/leanprover/LeanInk.git and run <code>lake build</code> then make the resulting
binary available to Alectryon using e.g.</p>
<pre><code class="language-bash"># make `leanInk` available in the current shell
export PATH=$PWD/build/bin:$PATH
</code></pre>
</li>
<li>
<p>Create a Python 3.10 environment.</p>
</li>
<li>
<p>Install Alectryon:</p>
<pre><code>python3 -m pip install git+https://github.com/Kha/alectryon.git@typeid
</code></pre>
</li>
<li>
<p>Now you are ready to process the <code>*.lean</code> files using Alectryon as follows:</p>
<pre><code>cd lean4/doc
alectryon --frontend lean4+markup examples/palindromes.lean --backend webpage -o palindromes.lean.md
</code></pre>
<p>Repeat this for the other .lean files you care about or write a script to process them all.</p>
</li>
<li>
<p>Now you can build the book using:</p>
<pre><code>cd lean4/doc
mdbook build
</code></pre>
</li>
</ol>
<p>This will put the HTML in a <code>out</code> folder so you can load <code>out/index.html</code> in your web browser and
it should look like https://lean-lang.org/lean4/doc/.</p>
<ol>
<li>
<p>It is also handy to use e.g. <a href="https://rust-lang.github.io/mdBook/cli/watch.html"><code>mdbook watch</code></a>
in the <code>doc/</code> folder so that it keeps the html up to date while you are editing.</p>
<pre><code class="language-bash">mdbook watch --open  # opens the output in `out/` in your default browser
</code></pre>
</li>
</ol>
<h2 id="testing-lean-snippets"><a class="header" href="#testing-lean-snippets">Testing Lean Snippets</a></h2>
<p>You can run the following in the <code>doc/</code> folder to test all the lean code snippets.</p>
<pre><code>```bash
mdbook test
```
</code></pre>
<p>and you can use the <code>--chapter</code> option to test a specific chapter that you are working on:</p>
<pre><code>```bash
mdbook test --chapter Array
```
</code></pre>
<p>Use chapter name <code>?</code> to get a list of all the chapter names.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-function-interface"><a class="header" href="#foreign-function-interface">Foreign Function Interface</a></h1>
<p>NOTE: The current interface was designed for internal use in Lean and should be considered <strong>unstable</strong>.
It will be refined and extended in the future.</p>
<p>As Lean is written partially in Lean itself and partially in C++, it offers efficient interoperability between the two languages (or rather, between Lean and any language supporting C interfaces).
This support is however currently limited to transferring Lean data types; in particular, it is not possible yet to pass or return compound data structures such as C <code>struct</code>s by value from or to Lean.</p>
<p>There are two primary attributes for interoperating with other languages:</p>
<ul>
<li><code>@[extern &quot;sym&quot;] constant leanSym : ...</code> binds a Lean declaration to the external symbol <code>sym</code>.
It can also be used with <code>def</code> to provide an internal definition, but ensuring consistency of both definitions is up to the user.</li>
<li><code>@[export sym] def leanSym : ...</code> exports <code>leanSym</code> under the unmangled symbol name <code>sym</code>.</li>
</ul>
<p>For simple examples of how to call foreign code from Lean and vice versa, see <a href="https://github.com/leanprover/lean4/blob/master/src/lake/examples/ffi">https://github.com/leanprover/lean4/blob/master/src/lake/examples/ffi</a> and <a href="https://github.com/leanprover/lean4/blob/master/src/lake/examples/reverse-ffi">https://github.com/leanprover/lean4/blob/master/src/lake/examples/reverse-ffi</a>, respectively.</p>
<h2 id="the-lean-abi"><a class="header" href="#the-lean-abi">The Lean ABI</a></h2>
<p>The Lean Application Binary Interface (ABI) describes how the signature of a Lean declaration is encoded as a native calling convention.
It is based on the standard C ABI and calling convention of the target platform.
For a Lean declaration marked with either <code>@[extern &quot;sym&quot;]</code> or <code>@[export sym]</code> for some symbol name <code>sym</code>, let <code>α₁ → ... → αₙ → β</code> be the normalized declaration's type.
If <code>n</code> is 0, the corresponding C declaration is</p>
<pre><code class="language-c">extern s sym;
</code></pre>
<p>where <code>s</code> is the C translation of <code>β</code> as specified in the next section.
In the case of an <code>@[extern]</code> definition, the symbol's value is guaranteed to be initialized only after calling the Lean module's initializer or that of an importing module; see <a href="dev/ffi.html#initialization">Initialization</a>.</p>
<p>If <code>n</code> is greater than 0, the corresponding C declaration is</p>
<pre><code class="language-c">s sym(t₁, ..., tₘ);
</code></pre>
<p>where the parameter types <code>tᵢ</code> are the C translation of the <code>αᵢ</code> as in the next section.
In the case of <code>@[extern]</code> all <em>irrelevant</em> types are removed first; see next section.</p>
<h3 id="translating-types-from-lean-to-c"><a class="header" href="#translating-types-from-lean-to-c">Translating Types from Lean to C</a></h3>
<ul>
<li>
<p>The integer types <code>UInt8</code>, ..., <code>UInt64</code>, <code>USize</code> are represented by the C types <code>uint8_t</code>, ..., <code>uint64_t</code>, <code>size_t</code>, respectively</p>
</li>
<li>
<p><code>Char</code> is represented by <code>uint32_t</code></p>
</li>
<li>
<p><code>Float</code> is represented by <code>double</code></p>
</li>
<li>
<p>An <em>enum</em> inductive type of at least 2 and at most 2^32 constructors, each of which with no parameters, is represented by the first type of <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code> that is sufficient to represent all constructor indices.</p>
<p>For example, the type <code>Bool</code> is represented as <code>uint8_t</code> with values <code>0</code> for <code>false</code> and <code>1</code> for <code>true</code>.</p>
</li>
<li>
<p><code>Decidable α</code> is represented the same way as <code>Bool</code></p>
</li>
<li>
<p>An inductive type with a <em>trivial structure</em>, that is,</p>
<ul>
<li>it is none of the types described above</li>
<li>it is not marked <code>unsafe</code></li>
<li>it has a single constructor with a single parameter of <em>relevant</em> type</li>
</ul>
<p>is represented by the representation of that parameter's type.</p>
<p>For example, <code>{ x : α // p }</code>, the <code>Subtype</code> structure of a value of type <code>α</code> and an irrelevant proof, is represented by the representation of <code>α</code>.</p>
</li>
<li>
<p><code>Nat</code> is represented by <code>lean_object *</code>.
Its runtime value is either a pointer to an opaque bignum object or, if the lowest bit of the &quot;pointer&quot; is 1 (<code>lean_is_scalar</code>), an encoded unboxed natural number (<code>lean_box</code>/<code>lean_unbox</code>).</p>
</li>
<li>
<p>A universe <code>Sort u</code>, type constructor <code>... → Sort u</code>, or proposition <code>p : Prop</code> is <em>irrelevant</em> and is either statically erased (see above) or represented as a <code>lean_object *</code> with the runtime value <code>lean_box(0)</code></p>
</li>
<li>
<p>Any other type is represented by <code>lean_object *</code>.
Its runtime value is a pointer to an object of a subtype of <code>lean_object</code> (see respective declarations in <code>lean.h</code>) or the unboxed value <code>lean_box(cidx)</code> for the <code>cidx</code>th constructor of an inductive type if this constructor does not have any relevant parameters.</p>
<p>Example: the runtime value of <code>u : Unit</code> is always <code>lean_box(0)</code>.</p>
</li>
</ul>
<h3 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h3>
<p>By default, all <code>lean_object *</code> parameters of an <code>@[extern]</code> function are considered <em>owned</em>, i.e. the external code is passed a &quot;virtual RC token&quot; and is responsible for passing this token along to another consuming function (exactly once) or freeing it via <code>lean_dec</code>.
To reduce reference counting overhead, parameters can be marked as <em>borrowed</em> by prefixing their type with <code>@&amp;</code>.
Borrowed objects must only be passed to other non-consuming functions (arbitrarily often) or converted to owned values using <code>lean_inc</code>.
In <code>lean.h</code>, the <code>lean_object *</code> aliases <code>lean_obj_arg</code> and <code>b_lean_obj_arg</code> are used to mark this difference on the C side.</p>
<p>Return values and <code>@[export]</code> parameters are always owned at the moment.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>When including Lean code as part of a larger program, modules must be <em>initialized</em> before accessing any of their declarations.
Module initialization entails</p>
<ul>
<li>initialization of all &quot;constants&quot; (nullary functions), including closed terms lifted out of other functions</li>
<li>execution of all <code>[init]</code> functions</li>
<li>execution of all <code>[builtin_init]</code> functions, if the <code>builtin</code> parameter of the module initializer has been set</li>
</ul>
<p>The module initializer is automatically run with the <code>builtin</code> flag for executables compiled from Lean code and for &quot;plugins&quot; loaded with <code>lean --plugin</code>.
For all other modules imported by <code>lean</code>, the initializer is run without <code>builtin</code>.
Thus <code>[init]</code> functions are run iff their module is imported, regardless of whether they have native code available or not, while <code>[builtin_init]</code> functions are only run for native executable or plugins, regardless of whether their module is imported or not.
<code>lean</code> uses built-in initializers for e.g. registering basic parsers that should be available even without importing their module (which is necessary for bootstrapping).</p>
<p>The initializer for module <code>A.B</code> is called <code>initialize_A_B</code> and will automatically initialize any imported modules.
Module initializers are idempotent (when run with the same <code>builtin</code> flag), but not thread-safe.
Together with initialization of the Lean runtime, you should execute code like the following exactly once before accessing any Lean declarations:</p>
<pre><code class="language-c">void lean_initialize_runtime_module();
void lean_initialize();
lean_object * initialize_A_B(uint8_t builtin, lean_object *);
lean_object * initialize_C(uint8_t builtin, lean_object *);
...

lean_initialize_runtime_module();
//lean_initialize();  // necessary if you (indirectly) access the `Lean` package

lean_object * res;
// use same default as for Lean executables
uint8_t builtin = 1;
res = initialize_A_B(builtin, lean_io_mk_world());
if (lean_io_result_is_ok(res)) {
    lean_dec_ref(res);
} else {
    lean_io_result_show_error(res);
    lean_dec(res);
    return ...;  // do not access Lean declarations if initialization failed
}
res = initialize_C(builtin, lean_io_mk_world());
if (lean_io_result_is_ok(res)) {
...

//lean_init_task_manager();  // necessary if you (indirectly) use `Task`
lean_io_mark_end_initialization();
</code></pre>
<h2 id="extern-in-the-interpreter"><a class="header" href="#extern-in-the-interpreter"><code>@[extern]</code> in the Interpreter</a></h2>
<p>The interpreter can run Lean declarations for which symbols are available in loaded shared libraries, which includes <code>@[extern]</code> declarations.
Thus to e.g. run <code>#eval</code> on such a declaration, you need to</p>
<ol>
<li>compile (at least) the module containing the declaration and its dependencies into a shared library, and then</li>
<li>pass this library to <code>lean --load-dynlib=</code> to run code <code>import</code>ing this module.</li>
</ol>
<p>Note that it is not sufficient to load the foreign library containing the external symbol because the interpreter depends on code that is emitted for each <code>@[extern]</code> declaration.
Thus it is not possible to interpret an <code>@[extern]</code> declaration in the same file.</p>
<p>See <code>tests/compiler/foreign</code> for an example.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="alectryon.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
