<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Laws - Lean Manual</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../alectryon.css">
        <link rel="stylesheet" href="../pygments.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../whatIsLean.html"><strong aria-hidden="true">1.</strong> What is Lean</a></li><li class="chapter-item "><a href="../tour.html"><strong aria-hidden="true">2.</strong> Tour of Lean</a></li><li class="chapter-item "><a href="../quickstart.html"><strong aria-hidden="true">3.</strong> Setting Up Lean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../setup.html"><strong aria-hidden="true">3.1.</strong> Extended Setup Notes</a></li></ol></li><li class="chapter-item "><a href="../tpil.html"><strong aria-hidden="true">4.</strong> Theorem Proving in Lean</a></li><li class="chapter-item "><a href="../fplean.html"><strong aria-hidden="true">5.</strong> Functional Programming in Lean</a></li><li class="chapter-item "><a href="../examples.html"><strong aria-hidden="true">6.</strong> Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../examples/palindromes.lean.html"><strong aria-hidden="true">6.1.</strong> Palindromes</a></li><li class="chapter-item "><a href="../examples/bintree.lean.html"><strong aria-hidden="true">6.2.</strong> Binary Search Trees</a></li><li class="chapter-item "><a href="../examples/tc.lean.html"><strong aria-hidden="true">6.3.</strong> A Certified Type Checker</a></li><li class="chapter-item "><a href="../examples/interp.lean.html"><strong aria-hidden="true">6.4.</strong> The Well-Typed Interpreter</a></li><li class="chapter-item "><a href="../examples/deBruijn.lean.html"><strong aria-hidden="true">6.5.</strong> Dependent de Bruijn Indices</a></li><li class="chapter-item "><a href="../examples/phoas.lean.html"><strong aria-hidden="true">6.6.</strong> Parametric Higher-Order Abstract Syntax</a></li></ol></li><li class="chapter-item "><li class="part-title">Language Manual</li><li class="chapter-item "><a href="../organization.html"><strong aria-hidden="true">7.</strong> Organizational features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../sections.html"><strong aria-hidden="true">7.1.</strong> Sections</a></li><li class="chapter-item "><a href="../namespaces.html"><strong aria-hidden="true">7.2.</strong> Namespaces</a></li><li class="chapter-item "><a href="../implicit.html"><strong aria-hidden="true">7.3.</strong> Implicit Arguments</a></li><li class="chapter-item "><a href="../autobound.html"><strong aria-hidden="true">7.4.</strong> Auto Bound Implicit Arguments</a></li></ol></li><li class="chapter-item "><a href="../syntax.html"><strong aria-hidden="true">8.</strong> Syntax Extensions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../do.html"><strong aria-hidden="true">8.1.</strong> The do Notation</a></li><li class="chapter-item "><a href="../stringinterp.html"><strong aria-hidden="true">8.2.</strong> String Interpolation</a></li><li class="chapter-item "><a href="../notation.html"><strong aria-hidden="true">8.3.</strong> User-Defined Notation</a></li><li class="chapter-item "><a href="../macro_overview.html"><strong aria-hidden="true">8.4.</strong> Macro Overview</a></li><li class="chapter-item "><a href="../elaborators.html"><strong aria-hidden="true">8.5.</strong> Elaborators</a></li><li class="chapter-item "><a href="../syntax_examples.html"><strong aria-hidden="true">8.6.</strong> Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../syntax_example.html"><strong aria-hidden="true">8.6.1.</strong> Balanced Parentheses</a></li><li class="chapter-item "><a href="../metaprogramming-arith.html"><strong aria-hidden="true">8.6.2.</strong> Arithmetic DSL</a></li></ol></li></ol></li><li class="chapter-item "><a href="../decltypes.html"><strong aria-hidden="true">9.</strong> Declaring New Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../enum.html"><strong aria-hidden="true">9.1.</strong> Enumerated Types</a></li><li class="chapter-item "><a href="../inductive.html"><strong aria-hidden="true">9.2.</strong> Inductive Types</a></li><li class="chapter-item "><a href="../struct.html"><strong aria-hidden="true">9.3.</strong> Structures</a></li><li class="chapter-item "><a href="../typeclass.html"><strong aria-hidden="true">9.4.</strong> Type classes</a></li><li class="chapter-item "><a href="../unifhint.html"><strong aria-hidden="true">9.5.</strong> Unification Hints</a></li></ol></li><li class="chapter-item "><a href="../builtintypes.html"><strong aria-hidden="true">10.</strong> Builtin Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../nat.html"><strong aria-hidden="true">10.1.</strong> Natural number</a></li><li class="chapter-item "><a href="../int.html"><strong aria-hidden="true">10.2.</strong> Integer</a></li><li class="chapter-item "><a href="../uint.html"><strong aria-hidden="true">10.3.</strong> Fixed precision unsigned integer</a></li><li class="chapter-item "><a href="../float.html"><strong aria-hidden="true">10.4.</strong> Float</a></li><li class="chapter-item "><a href="../array.html"><strong aria-hidden="true">10.5.</strong> Array</a></li><li class="chapter-item "><a href="../list.html"><strong aria-hidden="true">10.6.</strong> List</a></li><li class="chapter-item "><a href="../char.html"><strong aria-hidden="true">10.7.</strong> Character</a></li><li class="chapter-item "><a href="../string.html"><strong aria-hidden="true">10.8.</strong> String</a></li><li class="chapter-item "><a href="../option.html"><strong aria-hidden="true">10.9.</strong> Option</a></li><li class="chapter-item "><a href="../thunk.html"><strong aria-hidden="true">10.10.</strong> Thunk</a></li><li class="chapter-item "><a href="../task.html"><strong aria-hidden="true">10.11.</strong> Task and Thread</a></li></ol></li><li class="chapter-item "><a href="../functions.html"><strong aria-hidden="true">11.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../monads/intro.html"><strong aria-hidden="true">12.</strong> Monads</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../monads/functors.lean.html"><strong aria-hidden="true">12.1.</strong> Functor</a></li><li class="chapter-item "><a href="../monads/applicatives.lean.html"><strong aria-hidden="true">12.2.</strong> Applicative</a></li><li class="chapter-item "><a href="../monads/monads.lean.html"><strong aria-hidden="true">12.3.</strong> Monad</a></li><li class="chapter-item "><a href="../monads/readers.lean.html"><strong aria-hidden="true">12.4.</strong> Reader</a></li><li class="chapter-item "><a href="../monads/states.lean.html"><strong aria-hidden="true">12.5.</strong> State</a></li><li class="chapter-item "><a href="../monads/except.lean.html"><strong aria-hidden="true">12.6.</strong> Except</a></li><li class="chapter-item "><a href="../monads/transformers.lean.html"><strong aria-hidden="true">12.7.</strong> Transformers</a></li><li class="chapter-item expanded "><a href="../monads/laws.lean.html" class="active"><strong aria-hidden="true">12.8.</strong> Laws</a></li></ol></li><li class="chapter-item "><li class="part-title">Other</li><li class="chapter-item "><a href="../faq.html"><strong aria-hidden="true">13.</strong> Frequently Asked Questions</a></li><li class="chapter-item "><a href="../lean3changes.html"><strong aria-hidden="true">14.</strong> Significant Changes from Lean 3</a></li><li class="chapter-item "><a href="../syntax_highlight_in_latex.html"><strong aria-hidden="true">15.</strong> Syntax Highlighting Lean in LaTeX</a></li><li class="chapter-item "><a href="../examples/widgets.lean.html"><strong aria-hidden="true">16.</strong> User Widgets</a></li><li class="chapter-item "><a href="../semantic_highlighting.html"><strong aria-hidden="true">17.</strong> Semantic Highlighting</a></li><li class="chapter-item affix "><li class="part-title">Development</li><li class="chapter-item "><a href="../dev/index.html"><strong aria-hidden="true">18.</strong> Development Guide</a></li><li class="chapter-item "><a href="../make/index.html"><strong aria-hidden="true">19.</strong> Building Lean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../make/ubuntu.html"><strong aria-hidden="true">19.1.</strong> Ubuntu Setup</a></li><li class="chapter-item "><a href="../make/osx-10.9.html"><strong aria-hidden="true">19.2.</strong> macOS Setup</a></li><li class="chapter-item "><a href="../make/msys2.html"><strong aria-hidden="true">19.3.</strong> Windows MSYS2 Setup</a></li><li class="chapter-item "><a href="../make/wsl.html"><strong aria-hidden="true">19.4.</strong> Windows with WSL</a></li></ol></li><li class="chapter-item "><a href="../dev/bootstrap.html"><strong aria-hidden="true">20.</strong> Bootstrapping</a></li><li class="chapter-item "><a href="../dev/testing.html"><strong aria-hidden="true">21.</strong> Testing</a></li><li class="chapter-item "><a href="../dev/debugging.html"><strong aria-hidden="true">22.</strong> Debugging</a></li><li class="chapter-item "><a href="../dev/commit_convention.html"><strong aria-hidden="true">23.</strong> Commit Convention</a></li><li class="chapter-item "><a href="../dev/mdbook.html"><strong aria-hidden="true">24.</strong> Building This Manual</a></li><li class="chapter-item "><a href="../dev/ffi.html"><strong aria-hidden="true">25.</strong> Foreign Function Interface</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean Manual</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leanprover/lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="monad-laws"><a class="header" href="#monad-laws">Monad Laws</a></h1>
<p>In the previous sections you learned how to use <a href="functors.lean.html">Functors</a>,
<a href="applicatives.lean.html">Applicatives</a>, and <a href="monads.lean.html">Monads</a>, and you played with some useful
instances including <a href="monads.lean.html">Option</a>, <a href="monads.lean.html">IO</a>, <a href="readers.lean.html">Reader</a>,
<a href="states.lean.html">State</a> and <a href="except.lean.html">Except</a> and you learned about composition using <a href="transformers.lean.html">Monad
Transformers</a>.</p>
<p>So far, you've learned the concrete details you need in order to <em>use</em> monads in your Lean programs.
But there's still one more important concept you need if you want to <em>create</em> new functors,
applicatives and monads. Namely, the notion of <em>structural &quot;laws&quot;</em> -- rules that these type
classes should follow in order to meet other programmers' expectations about your code.</p>
<h2 id="life-without-laws"><a class="header" href="#life-without-laws">Life without Laws</a></h2>
<p>Remember Lean represents each of these abstract structures by a type class. Each of these type classes
has one or two main functions. So, as long as you implement those functions and it type checks, you
have a new functor, applicative, or monad, right?</p>
<p>Well not quite. Yes, your program will compile and you'll be able to use the instances. But this
doesn't mean your instances follow the mathematical constructs. If they don't, your instances won't
fulfill other programmers' expectations. Each type class has its own &quot;laws&quot;. For instance, suppose
you have the following Point Functor:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">structure</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type</var><b>: </b><span>Type 1</span></span></div></blockquote></div></small></div><span class="kt">Type</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BEq</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>BEq</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.map</var><b>: </b><span>{α β : Type} → (α → β) → Point α → Point β</span></span></div></blockquote></div></small></div><span class="nv">Point.map</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Point α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  { x := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Point α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token">,  <span class="c1">-- an example of something weird</span>
    y := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>α → β</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>s</var><b>: </b><span>Point α</span></span></div></blockquote></div></small></div><span class="nv">s</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>{α : Type} → Point α → α</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"> }

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Functor Point</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type → Type) → Type 1</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  map := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.map</var><b>: </b><span>{α β : Type} → (α → β) → Point α → Point β</span></span></div></blockquote></div></small></div>Point.map</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk0"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{ x := <span class="mi">4</span>, y := <span class="mi">3</span> }
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+</span><span class="mi">2</span>)</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.mk</var><b>: </b><span>{α : Type} → α → α → Point α</span></span></div></blockquote></div></small></div>Point.mk</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">) <span class="c1">-- { x := 4, y := 3 }</span></span></span></pre>
<p>This Point does something weird, when you <code>map</code> it because it transposes the <code>x</code> and <code>y</code> coordinates
which is not what other people would expect from a <code>map</code> function.  In fact, it breaks the rules
as you will see below.</p>
<h2 id="what-are-the-functor-laws"><a class="header" href="#what-are-the-functor-laws">What are the Functor laws?</a></h2>
<p>Functors have two laws: the <em>identity</em> law, and the <em>composition</em> law. These laws express behaviors that
your functor instances should follow. If they don't, other programmers will be very confused at the
effect your instances have on their program.</p>
<p>The identity law says that if you &quot;map&quot; the identity function (<code>id</code>) over your functor, the
resulting functor should be the same. A succinct way of showing this on a <code>List</code> functor is:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">list1</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">,</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token"> <span class="c1">-- true</span></span></span></pre>
<p>Now let's try the same test on the <code>Point</code> functor:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div><span class="nv">p1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Point</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Point.mk</var><b>: </b><span>{α : Type} → α → α → Point α</span></span></div></blockquote></div></small></div>Point.mk</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token"> <span class="c1">-- false</span></span></span></pre>
<p>Oh, and look while the <code>List</code> is behaving well, the <code>Point</code> functor fails this identity test.</p>
<p>The <em>composition</em> law says that if you &quot;map&quot; two functions in succession over a functor, this
should be the same as &quot;composing&quot; the functions and simply mapping that one super-function over the
functor.  In Lean you can compose two functions using <code>Function.comp f g</code> (or the syntax <code>f ∘ g</code>,
which you can type in VS code using <code>\o </code>) and you will get the same results from both of these
showing that the composition law holds for <code>List Nat</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">double</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">square</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk3"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">2</span>, <span class="mi">8</span>, <span class="mi">18</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token">) <span class="c1">-- [2, 8, 18]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk4"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token">)) <span class="bp">==</span> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>list1</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>list1</span><span class="alectryon-token">) <span class="c1">-- true</span>

<span class="c1">-- ok, what about the Point class?</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk5"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{ x := <span class="mi">2</span>, y := <span class="mi">8</span> }
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">) <span class="c1">-- { x := 2, y := 8 }</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk6"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">{ x := <span class="mi">8</span>, y := <span class="mi">2</span> }
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">   <span class="c1">-- { x := 8, y := 2 }</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk7"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">) <span class="bp">==</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p1</var><b>: </b><span>Point Nat</span></span></div></blockquote></div></small></div>p1</span><span class="alectryon-token">  <span class="c1">-- false</span></span></span></pre>
<p>Note that composition also fails on the bad <code>Point</code> because the x/y transpose.</p>
<p>As you can see this bad <code>Point</code> implementation violates both of the functor laws. In this case it
would not be a true functor. Its behavior would confuse any other programmers trying to use it. You
should take care to make sure that your instances make sense. Once you get a feel for these type
classes, the likelihood is that the instances you'll create will follow the laws.</p>
<p>You can also write a bad functor that passes one law but not the other like this:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bad_option_map</var><b>: </b><span>{α β : Type u} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div><span class="nv">bad_option_map</span></span><span class="alectryon-token"> {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">} : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">
  <span class="bp">|</span> _, _ <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type u} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">

</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Functor Option</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Functor</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
    map := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bad_option_map</var><b>: </b><span>{α β : Type u_1} → (α → β) → Option α → Option β</span></span></div></blockquote></div></small></div>bad_option_map</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div><span class="nv">t1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>10</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">10</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk8"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">false
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token"> <span class="c1">-- false</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk9"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token"> <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token">) <span class="bp">==</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>double</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>double</span><span class="alectryon-token"> <span class="bp">∘</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>square</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>square</span><span class="alectryon-token">) <span class="bp">&lt;$&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t1</var><b>: </b><span>Option Nat</span></span></div></blockquote></div></small></div>t1</span><span class="alectryon-token">  <span class="c1">-- true</span></span></span></pre>
<p>This fails the id law but obeys the composition law. Hopefully this explains the value of these
laws, and you don't need to see any more bad examples!</p>
<h2 id="what-are-the-applicative-laws"><a class="header" href="#what-are-the-applicative-laws">What are the Applicative Laws?</a></h2>
<p>While functors have two laws, applicatives have four laws:</p>
<ul>
<li>Identity</li>
<li>Homomorphism</li>
<li>Interchange</li>
<li>Composition</li>
</ul>
<h3 id="identity"><a class="header" href="#identity">Identity</a></h3>
<p><code>pure id &lt;*&gt; v = v</code></p>
<p>Applying the identity function through an applicative structure should not change the underlying
values or structure.  For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Applicative List</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.pure</var><b>: </b><span>{α : Type u_1} → α → List α</span></span></div></blockquote></div></small></div>List.pure</span><span class="alectryon-token">
  seq </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>List (α✝ → β✝)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Unit → List α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.bind</var><b>: </b><span>{α β : Type u_1} → List α → (α → List β) → List β</span></span></div></blockquote></div></small></div>List.bind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>List (α✝ → β✝)</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Functor.map</var><b>: </b><span>{f : Type u_1 → Type u_1} → [self : Functor f] → {α β : Type u_1} → (α → β) → f α → f β</span></span></div></blockquote></div></small></div>Functor.map</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α✝ → β✝</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Unit → List α✝</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>()</var><b>: </b><span>Unit</span></span></div></blockquote></div></small></div>()</span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chka"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">]  <span class="c1">-- [1, 2, 3]</span></span></span></pre>
<p>The <code>pure id</code> statement here is wrapping the identity function in an applicative structure
so that you can apply that over the container <code>[1, 2, 3]</code> using the Applicative <code>seq</code> operation
which has the notation <code>&lt;*&gt;</code>.</p>
<p>To prove this for all values <code>v</code> and any applicative <code>m</code> you can write this theorem:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Applicative m] [inst_1 : LawfulApplicative m] (v : m α),
  (Seq.seq (pure id) fun x =&gt; v) = v</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type u_1 → Type u_2) → Type (max (u_1 + 1) u_2)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulApplicative</var><b>: </b><span>(f : Type u_1 → Type u_2) → [inst : Applicative f] → Prop</span></span></div></blockquote></div></small></div>LawfulApplicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>id</var><b>: </b><span>{α : Type u_1} → α → α</span></span></div></blockquote></div></small></div>id</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>m α</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> :=
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkb"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkc"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="c1">-- Goals accomplished 🎉</span></span></span></pre>
<h3 id="homomorphism"><a class="header" href="#homomorphism">Homomorphism</a></h3>
<p><code>pure f &lt;*&gt; pure x = pure (f x)</code></p>
<p>Suppose you wrap a function and an object in <code>pure</code>. You can then apply the wrapped function over the
wrapped object. Of course, you could also apply the normal function over the normal object, and then
wrap it in <code>pure</code>. The homomorphism law states these results should be the same.</p>
<p>For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· + 2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">+</span> <span class="mi">2</span>)</span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkd"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>f</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>f</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>x</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) <span class="c1">-- true</span></span></span></pre>
<p>You should see a distinct pattern here. The overriding theme of almost all these laws is that these
<code>Applicative</code> types should behave like normal containers. The <code>Applicative</code> functions should not
have any side effects. All they should do is facilitate the wrapping, unwrapping, and transformation
of data contained in the container resulting in a new container that has the same structure.</p>
<h3 id="interchange"><a class="header" href="#interchange">Interchange</a></h3>
<p><code>u &lt;*&gt; pure y = pure (. y) &lt;*&gt; u</code>.</p>
<p>This law is is a little more complicated, so don't sweat it too much. It states that the order that
you wrap things shouldn't matter. One the left, you apply any applicative <code>u</code> over a pure wrapped
object. On the right, you first wrap a function applying the object as an argument. Note that <code>(· y)</code> is short hand for: <code>fun f =&gt; f y</code>. Then you apply this to the first applicative <code>u</code>. These
should be the same.</p>
<p>For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>List (Nat → Nat)</span></span></div></blockquote></div></small></div><span class="nv">g</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(· + 2)</var><b>: </b><span>Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·</span> <span class="bp">+</span> <span class="mi">2</span>)</span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chke"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>List (Nat → Nat)</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>y</span><span class="alectryon-token">) <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>g</var><b>: </b><span>List (Nat → Nat)</span></span></div></blockquote></div></small></div>g</span><span class="alectryon-token">      <span class="c1">-- true</span></span></span></pre>
<p>You can prove this with the following theorem:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>example</var><b>: </b><span>∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Applicative m] [inst_1 : LawfulApplicative m] (u : m (α → β))
  (y : α), (Seq.seq u fun x =&gt; pure y) = Seq.seq (pure fun x =&gt; x y) fun x =&gt; u</span></span></div></blockquote></div></small></div><span class="kd">example</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Applicative</var><b>: </b><span>(Type ?u.4140 → Type ?u.4139) → Type (max (?u.4140 + 1) ?u.4139)</span></span></div></blockquote></div></small></div>Applicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>LawfulApplicative</var><b>: </b><span>(f : Type u_1 → Type u_2) → [inst : Applicative f] → Prop</span></span></div></blockquote></div></small></div>LawfulApplicative</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token">] (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>m (α → β)</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>m</var><b>: </b><span>Type u_1 → Type u_2</span></span></div></blockquote></div></small></div><span class="nv">m</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>α</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">α</span></span><span class="alectryon-token">) :
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>m (α → β)</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type u_1 → Type u_2} → [self : Pure f] → {α : Type u_1} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> (<span class="bp">·</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>y</var><b>: </b><span>α</span></span></div></blockquote></div></small></div><span class="nv">y</span></span><span class="alectryon-token">) <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>m (α → β)</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> :=
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chkf"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk10"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure_seq</var><b>: </b><span>∀ {f : Type ?u.4369 → Type ?u.4368} [inst : Applicative f] [self : LawfulApplicative f] {α β : Type ?u.4369} (g : α → β)
  (x : f α), (Seq.seq (pure g) fun x_1 =&gt; x) = g &lt;$&gt; x</span></span></div></blockquote></div></small></div>pure_seq</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="c1">-- Goals accomplished 🎉</span></span></span></pre>
<h3 id="composition"><a class="header" href="#composition">Composition:</a></h3>
<p><code>u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></p>
<p>This final applicative law mimics the second functor law. It is a composition law. It states that
function composition holds across applications within the applicative:</p>
<p>For example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">u</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token">]
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>4</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">4</span></span><span class="alectryon-token">]
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>w</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">w</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>6</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">6</span></span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk11"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">9</span>, <span class="mi">10</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">11</span>, <span class="mi">12</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·+·)</var><b>: </b><span>Nat → Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>u</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>v</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>w</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>w</span><span class="alectryon-token">
<span class="c1">-- [9, 10, 10, 11, 10, 11, 11, 12]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk12"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="mi">9</span>, <span class="mi">10</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">10</span>, <span class="mi">11</span>, <span class="mi">11</span>, <span class="mi">12</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>grouping</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">grouping</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>v</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>w</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>w</span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>(·+·)</var><b>: </b><span>Nat → Nat → Nat</span></span></div></blockquote></div></small></div>(<span class="bp">·+·</span>)</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>u</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div>u</span><span class="alectryon-token"> <span class="bp">&lt;*&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>grouping</var><b>: </b><span>List Nat</span></span></div></blockquote></div></small></div><span class="nv">grouping</span></span><span class="alectryon-token">
<span class="c1">-- [9, 10, 10, 11, 10, 11, 11, 12]</span></span></span></pre>
<p>To test composition you see the separate grouping <code>(v &lt;*&gt; w)</code> then that can be used in the outer
sequence <code>u &lt;*&gt; grouping</code> to get the same final result <code>[9, 10, 10, 11, 10, 11, 11, 12]</code>.</p>
<h2 id="what-are-the-monad-laws"><a class="header" href="#what-are-the-monad-laws">What are the Monad Laws?</a></h2>
<p>Monads have three laws:</p>
<ul>
<li>Left Identity</li>
<li>Right Identity</li>
<li>Associativity</li>
</ul>
<h3 id="left-identity"><a class="header" href="#left-identity">Left Identity</a></h3>
<p>Identity laws for monads specify that <code>pure</code> by itself shouldn't really change anything about the
structure or its values.</p>
<p>Left identity is <code>x &gt;&gt;= pure = x</code> and is demonstrated by the following examples on a monadic <code>List</code>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>instance</var><b>: </b><span>Monad List</span></span></div></blockquote></div></small></div><span class="kd">instance</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Monad</var><b>: </b><span>(Type u_1 → Type u_1) → Type (u_1 + 1)</span></span></div></blockquote></div></small></div>Monad</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token">  </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  pure := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.pure</var><b>: </b><span>{α : Type u_1} → α → List α</span></span></div></blockquote></div></small></div>List.pure</span><span class="alectryon-token">
  bind := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.bind</var><b>: </b><span>{α β : Type u_1} → List α → (α → List β) → List β</span></span></div></blockquote></div></small></div>List.bind</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div><span class="nv">a</span></span><span class="alectryon-token"> := [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;apple&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;apple&quot;</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;orange&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;orange&quot;</span></span><span class="alectryon-token">]

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk13"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[<span class="s2">&quot;apple&quot;</span>, <span class="s2">&quot;orange&quot;</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token">      <span class="c1">-- [&quot;apple&quot;, &quot;orange&quot;]</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk14"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>a</var><b>: </b><span>List String</span></span></div></blockquote></div></small></div>a</span><span class="alectryon-token">  <span class="c1">-- true</span></span></span></pre>
<h3 id="right-identity"><a class="header" href="#right-identity">Right Identity</a></h3>
<p>Right identity is <code>pure x &gt;&gt;= f = f x</code> and is demonstrated by the following example:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> :=  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">+</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token">)
</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">z</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk15"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">6</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token">                  <span class="c1">-- some 6</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk16"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some <span class="mi">6</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token">                           <span class="c1">-- some 6</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk17"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">true
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>pure</var><b>: </b><span>{f : Type → Type} → [self : Pure f] → {α : Type} → α → f α</span></span></div></blockquote></div></small></div>pure</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>Nat → Option Nat</span></span></div></blockquote></div></small></div>h</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>z</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>z</span><span class="alectryon-token">            <span class="c1">-- true</span></span></span></pre>
<p>So in this example, with this specific <code>z</code> and <code>h</code>, you see that the rule holds true.</p>
<h3 id="associativity"><a class="header" href="#associativity">Associativity</a></h3>
<p>The associativity law is written as:</p>
<pre><code class="language-lean ignore">  x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= (λ x =&gt; f x &gt;&gt;= g)
</code></pre>
<p>where <code>(x : m α)</code> and <code>(f : α → m β)</code> and <code>(g : β → m γ)</code>.</p>
<p>The associativity law is difficult to parse like some of the applicative laws, but what it is saying
is that if you change the grouping of <code>bind</code> operations, you should still get the same result.
This law has a parallel structure to the other composition laws.</p>
<p>You can see this in action in the following rewrite of <code>runOptionFuncsBind</code> from <a href="monads.lean.html">monads</a>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div><span class="nv">optionFunc1</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token"> <span class="bp">-&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;&quot;</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>str</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">str</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>length</var><b>: </b><span>String → Nat</span></span></div></blockquote></div></small></div>length</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div><span class="nv">optionFunc2</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"> <span class="bp">%</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> <span class="bp">==</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>0</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>i</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">i</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toFloat</var><b>: </b><span>Nat → Float</span></span></div></blockquote></div></small></div>toFloat</span><span class="alectryon-token"> <span class="bp">*</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3.14159</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">3</span><span class="bp">.</span><span class="mi">14159</span></span><span class="alectryon-token">)

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">optionFunc3</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Float</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Float</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"> <span class="bp">&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>15.0</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="mi">15</span><span class="bp">.</span><span class="mi">0</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>floor</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div>floor</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div>toUInt32</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div>toNat</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>f</var><b>: </b><span>Float</span></span></div></blockquote></div></small></div><span class="nv">f</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ceil</var><b>: </b><span>Float → Float</span></span></div></blockquote></div></small></div>ceil</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toUInt32</var><b>: </b><span>Float → UInt32</span></span></div></blockquote></div></small></div>toUInt32</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toNat</var><b>: </b><span>UInt32 → Nat</span></span></div></blockquote></div></small></div>toNat</span><span class="alectryon-token">]


</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBind</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">runOptionFuncsBind</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div>optionFunc1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div>optionFunc2</span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div>optionFunc3</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBindGrouped</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div><span class="nv">runOptionFuncsBindGrouped</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>String</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>String</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type → Type</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) :=
   </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc1</var><b>: </b><span>String → Option Nat</span></span></div></blockquote></div></small></div>optionFunc1</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>input</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="nv">input</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> (<span class="bp">λ</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc2</var><b>: </b><span>Nat → Option Float</span></span></div></blockquote></div></small></div>optionFunc2</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">x</span></span><span class="alectryon-token"> <span class="bp">&gt;&gt;=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>optionFunc3</var><b>: </b><span>Float → Option (List Nat)</span></span></div></blockquote></div></small></div>optionFunc3</span><span class="alectryon-token">)

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk18"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some [<span class="mi">9</span>, <span class="mi">10</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBind</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div>runOptionFuncsBind</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;big&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;big&quot;</span></span><span class="alectryon-token">        <span class="c1">-- some [9, 10]</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="laws-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="laws-lean-chk19"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">some [<span class="mi">9</span>, <span class="mi">10</span>]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>runOptionFuncsBindGrouped</var><b>: </b><span>String → Option (List Nat)</span></span></div></blockquote></div></small></div>runOptionFuncsBindGrouped</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;big&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;big&quot;</span></span><span class="alectryon-token"> <span class="c1">-- some [9, 10]</span></span></span></pre>
<p>Notice here we had to insert a <code>λ</code> function just like the definition says: <code>(λ x =&gt; f x &gt;&gt;= g)</code>.
This is because unlike applicatives, you can't resolve the structure of later operations without the
results of earlier operations quite as well because of the extra context monads provide. But you can
still group their later operations into composite functions taking their inputs from earlier on, and
the result should be the same.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>While these laws may be a bit difficult to understand just by looking at them, the good news is that
most of the instances you'll make will naturally follow the laws so long as you keep it simple, so
you shouldn't have to worry about them too much.</p>
<p>There are two main ideas from all the laws:</p>
<ol>
<li>Applying the identity or pure function should not change the underlying values or structure.</li>
<li>It should not matter what order you group operations in.  Another way to state this is function
composition should hold across your structures.</li>
</ol>
<p>Following these laws will ensure other programmers are not confused by the behavior of your
new functors, applicatives and monads.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../monads/transformers.lean.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../faq.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../monads/transformers.lean.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../faq.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../alectryon.js"></script>
    </body>
</html>
