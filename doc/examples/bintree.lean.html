<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Binary Search Trees - Lean Manual</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../alectryon.css">
        <link rel="stylesheet" href="../pygments.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../whatIsLean.html"><strong aria-hidden="true">1.</strong> What is Lean</a></li><li class="chapter-item "><a href="../tour.html"><strong aria-hidden="true">2.</strong> Tour of Lean</a></li><li class="chapter-item "><a href="../quickstart.html"><strong aria-hidden="true">3.</strong> Setting Up Lean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../setup.html"><strong aria-hidden="true">3.1.</strong> Extended Setup Notes</a></li></ol></li><li class="chapter-item "><a href="../tpil.html"><strong aria-hidden="true">4.</strong> Theorem Proving in Lean</a></li><li class="chapter-item "><a href="../fplean.html"><strong aria-hidden="true">5.</strong> Functional Programming in Lean</a></li><li class="chapter-item expanded "><a href="../examples.html"><strong aria-hidden="true">6.</strong> Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../examples/palindromes.lean.html"><strong aria-hidden="true">6.1.</strong> Palindromes</a></li><li class="chapter-item expanded "><a href="../examples/bintree.lean.html" class="active"><strong aria-hidden="true">6.2.</strong> Binary Search Trees</a></li><li class="chapter-item "><a href="../examples/tc.lean.html"><strong aria-hidden="true">6.3.</strong> A Certified Type Checker</a></li><li class="chapter-item "><a href="../examples/interp.lean.html"><strong aria-hidden="true">6.4.</strong> The Well-Typed Interpreter</a></li><li class="chapter-item "><a href="../examples/deBruijn.lean.html"><strong aria-hidden="true">6.5.</strong> Dependent de Bruijn Indices</a></li><li class="chapter-item "><a href="../examples/phoas.lean.html"><strong aria-hidden="true">6.6.</strong> Parametric Higher-Order Abstract Syntax</a></li></ol></li><li class="chapter-item "><li class="part-title">Language Manual</li><li class="chapter-item "><a href="../organization.html"><strong aria-hidden="true">7.</strong> Organizational features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../sections.html"><strong aria-hidden="true">7.1.</strong> Sections</a></li><li class="chapter-item "><a href="../namespaces.html"><strong aria-hidden="true">7.2.</strong> Namespaces</a></li><li class="chapter-item "><a href="../implicit.html"><strong aria-hidden="true">7.3.</strong> Implicit Arguments</a></li><li class="chapter-item "><a href="../autobound.html"><strong aria-hidden="true">7.4.</strong> Auto Bound Implicit Arguments</a></li></ol></li><li class="chapter-item "><a href="../syntax.html"><strong aria-hidden="true">8.</strong> Syntax Extensions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../do.html"><strong aria-hidden="true">8.1.</strong> The do Notation</a></li><li class="chapter-item "><a href="../stringinterp.html"><strong aria-hidden="true">8.2.</strong> String Interpolation</a></li><li class="chapter-item "><a href="../notation.html"><strong aria-hidden="true">8.3.</strong> User-Defined Notation</a></li><li class="chapter-item "><a href="../macro_overview.html"><strong aria-hidden="true">8.4.</strong> Macro Overview</a></li><li class="chapter-item "><a href="../elaborators.html"><strong aria-hidden="true">8.5.</strong> Elaborators</a></li><li class="chapter-item "><a href="../syntax_examples.html"><strong aria-hidden="true">8.6.</strong> Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../syntax_example.html"><strong aria-hidden="true">8.6.1.</strong> Balanced Parentheses</a></li><li class="chapter-item "><a href="../metaprogramming-arith.html"><strong aria-hidden="true">8.6.2.</strong> Arithmetic DSL</a></li></ol></li></ol></li><li class="chapter-item "><a href="../decltypes.html"><strong aria-hidden="true">9.</strong> Declaring New Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../enum.html"><strong aria-hidden="true">9.1.</strong> Enumerated Types</a></li><li class="chapter-item "><a href="../inductive.html"><strong aria-hidden="true">9.2.</strong> Inductive Types</a></li><li class="chapter-item "><a href="../struct.html"><strong aria-hidden="true">9.3.</strong> Structures</a></li><li class="chapter-item "><a href="../typeclass.html"><strong aria-hidden="true">9.4.</strong> Type classes</a></li><li class="chapter-item "><a href="../unifhint.html"><strong aria-hidden="true">9.5.</strong> Unification Hints</a></li></ol></li><li class="chapter-item "><a href="../builtintypes.html"><strong aria-hidden="true">10.</strong> Builtin Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../nat.html"><strong aria-hidden="true">10.1.</strong> Natural number</a></li><li class="chapter-item "><a href="../int.html"><strong aria-hidden="true">10.2.</strong> Integer</a></li><li class="chapter-item "><a href="../uint.html"><strong aria-hidden="true">10.3.</strong> Fixed precision unsigned integer</a></li><li class="chapter-item "><a href="../float.html"><strong aria-hidden="true">10.4.</strong> Float</a></li><li class="chapter-item "><a href="../array.html"><strong aria-hidden="true">10.5.</strong> Array</a></li><li class="chapter-item "><a href="../list.html"><strong aria-hidden="true">10.6.</strong> List</a></li><li class="chapter-item "><a href="../char.html"><strong aria-hidden="true">10.7.</strong> Character</a></li><li class="chapter-item "><a href="../string.html"><strong aria-hidden="true">10.8.</strong> String</a></li><li class="chapter-item "><a href="../option.html"><strong aria-hidden="true">10.9.</strong> Option</a></li><li class="chapter-item "><a href="../thunk.html"><strong aria-hidden="true">10.10.</strong> Thunk</a></li><li class="chapter-item "><a href="../task.html"><strong aria-hidden="true">10.11.</strong> Task and Thread</a></li></ol></li><li class="chapter-item "><a href="../functions.html"><strong aria-hidden="true">11.</strong> Functions</a></li><li class="chapter-item "><a href="../monads/intro.html"><strong aria-hidden="true">12.</strong> Monads</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../monads/functors.lean.html"><strong aria-hidden="true">12.1.</strong> Functor</a></li><li class="chapter-item "><a href="../monads/applicatives.lean.html"><strong aria-hidden="true">12.2.</strong> Applicative</a></li><li class="chapter-item "><a href="../monads/monads.lean.html"><strong aria-hidden="true">12.3.</strong> Monad</a></li><li class="chapter-item "><a href="../monads/readers.lean.html"><strong aria-hidden="true">12.4.</strong> Reader</a></li><li class="chapter-item "><a href="../monads/states.lean.html"><strong aria-hidden="true">12.5.</strong> State</a></li><li class="chapter-item "><a href="../monads/except.lean.html"><strong aria-hidden="true">12.6.</strong> Except</a></li><li class="chapter-item "><a href="../monads/transformers.lean.html"><strong aria-hidden="true">12.7.</strong> Transformers</a></li><li class="chapter-item "><a href="../monads/laws.lean.html"><strong aria-hidden="true">12.8.</strong> Laws</a></li></ol></li><li class="chapter-item "><li class="part-title">Other</li><li class="chapter-item "><a href="../faq.html"><strong aria-hidden="true">13.</strong> Frequently Asked Questions</a></li><li class="chapter-item "><a href="../lean3changes.html"><strong aria-hidden="true">14.</strong> Significant Changes from Lean 3</a></li><li class="chapter-item "><a href="../syntax_highlight_in_latex.html"><strong aria-hidden="true">15.</strong> Syntax Highlighting Lean in LaTeX</a></li><li class="chapter-item "><a href="../examples/widgets.lean.html"><strong aria-hidden="true">16.</strong> User Widgets</a></li><li class="chapter-item "><a href="../semantic_highlighting.html"><strong aria-hidden="true">17.</strong> Semantic Highlighting</a></li><li class="chapter-item affix "><li class="part-title">Development</li><li class="chapter-item "><a href="../dev/index.html"><strong aria-hidden="true">18.</strong> Development Guide</a></li><li class="chapter-item "><a href="../make/index.html"><strong aria-hidden="true">19.</strong> Building Lean</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../make/ubuntu.html"><strong aria-hidden="true">19.1.</strong> Ubuntu Setup</a></li><li class="chapter-item "><a href="../make/osx-10.9.html"><strong aria-hidden="true">19.2.</strong> macOS Setup</a></li><li class="chapter-item "><a href="../make/msys2.html"><strong aria-hidden="true">19.3.</strong> Windows MSYS2 Setup</a></li><li class="chapter-item "><a href="../make/wsl.html"><strong aria-hidden="true">19.4.</strong> Windows with WSL</a></li></ol></li><li class="chapter-item "><a href="../dev/bootstrap.html"><strong aria-hidden="true">20.</strong> Bootstrapping</a></li><li class="chapter-item "><a href="../dev/testing.html"><strong aria-hidden="true">21.</strong> Testing</a></li><li class="chapter-item "><a href="../dev/debugging.html"><strong aria-hidden="true">22.</strong> Debugging</a></li><li class="chapter-item "><a href="../dev/commit_convention.html"><strong aria-hidden="true">23.</strong> Commit Convention</a></li><li class="chapter-item "><a href="../dev/mdbook.html"><strong aria-hidden="true">24.</strong> Building This Manual</a></li><li class="chapter-item "><a href="../dev/ffi.html"><strong aria-hidden="true">25.</strong> Foreign Function Interface</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean Manual</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/leanprover/lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="binary-search-trees"><a class="header" href="#binary-search-trees">Binary Search Trees</a></h1>
<p>If the type of keys can be totally ordered -- that is, it supports a well-behaved <code>≤</code> comparison --
then maps can be implemented with binary search trees (BSTs). Insert and lookup operations on BSTs take time
proportional to the height of the tree. If the tree is balanced, the operations therefore take logarithmic time.</p>
<p>This example is based on a similar example found in the <a href="https://softwarefoundations.cis.upenn.edu/vfa-current/SearchTree.html">&quot;Software Foundations&quot;</a>
book (volume 3).</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --></pre>
<p>We use <code>Nat</code> as the key type in our implementation of BSTs,
since it has a convenient total order with lots of theorems and automation available.
We leave as an exercise to the reader the generalization to arbitrary types.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div><span class="nv">Tree</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type v</var><b>: </b><span>Type (v + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> v</span><span class="alectryon-token">) </span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type v} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type v} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div><span class="nv">Tree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type v → Type v</span></span></div></blockquote></div></small></div><span class="nv">Tree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type v</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
  </span><span class="alectryon-token"><span class="k">deriving</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Repr</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Repr</span><span class="alectryon-token"></span></span></pre>
<p>The function <code>contains</code> returns <code>true</code> iff the given tree contains the key <code>k</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">Tree.contains</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.1319} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>false</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>false</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.1328} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk0"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>value<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">contains</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">contains</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>true</var><b>: </b><span>Bool</span></span></div></blockquote></div></small></div>true</span><span class="alectryon-token"></span></span></pre>
<p><code>t.find? k</code> returns <code>some v</code> if <code>v</code> is the value bound to key <code>k</code> in the tree <code>t</code>. It returns <code>none</code> otherwise.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>Tree.find<span class="bp">?</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.1660} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type u_1} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.1672} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type u_1} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"></span></span></pre>
<p><code>t.insert k v</code> is the map containing all the bindings of <code>t</code> along with a binding of <code>k</code> to <code>v</code>.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div><span class="nv">Tree.insert</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.2009} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.2024} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span>
    </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div><span class="nv">insert</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token">
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">if</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">then</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div><span class="nv">insert</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)
    </span><span class="alectryon-token"><span class="k">else</span></span><span class="alectryon-token">
      </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"></span></span></pre>
<p>Let's add a new operation to our tree: converting it to an association list that contains the key--value bindings from the tree stored as pairs.
If that list is sorted by the keys, then any two trees that represent the same map would be converted to the same list.
Here's a function that does so with an in-order traversal of the tree.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">Tree.toList</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.2378} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.2390} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">toList</span></span><span class="alectryon-token"> <span class="bp">++</span> [(</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)] <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">toList</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Tree.node (Tree.node (Tree.leaf) <span class="mi">1</span> <span class="s2">&quot;one&quot;</span> (Tree.leaf)) <span class="mi">2</span> <span class="s2">&quot;two&quot;</span> (Tree.node (Tree.leaf) <span class="mi">3</span> <span class="s2">&quot;three&quot;</span> (Tree.leaf))
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.leaf</var><b>: </b><span>{β : Type} → Tree β</span></span></div></blockquote></div></small></div>Tree.leaf</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;two&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;two&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;three&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;three&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;one&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;one&quot;</span></span><span class="alectryon-token">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2"><span class="alectryon-token"><span class="k">#eval</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[(<span class="mi">1</span>, <span class="s2">&quot;one&quot;</span>), (<span class="mi">2</span>, <span class="s2">&quot;two&quot;</span>), (<span class="mi">3</span>, <span class="s2">&quot;three&quot;</span>)]
</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.leaf</var><b>: </b><span>{β : Type} → Tree β</span></span></div></blockquote></div></small></div>Tree.leaf</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>2</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">2</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;two&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;two&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>3</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">3</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;three&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;three&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>&quot;one&quot;</var><b>: </b><span>String</span></span></div></blockquote></div></small></div><span class="s2">&quot;one&quot;</span></span><span class="alectryon-token">
      <span class="bp">|&gt;.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token"></span></span></pre>
<p>The implementation of <code>Tree.toList</code> is inefficient because of how it uses the <code>++</code> operator.
On a balanced tree its running time is linearithmic, because it does a linear number of
concatenations at each level of the tree. On an unbalanced tree it's quadratic time.
Here's a tail-recursive implementation than runs in linear time, regardless of whether the tree is balanced:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toListTR</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">Tree.toListTR</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) :=
    </span><span class="alectryon-token"><span class="k">match</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type ?u.2888} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token">
    <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type ?u.2898} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>l</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">l</span></span><span class="alectryon-token"> ((</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">) :: </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>r</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">r</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token">)</span></span></pre>
<p>We now prove that <code>t.toList</code> and <code>t.toListTR</code> return the same list.
The proof is on induction, and as we used the auxiliary function <code>go</code>
to define <code>Tree.toListTR</code>, we use the auxiliary theorem <code>go</code> to prove the theorem.</p>
<p>The proof of the auxiliary theorem is by induction on <code>t</code>.
The <code>generalizing acc</code> modifier instructs Lean to revert <code>acc</code>, apply the
induction theorem for <code>Tree</code>s, and then reintroduce <code>acc</code> in each case.
By using <code>generalizing</code>, we obtain the more general induction hypotheses</p>
<ul>
<li>
<p><code>left_ih : ∀ acc, toListTR.go left acc = toList left ++ acc</code></p>
</li>
<li>
<p><code>right_ih : ∀ acc, toListTR.go right acc = toList right ++ acc</code></p>
</li>
</ul>
<p>Recall that the combinator <code>tac &lt;;&gt; tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal,
concatenating all goals produced by <code>tac'</code>. In this theorem, we use it to apply
<code>simp</code> and close each subgoal produced by the <code>induction</code> tactic.</p>
<p>The <code>simp</code> parameters <code>toListTR.go</code> and <code>toList</code> instruct the simplifier to try to reduce
and/or apply auto generated equation theorems for these two functions.
The parameter <code>*</code> instructs the simplifier to use any equation in a goal as rewriting rules.
In this particular case, <code>simp</code> uses the induction hypotheses as rewriting rules.
Finally, the parameter <code>List.append_assoc</code> instructs the simplifier to use the
<code>List.append_assoc</code> theorem as a rewriting rule.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList_eq_toListTR</var><b>: </b><span>∀ {β : Type u_1} (t : Tree β), toList t = toListTR t</span></span></div></blockquote></div></small></div><span class="nv">Tree.toList_eq_toListTR</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR</span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR</var><b>: </b><span>{β : Type ?u.3985} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>∀ (t : Tree β) (acc : List (Nat × β)), toListTR.go t acc = toList t ++ acc</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>[]</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div>[]</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
</span><span class="alectryon-token"><span class="k">where</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>go</var><b>: </b><span>∀ (t : Tree β) (acc : List (Nat × β)), toListTR.go t acc = toList t ++ acc</span></span></div></blockquote></div></small></div><span class="nv">go</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>List</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">×</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">))
     : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR.go</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR.go</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token"> <span class="bp">++</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk6"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">generalizing</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>acc</var><b>: </b><span>List (Nat × β)</span></span></div></blockquote></div></small></div><span class="nv">acc</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">toListTR.go leaf acc <span class="bp">=</span> toList leaf <span class="bp">++</span> acc</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t, left✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>left_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go left<span class="bp">✝</span> acc <span class="bp">=</span> toList left<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>right_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go right<span class="bp">✝</span> acc <span class="bp">=</span> toList right<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk7"><hr><span class="goal-name">node</span></label><div class="goal-conclusion">toListTR.go (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) acc <span class="bp">=</span> toList (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) <span class="bp">++</span> acc</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk8"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">toListTR.go leaf acc <span class="bp">=</span> toList leaf <span class="bp">++</span> acc</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t, left✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>left_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go left<span class="bp">✝</span> acc <span class="bp">=</span> toList left<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>right_ih✝</var><span class="hyp-type"><b>: </b><span><span class="bp">∀</span> (acc : List (Nat <span class="bp">×</span> β)), toListTR.go right<span class="bp">✝</span> acc <span class="bp">=</span> toList right<span class="bp">✝</span> <span class="bp">++</span> acc</span></span></span><br><span><var>acc</var><span class="hyp-type"><b>: </b><span>List (Nat <span class="bp">×</span> β)</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk9"><hr><span class="goal-name">node</span></label><div class="goal-conclusion">toListTR.go (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) acc <span class="bp">=</span> toList (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) <span class="bp">++</span> acc</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chka"><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toListTR.go</var><b>: </b><span>{β : Type ?u.3350} → Tree β → List (Nat × β) → List (Nat × β)</span></span></div></blockquote></div></small></div>toListTR.go</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList</var><b>: </b><span>{β : Type ?u.3599} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>toList</span><span class="alectryon-token">, <span class="bp">*</span>, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>List.append_assoc</var><b>: </b><span>∀ {α : Type ?u.3862} (as bs cs : List α), as ++ bs ++ cs = as ++ (bs ++ cs)</span></span></div></blockquote></div></small></div>List.append_assoc</span><span class="alectryon-token">]</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The <code>[csimp]</code> annotation instructs the Lean code generator to replace
any <code>Tree.toList</code> with <code>Tree.toListTR</code> when generating code.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">@[csimp]</span> </span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList_eq_toListTR_csimp</var><b>: </b><span>@toList = @toListTR</span></span></div></blockquote></div></small></div><span class="nv">Tree.toList_eq_toListTR_csimp</span></span><span class="alectryon-token">
                 : <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toList</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>Tree.toList</span><span class="alectryon-token"> <span class="bp">=</span> <span class="bp">@</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.toListTR</var><b>: </b><span>{β : Type u_1} → Tree β → List (Nat × β)</span></span></div></blockquote></div></small></div>Tree.toListTR</span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkb"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkc"><span class="alectryon-token"><span class="k">funext</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.h</span></span><div class="goal-conclusion">toList t <span class="bp">=</span> toListTR t</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkd"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>toList_eq_toListTR</var><b>: </b><span>∀ {β : Type u_1} (t : Tree β), toList t = toListTR t</span></span></div></blockquote></div></small></div>toList_eq_toListTR</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>The implementations of <code>Tree.find?</code> and <code>Tree.insert</code> assume that values of type tree obey the BST invariant:
for any non-empty node with key <code>k</code>, all the values of the <code>left</code> subtree are less than <code>k</code> and all the values
of the right subtree are greater than <code>k</code>. But that invariant is not part of the definition of tree.</p>
<p>So, let's formalize the BST invariant. Here's one way to do so. First, we define a helper <code>ForallTree</code>
to express that idea that a predicate holds at every node of a tree:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p Tree.leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (Tree.node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> :
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">ForallTree</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → β → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token">)</span></span></pre>
<p>Second, we define the BST invariant:
An empty tree is a BST.
A non-empty tree is a BST if all its left nodes have a lesser key, its right nodes have a greater key, and the left and right subtrees are themselves BSTs.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">inductive</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1}, BST Tree.leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">
  <span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> :
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chke"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>?m.4774</span></span></div></blockquote></div></small></div><span class="nv">v</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>v<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> (</span><span class="alectryon-token"><span class="k">fun</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chkf"><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>?m.4774</span></span></div></blockquote></div></small></div><span class="nv">v</span></span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: unused <span class="kd">variable</span> <span class="bp">`</span>v<span class="bp">`</span> [linter.unusedVariables]</blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> <span class="bp">=&gt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> <span class="bp">→</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> <span class="bp">→</span>
     </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div><span class="nv">BST</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>?m.4774</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree ?m.4774</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token">)</span></span></pre>
<p>We can use the <code>macro</code> command to create helper tactics for organizing our proofs.
The macro <code>have_eq x y</code> tries to prove <code>x = y</code> using linear arithmetic, and then
immediately uses the new equality to substitute <code>x</code> with <code>y</code> everywhere in the goal.</p>
<p>The modifier <code>local</code> specifies the scope of the macro.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="sd">/-- The `have_eq lhs rhs` tactic (tries to) prove that `lhs = rhs`,</span>
<span class="sd">    and then replaces `lhs` with `rhs`. -/</span>
</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;have_eq &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">lhs</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>term</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>term</span><span class="alectryon-token">:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">rhs</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>term</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>term</span><span class="alectryon-token">:</span><span class="alectryon-token"><span class="k">max</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tactic</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>tactic</span><span class="alectryon-token"> <span class="bp">=&gt;</span>
  <span class="bp">`</span>(tactic<span class="bp">|</span>
    (</span><span class="alectryon-token"><span class="k">have</span></span><span class="alectryon-token"> h : <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">lhs</span></span><span class="alectryon-token"> <span class="bp">=</span> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>rhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">rhs</span></span><span class="alectryon-token"> :=
       <span class="c1">-- TODO: replace with linarith</span>
       </span><span class="alectryon-token"><span class="kd">by</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp_arith</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">at</span></span><span class="alectryon-token"> <span class="bp">*;</span> </span><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> Nat.le_antisymm <span class="bp">&lt;;&gt;</span> </span><span class="alectryon-token"><span class="k">assumption</span></span><span class="alectryon-token">
     </span><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">subst</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>lhs</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">lhs</span></span><span class="alectryon-token">))</span></span></pre>
<p>The <code>by_cases' e</code> is just the regular <code>by_cases</code> followed by <code>simp</code> using all
hypotheses in the current goal as rewriting rules.
Recall that the <code>by_cases</code> tactic creates two goals. One where we have <code>h : e</code> and
another one containing <code>h : ¬ e</code>. The simplifier uses the <code>h</code> to rewrite <code>e</code> to <code>True</code>
in the first subgoal, and <code>e</code> to <code>False</code> in the second. This is particularly
useful if <code>e</code> is the condition of an <code>if</code>-statement.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="sd">/-- `by_cases&#39; e` is a shorthand form `by_cases e &lt;;&gt; simp[*]` -/</span>
</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">macro</span></span><span class="alectryon-token"> <span class="s2">&quot;by_cases&#39; &quot;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token">:</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>term</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>term</span><span class="alectryon-token"> :  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>tactic</var><b>: </b><span>Lean.Parser.Category</span></span></div></blockquote></div></small></div>tactic</span><span class="alectryon-token"> <span class="bp">=&gt;</span>
  <span class="bp">`</span>(tactic<span class="bp">|</span> </span><span class="alectryon-token"><span class="k">by_cases</span></span><span class="alectryon-token"> <span class="bp">$</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>e</var><b>: </b><span>Lean.TSyntax `term</span></span></div></blockquote></div></small></div><span class="nv">e</span></span><span class="alectryon-token"> <span class="bp">&lt;;&gt;</span> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token"> [<span class="bp">*</span>])</span></span></pre>
<p>We can use the attribute <code>[simp]</code> to instruct the simplifier to reduce given definitions or
apply rewrite theorems. The <code>local</code> modifier limits the scope of this modification to this file.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">] </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>Tree.insert</span><span class="alectryon-token"></span></span></pre>
<p>We now prove that <code>Tree.insert</code> preserves the BST invariant using induction and case analysis.
Recall that the tactic <code>. tac</code> focuses on the main goal and tries to solve it using <code>tac</code>, or else fails.
It is used to structure proofs in Lean.
The notation <code>‹e›</code> is just syntax sugar for <code>(by assumption : e)</code>. That is, it tries to find a hypothesis <code>h : e</code>.
It is useful to access hypothesis that have auto generated names (aka &quot;inaccessible&quot;) names.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.forall_insert_of_forall</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {t : Tree β} {key : Nat} {value : β},
  ForallTree p t → p key value → ForallTree p (insert t key value)</span></span></div></blockquote></div></small></div><span class="nv">Tree.forall_insert_of_forall</span></span><span class="alectryon-token">
        (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree p t</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → ?m.6750 → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree ?m.6750</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>p key value</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → ?m.6750 → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>?m.6750</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ForallTree</var><b>: </b><span>{β : Type u_1} → (Nat → β → Prop) → Tree β → Prop</span></span></div></blockquote></div></small></div>ForallTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Nat → ?m.6750 → Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree ?m.6750</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>?m.6750</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk10"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk11"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree p t</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree p t</span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForallTree p (insert t key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk12"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">ForallTree p (insert leaf key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk13"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>p key value</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk14"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree p left✝</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p key✝ value✝</span></span></div></blockquote></div></small></div><span class="nv">hp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree p right✝</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>ForallTree p (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>ForallTree p (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p key<span class="bp">✝</span> value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">ForallTree p (insert (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk15"><span class="alectryon-token"><span class="k">rename</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">=&gt;</span> k</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">ForallTree p (insert (node left<span class="bp">✝</span> k value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk16"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">ForallTree p (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk17"><hr><span class="goal-name">node.inr</span></label><div class="goal-conclusion">ForallTree p (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk18"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">ForallTree p (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk19"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>ForallTree p (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p k value✝</span></span></div></blockquote></div></small></div><span class="nv">hp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree p right✝</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1a"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">ForallTree p (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1b"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk1c"><hr><span class="goal-name">node.inr.inr</span></label><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1d"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1e"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree p left✝</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p k value✝</span></span></div></blockquote></div></small></div><span class="nv">hp</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>ForallTree p (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk1f"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p key value</span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk20"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β✝</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>Nat <span class="bp">→</span> β<span class="bp">✝</span> <span class="bp">→</span> <span class="kt">Prop</span></span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>left✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β<span class="bp">✝</span></span></span></span><br><span><var>right✝</var><span class="hyp-type"><b>: </b><span>Tree β<span class="bp">✝</span></span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree p left<span class="bp">✝</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p k value<span class="bp">✝</span></span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree p right<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>p k value</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert left<span class="bp">✝</span> k value)</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>ForallTree p (insert right<span class="bp">✝</span> k value)</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">ForallTree p (node left<span class="bp">✝</span> k value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk21"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {left : Tree β} {key : Nat} {value : β} {right : Tree β},
  ForallTree p left → p key value → ForallTree p right → ForallTree p (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree p left✝</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>p k value</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree p right✝</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.bst_insert_of_bst</var><b>: </b><span>∀ {β : Type u_1} {t : Tree β}, BST t → ∀ (key : Nat) (value : β), BST (insert t key value)</span></span></div></blockquote></div></small></div><span class="nv">Tree.bst_insert_of_bst</span></span><span class="alectryon-token">
        {</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">} (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div>BST</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u_1} → Tree β → Prop</span></span></div></blockquote></div></small></div>BST</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk22"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk23"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BST (insert t key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk24"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>∀ {β : Type u_1}, BST leaf</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">BST (insert leaf key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk25"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop}, ForallTree p leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1}, BST leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1}, BST leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk26"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k v =&gt; k &lt; key✝) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k v =&gt; key✝ &lt; k) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₁</var><b>: </b><span>BST left✝</span></span></div></blockquote></div></small></div><span class="nv">b₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₂</var><b>: </b><span>BST right✝</span></span></div></blockquote></div></small></div><span class="nv">b₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>BST (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>BST (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>key✝</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key<span class="bp">✝</span>) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key<span class="bp">✝</span> <span class="bp">&lt;</span> k) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">BST (insert (node left<span class="bp">✝</span> key<span class="bp">✝</span> value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk27"><span class="alectryon-token"><span class="k">rename</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token"> <span class="bp">=&gt;</span> k</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">BST (insert (node left<span class="bp">✝</span> k value<span class="bp">✝</span> right<span class="bp">✝</span>) key value)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk28"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">BST
  (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>
  <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk29"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">BST (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk2a"><hr><span class="goal-name">node.inr</span></label><div class="goal-conclusion">BST (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2b"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">BST (node (insert left<span class="bp">✝</span> key value) k value<span class="bp">✝</span> right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2c"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forall_insert_of_forall</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {t : Tree β} {key : Nat} {value : β},
  ForallTree p t → p key value → ForallTree p (insert t key value)</span></span></div></blockquote></div></small></div>forall_insert_of_forall</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k_1 &lt; k) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> ‹key <span class="bp">&lt;</span> k›) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k &lt; k_1) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₁</var><b>: </b><span>BST (insert left✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₂</var><b>: </b><span>BST right✝</span></span></div></blockquote></div></small></div><span class="nv">b₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2d"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">BST (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value) <span class="k">else</span> node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk2e"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk2f"><hr><span class="goal-name">node.inr.inr</span></label><div class="goal-conclusion">BST (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk30"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> k value<span class="bp">✝</span> (insert right<span class="bp">✝</span> key value))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk31"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k_1 &lt; k) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>forall_insert_of_forall</var><b>: </b><span>∀ {β : Type u_1} {p : Nat → β → Prop} {t : Tree β} {key : Nat} {value : β},
  ForallTree p t → p key value → ForallTree p (insert t key value)</span></span></div></blockquote></div></small></div>forall_insert_of_forall</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k &lt; k_1) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> ‹k <span class="bp">&lt;</span> key›) </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₁</var><b>: </b><span>BST left✝</span></span></div></blockquote></div></small></div><span class="nv">b₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ih₂</var><b>: </b><span>BST (insert right✝ key value)</span></span></div></blockquote></div></small></div><span class="nv">ih₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk32"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> key value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> key value)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> key value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk33"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>left✝, right✝</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value✝</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h₁</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left<span class="bp">✝</span></span></span></span><br><span><var>h₂</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right<span class="bp">✝</span></span></span></span><br><span><var>b₁</var><span class="hyp-type"><b>: </b><span>BST left<span class="bp">✝</span></span></span></span><br><span><var>b₂</var><span class="hyp-type"><b>: </b><span>BST right<span class="bp">✝</span></span></span></span><br><span><var>ih₁</var><span class="hyp-type"><b>: </b><span>BST (insert left<span class="bp">✝</span> k value)</span></span></span><br><span><var>ih₂</var><span class="hyp-type"><b>: </b><span>BST (insert right<span class="bp">✝</span> k value)</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">BST (node left<span class="bp">✝</span> k value right<span class="bp">✝</span>)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
        </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk34"><span class="alectryon-token"><span class="k">exact</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₁</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k_1 &lt; k) left✝</span></span></div></blockquote></div></small></div><span class="nv">h₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h₂</var><b>: </b><span>ForallTree (fun k_1 v =&gt; k &lt; k_1) right✝</span></span></div></blockquote></div></small></div><span class="nv">h₂</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₁</var><b>: </b><span>BST left✝</span></span></div></blockquote></div></small></div><span class="nv">b₁</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b₂</var><b>: </b><span>BST right✝</span></span></div></blockquote></div></small></div><span class="nv">b₂</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
<p>Now, we define the type <code>BinTree</code> using a <code>Subtype</code> that states that only trees satisfying the BST invariant are <code>BinTree</code>s.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div><span class="nv">BinTree</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Type u</var><b>: </b><span>Type (u + 1)</span></span></div></blockquote></div></small></div><span class="kt">Type</span> u</span><span class="alectryon-token">) := { </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree</var><b>: </b><span>Type u → Type u</span></span></div></blockquote></div></small></div>Tree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> <span class="bp">//</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BST</var><b>: </b><span>{β : Type u} → Tree β → Prop</span></span></div></blockquote></div></small></div>BST</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> }

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.mk</var><b>: </b><span>{β : Type u_1} → BinTree β</span></span></div></blockquote></div></small></div><span class="nv">BinTree.mk</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>{β : Type u_1} → Tree β</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.leaf</var><b>: </b><span>∀ {β : Type u_1}, BST Tree.leaf</span></span></div></blockquote></div></small></div><span class="bp">.</span>leaf</span><span class="alectryon-token">⟩

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.contains</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Bool</span></span></div></blockquote></div></small></div><span class="nv">BinTree.contains</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div>contains</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>BinTree.find<span class="bp">?</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">def</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div><span class="nv">BinTree.insert</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token"> :=
  ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>val</var><b>: </b><span>{α : Type u_1} → {p : α → Prop} → Subtype p → α</span></span></div></blockquote></div></small></div>val</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bst_insert_of_bst</var><b>: </b><span>∀ {β : Type u_1} {t : Tree β}, BST t → ∀ (key : Nat) (value : β), BST (Tree.insert t key value)</span></span></div></blockquote></div></small></div>bst_insert_of_bst</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>property</var><b>: </b><span>∀ {α : Type u_1} {p : α → Prop} (self : Subtype p), p self.val</span></span></div></blockquote></div></small></div>property</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">⟩</span></span></pre>
<p>Finally, we prove that <code>BinTree.find?</code> and <code>BinTree.insert</code> satisfy the map properties.</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="alectryon-token"><span class="kn">attribute</span></span><span class="alectryon-token"> [</span><span class="alectryon-token"><span class="kn">local</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">simp</span></span><span class="alectryon-token">]
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.mk</var><b>: </b><span>{β : Type u_1} → BinTree β</span></span></div></blockquote></div></small></div>BinTree.mk</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.contains</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Bool</span></span></div></blockquote></div></small></div>BinTree.contains</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>BinTree.find<span class="bp">?</span></span><span class="alectryon-token">
  </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div>BinTree.insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.find?</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Option β</span></span></div></blockquote></div></small></div>Tree.find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.contains</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → Bool</span></span></div></blockquote></div></small></div>Tree.contains</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Tree.insert</var><b>: </b><span>{β : Type u_1} → Tree β → Nat → β → Tree β</span></span></div></blockquote></div></small></div>Tree.insert</span><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find_mk</var><b>: </b><span>∀ {β : Type u_1} (k : Nat), find? mk k = none</span></span></div></blockquote></div></small></div><span class="nv">BinTree.find_mk</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">)
        : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.mk</var><b>: </b><span>{β : Type u_1} → BinTree β</span></span></div></blockquote></div></small></div>BinTree.mk</span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">=</span> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>none</var><b>: </b><span>{α : Type u_1} → Option α</span></span></div></blockquote></div></small></div>none</span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Option</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>Option</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk35"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk36"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find_insert</var><b>: </b><span>∀ {β : Type u_1} (b : BinTree β) (k : Nat) (v : β), find? (insert b k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">BinTree.find_insert</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>some</var><b>: </b><span>{α : Type u_1} → α → Option α</span></span></div></blockquote></div></small></div>some</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk37"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk38"><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find<span class="bp">?</span> (insert { val := t, property := h } k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk39"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3a"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3b"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k <span class="bp">=</span>
  some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3c"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type v} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k <span class="bp">=</span>
  some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3d"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk3e"><hr><span class="goal-name">node.inr</span></label><div class="goal-conclusion">Tree.find<span class="bp">?</span> (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right) k <span class="bp">=</span> some v</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk3f"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk40"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl.node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk41"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inl.node</span></span><div class="goal-conclusion">BST left</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk42"><span class="alectryon-token"><span class="k">assumption</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk43"><span class="alectryon-token"><span class="bp">.</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk44"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
      </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk45"><span class="alectryon-token"><span class="k">cases</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl.node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk46"><span class="alectryon-token"><span class="k">apply</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k = some v</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k <span class="bp">=</span> some v</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>key <span class="bp">&lt;</span> k</span></span></span><br><span><var>a✝³</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>a✝²</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>a✝¹</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>a✝</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inl.node</span></span><div class="goal-conclusion">BST right</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk47"><span class="alectryon-token"><span class="k">assumption</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">

</span><span class="alectryon-token"><span class="kd">theorem</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree.find_insert_of_ne</var><b>: </b><span>∀ {β : Type u_1} {k k' : Nat} (b : BinTree β), k ≠ k' → ∀ (v : β), find? (insert b k v) k' = find? b k'</span></span></div></blockquote></div></small></div><span class="nv">BinTree.find_insert_of_ne</span></span><span class="alectryon-token"> (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>BinTree</var><b>: </b><span>Type u_1 → Type u_1</span></span></div></blockquote></div></small></div>BinTree</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>k ≠ k'</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">≠</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token">) (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token"> : </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>β</var><b>: </b><span>Type u_1</span></span></div></blockquote></div></small></div><span class="nv">β</span></span><span class="alectryon-token">)
        : (</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>insert</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → β → BinTree β</span></span></div></blockquote></div></small></div>insert</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>v</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">v</span></span><span class="alectryon-token">)<span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token"> <span class="bp">=</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span><span class="alectryon-token"><span class="bp">.</span></span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>find?</var><b>: </b><span>{β : Type u_1} → BinTree β → Nat → Option β</span></span></div></blockquote></div></small></div>find<span class="bp">?</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token"> := </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk48"><span class="alectryon-token"><span class="kd">by</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk49"><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> ⟨</span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token">, </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST t</span></span></div></blockquote></div></small></div><span class="nv">h</span></span><span class="alectryon-token">⟩ := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>b</var><b>: </b><span>BinTree β</span></span></div></blockquote></div></small></div><span class="nv">b</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find<span class="bp">?</span> (insert { val := t, property := h } k v) k&#39; <span class="bp">=</span> find<span class="bp">?</span> { val := t, property := h } k&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4a"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> t k&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4b"><span class="alectryon-token"><span class="k">induction</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>t</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">t</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><span class="k">with</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (Tree.insert t k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> t k&#39;</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4c"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4d"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>leaf</var><b>: </b><span>{β : Type v} → Tree β</span></span></div></blockquote></div></small></div>leaf</span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf</span></span><div class="goal-conclusion">(<span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> none <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk4e"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk4f"><hr><span class="goal-name">leaf.inr</span></label><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk50"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk51"><hr><span class="goal-name">leaf.inr</span></label><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk52"><span class="alectryon-token">(</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk53"><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk54"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk55"><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk56"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> none <span class="k">else</span> some v) <span class="bp">=</span> none</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk57"><span class="alectryon-token"><span class="k">split</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk58"><hr><span class="goal-name">leaf.inr.inr</span></label><div class="goal-conclusion">False</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk59"><span class="alectryon-token"><span class="bp">&lt;;&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inl</span></span><div class="goal-conclusion">none <span class="bp">=</span> none</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="bintree-lean-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><label class="goal-separator" for="bintree-lean-chk5a"><hr><span class="goal-name">leaf.inr.inr</span></label><div class="goal-conclusion">False</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5b"><span class="alectryon-token">(</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5c"><span class="alectryon-token"><span class="k">try</span></span><span class="alectryon-token"></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5d"><span class="alectryon-token"><span class="k">simp</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5e"><span class="alectryon-token">)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk5f"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>BST Tree.leaf</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">leaf.inr.inr</span></span><div class="goal-conclusion">False</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk60"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk61"><span class="alectryon-token"><span class="bp">|</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>node</var><b>: </b><span>{β : Type v} → Tree β → Nat → β → Tree β → Tree β</span></span></div></blockquote></div></small></div>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>left</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">left</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>value</var><b>: </b><span>β</span></span></div></blockquote></div></small></div><span class="nv">value</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>right</var><b>: </b><span>Tree β</span></span></div></blockquote></div></small></div><span class="nv">right</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k' = Tree.find? left k'</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k' = Tree.find? right k'</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> <span class="bp">=&gt;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk62"><span class="alectryon-token"><span class="k">let</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>.node</var><b>: </b><span>∀ {β : Type u_1} {key : Nat} {left right : Tree β} {value : β},
  ForallTree (fun k v =&gt; k &lt; key) left →
    ForallTree (fun k v =&gt; key &lt; k) right → BST left → BST right → BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="bp">.</span>node</span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hl</var><b>: </b><span>ForallTree (fun k v =&gt; k &lt; key) left</span></span></div></blockquote></div></small></div><span class="nv">hl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hr</var><b>: </b><span>ForallTree (fun k v =&gt; key &lt; k) right</span></span></div></blockquote></div></small></div><span class="nv">hr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bl</var><b>: </b><span>BST left</span></span></div></blockquote></div></small></div><span class="nv">bl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>br</var><b>: </b><span>BST right</span></span></div></blockquote></div></small></div><span class="nv">br</span></span><span class="alectryon-token"> := </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>h</var><b>: </b><span>BST (Tree.node left key value right)</span></span></div></blockquote></div></small></div><span class="nv">h</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>BST left <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk63"><span class="alectryon-token"><span class="k">specialize</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihl</var><b>: </b><span>BST left → Tree.find? (Tree.insert left k v) k' = Tree.find? left k'</span></span></div></blockquote></div></small></div><span class="nv">ihl</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>bl</var><b>: </b><span>BST left</span></span></div></blockquote></div></small></div><span class="nv">bl</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>BST right <span class="bp">→</span> Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk64"><span class="alectryon-token"><span class="k">specialize</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>ihr</var><b>: </b><span>BST right → Tree.find? (Tree.insert right k v) k' = Tree.find? right k'</span></span></div></blockquote></div></small></div><span class="nv">ihr</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>br</var><b>: </b><span>BST right</span></span></div></blockquote></div></small></div><span class="nv">br</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span>
    (<span class="k">if</span> k <span class="bp">&lt;</span> key <span class="k">then</span> Tree.node (Tree.insert left k v) key value right
    <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right)
    k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk65"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr</span></span><div class="goal-conclusion">Tree.find<span class="bp">?</span> (<span class="k">if</span> key <span class="bp">&lt;</span> k <span class="k">then</span> Tree.node left key value (Tree.insert right k v) <span class="k">else</span> Tree.node left k v right) k&#39; <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk66"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>key</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left key value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> key) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> key <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> key</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>key <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some v) <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> key <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> key <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk67"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>key</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">key</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝²</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right</span></span></span><br><span><var>h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some v) <span class="bp">=</span>
  <span class="k">if</span> k&#39; <span class="bp">&lt;</span> k <span class="k">then</span> Tree.find<span class="bp">?</span> left k&#39; <span class="k">else</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk68"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span><span class="alectryon-token"> <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝³</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right</span></span></span><br><span><var>h✝², h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr.inr</span></span><div class="goal-conclusion">(<span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some v) <span class="bp">=</span> <span class="k">if</span> k <span class="bp">&lt;</span> k&#39; <span class="k">then</span> Tree.find<span class="bp">?</span> right k&#39; <span class="k">else</span> some value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token"><span class="bp">;</span></span><span class="alectryon-token"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk69"><span class="alectryon-token"><span class="k">by_cases&#39;</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token">  <span class="bp">&lt;</span> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k, k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>h✝⁴</var><span class="hyp-type"><b>: </b><span>k <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k_1 <span class="bp">&lt;</span> k) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k_1 v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k_1) right</span></span></span><br><span><var>h✝³, h✝²</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝¹</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k</span></span></span><br><span><var>h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr.inr.inr</span></span><div class="goal-conclusion">v <span class="bp">=</span> value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk6a"><span class="alectryon-token"><span class="k">have_eq</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k</span></span><span class="alectryon-token"> </span><span class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>k'</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="nv">k&#39;</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>β</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> u_1</span></span></span><br><span><var>k'</var><span class="hyp-type"><b>: </b><span>Nat</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>BinTree β</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>left</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>value</var><span class="hyp-type"><b>: </b><span>β</span></span></span><br><span><var>right</var><span class="hyp-type"><b>: </b><span>Tree β</span></span></span><br><span><var>bl</var><span class="hyp-type"><b>: </b><span>BST left</span></span></span><br><span><var>br</var><span class="hyp-type"><b>: </b><span>BST right</span></span></span><br><span><var>h✝⁴</var><span class="hyp-type"><b>: </b><span>k&#39; <span class="bp">≠</span> k&#39;</span></span></span><br><span><var>ihl</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert left k&#39; v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> left k&#39;</span></span></span><br><span><var>ihr</var><span class="hyp-type"><b>: </b><span>Tree.find<span class="bp">?</span> (Tree.insert right k&#39; v) k&#39; <span class="bp">=</span> Tree.find<span class="bp">?</span> right k&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>BST (Tree.node left k&#39; value right)</span></span></span><br><span><var>hl</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k <span class="bp">&lt;</span> k&#39;) left</span></span></span><br><span><var>hr</var><span class="hyp-type"><b>: </b><span>ForallTree (<span class="k">fun</span> k v <span class="bp">=&gt;</span> k&#39; <span class="bp">&lt;</span> k) right</span></span></span><br><span><var>h✝³, h✝², h✝¹, h✝</var><span class="hyp-type"><b>: </b><span><span class="bp">¬</span>k&#39; <span class="bp">&lt;</span> k&#39;</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">node.inr.inr.inr.inr</span></span><div class="goal-conclusion">v <span class="bp">=</span> value</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="alectryon-token">
    </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="bintree-lean-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="bintree-lean-chk6b"><span class="alectryon-token"><span class="k">contradiction</span></span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../examples/palindromes.lean.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../examples/tc.lean.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../examples/palindromes.lean.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../examples/tc.lean.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../alectryon.js"></script>
    </body>
</html>
